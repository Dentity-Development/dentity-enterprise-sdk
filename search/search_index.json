{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Welcome to Trinsic's Docs \ud83d\udc4b Build the future of identity with Trinsic, infrastructure for building amazing identity products using identity wallets and verifiable credentials. CLI Tutorial <p>Dive into a sandbox CLI environment</p>        Get started        Dashboard <p>Create your ecosystem and API key</p>        Sign in        API reference <p>Explore our server- and client-side API libraries</p>        View reference        <p>Looking for our Legacy Platform's documentation?</p>"},{"location":"index-old/","title":"Introduction","text":""},{"location":"index-old/#build-the-future-of-identity","title":"Build the future of identity","text":"<p>Welcome to Trinsic, the leading infrastructure for building identity products based on identity wallets and verifiable credentials. We work with teams building IDtech products across myriad use cases, industries, and geographies.</p> <p>Trinsic is a cloud-native, web5-native developer platform, which means your product will inherit features such as user-centricity, interoperability, and decentralization out of the box. We strive to make these concepts easy to understand and use. </p> <p>We\u2019re glad you\u2019re here. We\u2019ve been developer-focused since our beginnings in 2019, and now power many of the most successful decentralized identity products. As you explore our documentation, we\u2019d love your feedback through our Slack community, the chat bubble on the page, or email. And if you want to complain (or say nice things) to the CEO, feel free to email me (Riley at trinsic.id).</p> <p>Get Started in 15 Minutes</p> <p>Try our CLI tutorial to get familiar with Trinsic through a common use case.</p> <p>Learn about Trinsic</p> <p>Dive deeper into the technology &amp; standards that power our platform. Learn More </p> <p>Product concepts</p> <p>Learn about why digital wallets and verifiable credentials enable amazing identity products. Learn More </p> <p>API reference</p> <p>Dive in to our API reference to start building right away. Explore API</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#sdks","title":"SDKs","text":""},{"location":"roadmap/#available-sdks","title":"Available SDKs","text":"<ul> <li> .NET</li> <li> Node</li> <li> Python</li> <li> Web</li> <li> Java</li> <li> Go</li> <li> Ruby</li> <li> Android</li> <li> iOS</li> </ul>"},{"location":"support/","title":"Have a Question?","text":"<p>Normally, the best way to ask quick questions is through the Trinsic Community slack channel.</p> <p>If you have a bug to report, please report it on the Github issues on our SDK. Contributions and additions to this docs site are always welcome.</p> <p>Finally, if you're interested in getting in touch with the team for any other reason, contact us at support@trinsic.id. We treat any feedback as gold.</p>"},{"location":"android/","title":"Android Sample Application","text":"<p>The Trinsic Android sample application makes it easy to interact with the Trinsic API. The sample application is located here</p>"},{"location":"android/#installation","title":"Installation","text":"<ol> <li>Clone the <code>sdk-examples</code> repository</li> <li>Open the folder <code>sdk-examples/android</code> in Android Studio</li> <li>Run gradle build for the first time, it will take a while, but it should pull down all the required <code>.jar</code> files</li> <li>You should be able to build and run the android application.</li> <li>There is an <code>sdk-examples/android-controller</code> application written in Python which allows you to issue credentials/verify proofs outside of the android application for demonstration purposes.</li> </ol> <p>Note</p> <p>If you want to included the two required Trinsic <code>.jar</code> files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p> <pre><code>def urlFile = { url, name -&gt;\nFile file = new File(\"$buildDir/download/${name}\")\nfile.parentFile.mkdirs()\nif (!file.exists()) {\nnew URL(url).withInputStream { downloadStream -&gt;\nfile.withOutputStream { fileOut -&gt;\nfileOut &lt;&lt; downloadStream\n}\n}\n}\nfiles(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\n// other dependencies\nimplementation urlFile('https://github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0')\nimplementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1')\n}\n</code></pre>"},{"location":"android/#next-steps","title":"Next Steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Java API Reference</p>"},{"location":"cli/","title":"The Trinsic CLI","text":"<p>The Trinsic CLI makes it easy to interact with the Trinsic API from your terminal. You can get the CLI on homebrew or build the CLI from source on Github. It contains all the commands of Trinsic's SDKs and makes them interactive. </p>"},{"location":"cli/#installation","title":"Installation","text":"MacOS and LinuxWindowsFrom source <p>We use homebrew to distribute the CLI packages for MacOS and Linux. Install Homebrew</p> <p>Then run these commands to install the Trinsic CLI <pre><code>brew install trinsic-id/tap/trinsic-cli\n</code></pre></p> <p>The CLI can be installed using Winget <pre><code>winget install trinsic.okapi\nwinget install trinsic.cli\n</code></pre></p> <p>The CLI can also be built from source.</p> <p>This requires the Rustup toolchain  installed on your system.</p> <p>Once installed, run this command in terminal:</p> <pre><code>cargo +nightly install --git https://github.com/trinsic-id/sdk trinsic\n</code></pre> <p>To verify that the CLI has been installed successfully, try running:</p> <pre><code>trinsic --help\n</code></pre>"},{"location":"cli/#next-steps","title":"Next Steps","text":"<p>Once the CLI is installed, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference. For more information about the CLI, read the configuration guide</p> <p>Start Walkthrough Explore API</p>"},{"location":"cli/config/","title":"Configuration","text":"<p>The CLI stores its configuration in the user's home directory in <code>~/.trinsic/</code>. This directory contains the main configuration file <code>config.toml</code> and all the profile data.</p>"},{"location":"cli/config/#show-configuration","title":"Show Configuration","text":"<p>To print the current configuration file in the terminal use:</p> <pre><code>trinsic config --show\n</code></pre> <p>Typical configuration file may look like this:</p> <pre><code>[server]\naddress = \"https://prod.trinsic.cloud\"\n\n[profile]\ndefault = \"my_profile\"\n</code></pre>"},{"location":"cli/config/#update-configuration-entry","title":"Update Configuration Entry","text":"<p>To change the configuration values, use the <code>config</code> subcommand with the attribute and its value.</p> <pre><code>trinsic config &lt;attribute_name&gt; &lt;attribute_value&gt;\n</code></pre> <p>The following attributes are currently supported:</p> <code>server-address</code> <p>Updates the default server address the CLI communicates</p> <pre><code>trinsic config --server-address https://example.com/\n</code></pre> <code>profile-default</code> <p>Updates the default profile used with the CLI</p> <pre><code>trinsic config --profile-default alice\n</code></pre>"},{"location":"cli/demo/","title":"Trinsic CLI Demo","text":""},{"location":"cli/demo/#steps-to-run","title":"Steps to Run","text":"<ul> <li>Click the green Run button</li> <li>Follow walkthrough</li> <li>Note: If you resize this window, make sure to reload the page. If not, the CLI will have display problems.</li> </ul>"},{"location":"dotnet/","title":"The Trinsic C# / .NET SDK","text":"<p>The Trinsic C# / .NET SDK makes it easy to interact with the Trinsic API from your .NET application. The most recent version of the library can be found on NuGet. The Trinsic SDK supports .NET applications written in C#, VB.NET, and F# that utilize any supported version of .NET Core. You can also find the SDKs source on Github.</p> <p>Supported runtimes</p> <p>.NET targets for iOS, Android, and Blazor are fully supported using the same package dependencies via .NET 6.</p>"},{"location":"dotnet/#installation-in-a-new-project","title":"Installation in a new project","text":"<p>Add the required dependencies from Nuget.org </p> Package Manager.NET CLIPackageReference <pre><code>PM&gt; Install-Package Trinsic\n</code></pre> <pre><code>dotnet add package Trinsic\n</code></pre> <pre><code>&lt;PackageReference Include=\"Trinsic\" /&gt;\n</code></pre> <p>To register the services with dependency injection pipeline:</p> <pre><code>services.AddTrinsic();\n</code></pre> <p>To configure additional parameters:</p> <pre><code>services.AddTrinsic(options =&gt;\n{\n// to configure the service with your auth token\noptions.ServiceOptions.AuthToken = \"&lt;auth_token&gt;\";\n})\n</code></pre> <p>The service can then be injected in your controller as</p> <pre><code>public MyController(TrinsicService trinsicService)\n{\n// init\n}\n</code></pre> <p>Alternatively, you can simply instantiate this service with or without parameters</p> <pre><code>var trinsicService = new TrinsicService();\n\n// or\n\nvar trinsicService = new TrinsicService(new ServiceOptions\n{\nAuthToken = \"&lt;auth_token&gt;\"\n});\n</code></pre>"},{"location":"dotnet/#next-steps","title":"Next Steps","text":"<p>Once the .NET SDK package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API C# API Reference</p>"},{"location":"go/","title":"The Trinsic Go SDK","text":"<p>The Trinsic Go SDK makes it easy to interact with the Trinsic API from any Go application. The most recent version of the library can be found on ____. You can find the SDKs source on Github.</p>"},{"location":"go/#installation-and-configuration","title":"Installation and Configuration","text":"<p>If you're installing go on M1, the Standard Go.dev Install Page actually defaults to still showing you an amd64 install pkg even if you're on an M1.</p> <p>You have to go to the other downloads page to get the <code>arm64</code> version for sure.</p> <ul> <li>NOTE: Windows installation is possible, but requires jumping through a few hoops. More details to come later.</li> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>You need to have CGO configured for the okapi native binary link</li> <li>Issue the following command: <pre><code>go install github.com/trinsic-id/sdk/go@latest\n</code></pre></li> <li>To test the installation, try the following go code:</li> </ul> <pre><code>trinsicService, err := sdk.NewTrinsic()\nif err != nil {\npanic(\"Account service not created\")\n}\n\nprofile, err := trinsicService.Account().LoginAnonymous(context.Background())\nif err != nil {\npanic(\"Sign in failed!\")\n}\nfmt.Printf(\"%v\\n\", profile)\n</code></pre>"},{"location":"go/#next-steps","title":"Next Steps","text":"<p>Once the go package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Go API Reference</p>"},{"location":"go/#diagnostics","title":"Diagnostics","text":""},{"location":"go/#m1-architecture-install-issues","title":"M1 Architecture install issues","text":"<pre><code>uname -m\necho $GOARCH\n</code></pre> <p>The go architecture and apple processor architecture need to match for the dynamic okapi library loading to work.</p> <p>The long story short is though, when that happens, it actually sets all the environment variables also to AMD, including <code>GOHOSTARCH</code>, <code>GOARCH</code>, and <code>GOTOOLDIR</code>. This, then causes the bad env variable to impact the linker.</p> <p>If you receive an error that looks like the following on Apple M1 architecture, it is possible that you have the wrong architecture of golang installed/configured. <pre><code>panic: unable to open a handle to the library [recovered]\npanic: unable to open a handle to the library\n</code></pre></p> <p>Try running a test code with the following env vars set: <pre><code>GOARCH=arm64  go test ./...\n</code></pre></p> <p>If <code>CGO</code> is not enabled, you will receive an error like the following: <pre><code>go/pkg/mod/github.com/trinsic-id/okapi/go@v1.6.1/okapi/didcomm.go:22:9: undefined: callOkapiNative\n</code></pre></p> <p>Try running with the following env var set: <pre><code>CGO_ENABLED=1  go test ./...\n</code></pre></p>"},{"location":"ios/","title":"The Trinsic Swift SDK","text":"<p>The Trinsic Swift SDK makes it easy to interact with the Trinsic API from any application built for iOS, MacCatalyst, or MacOS. The SDK is available for Swift Package Manager and can be added in your dependency section in <code>Package.swift</code> as follows:</p> <pre><code>dependencies: [\n    .package(name: \"Trinsic\", url: \"https://github.com/trinsic-id/sdk-swift\", branch: \"main\")\n],\n</code></pre> <p>You can find more details, source code, and tests for the Swift SDK at trinsic-id/sdk-swift.</p>"},{"location":"java/","title":"The Trinsic Java / Kotlin SDK","text":"<p>The Trinsic Java / Kotlin SDK makes it easy to interact with the Trinsic API from any Java (or Kotlin) application. The most recent version of the package is found on the Github Release. You can find the SDKs source on Github.</p>"},{"location":"java/#installation","title":"Installation","text":"<ol> <li>Add the <code>urlFile</code> code shown below to your <code>build.gradle</code>.</li> <li>Add the implementations as shown below to your <code>build.gradle</code>.</li> <li>Run <code>gradle build</code> to download the required jar files. This can take some time.</li> </ol>"},{"location":"java/#configuration","title":"Configuration","text":"<ol> <li>Okapi binaries are now included with the server <code>.jar</code> or the corresponding android <code>.aar</code> file. The gradle include process is essentially similar (see below).</li> <li>If you install to a different location for debugging, use the environment variable <code>LD_LIBRARY_PATH</code>, even on Windows.</li> <li>For Android, the okapi binaries must be copied (currently manually) to a specific location with a specific folder structure. The complete sample application is here</li> </ol> <p>Note</p> <p>If you want to include the two required Trinsic <code>.jar</code> files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p> <pre><code>def urlFile = { url, name -&gt;\nFile file = new File(\"$buildDir/download/${name}\")\nfile.parentFile.mkdirs()\nif (!file.exists()) {\nnew URL(url).withInputStream { downloadStream -&gt;\nfile.withOutputStream { fileOut -&gt;\nfileOut &lt;&lt; downloadStream\n}\n}\n}\nfiles(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\n// other dependencies\nimplementation urlFile('https://github.com/trinsic-id/okapi/releases/download/v1.6.0/trinsic-okapi-1.6.2.jar', 'trinsic-okapi-1.6.2')\n// android version:\n// implementation urlFile('https://github.com/trinsic-id/okapi/releases/download/v1.6.0/trinsic-okapi-1.6.1.aar', 'trinsic-okapi-1.6.1')\nimplementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.8.0/trinsic-services-1.8.1.jar', 'trinsic-services-1.8.1')\n}\n</code></pre>"},{"location":"java/#next-steps","title":"Next Steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Java API Reference</p>"},{"location":"learn/","title":"Introduction","text":""},{"location":"learn/#build-the-future-of-identity","title":"Build the future of identity","text":"<p>Trinsic is a cloud-native, web5-native infrastructure for building IDtech products across a variety of use cases, industries, and geographies. Products built on Trinsic inherit features such as user-centricity, interoperability, and decentralization out of the box. We strive to make these concepts easy to understand and use.   We\u2019re glad you\u2019re here.  We\u2019ve been focused on providing an exceptional developer experience for decentralized identity since our beginnings in 2019.  Today, we power many of the most successful decentralized identity products.  As you explore our documentation, we\u2019d love your feedback through our Slack community, the chat bubble on the page, or email.  And if you want to complain (or say nice things) to the CEO, feel free to email me (Riley at trinsic.id).</p>"},{"location":"learn/migrate/","title":"Migration Guidelines","text":"<p>This document outlines the differences between our existing platform based on Hyperledger Aries and our next-gen identity infrastructure known as Ecosystems. The intended audience of this document is technical business decision makers or solution architects who are looking to migrate their existing integration. For everyone else, this can also be a good source of information with comparsion between the two platforms. Please feel free to reach out to us or ask any questions in our Slack Community channels.</p>"},{"location":"learn/migrate/#motivations-to-build-the-new-platform","title":"Motivations to build the new platform","text":"<p>Open standards and protocols \u2014 One of the critical decisions to create our new platform was the ability to use standardized data models. The Verifiable Credentials Data Model was an important milestone that standardized the data exchange format. The use of Decentralized Identifiers was another important step in building solutions that will work with community supported specifications. The tight coupling of Anoncreds with the wallet, communication, and ledger layers proved to be very challenging to iterate on. While projects like Anoncreds and DIDComm that started in Indy are now on a standards track, the success of our customers in production required prioritizing existing W3C, OIDC, and other standards first.</p> <p>Cryptographic suites performance and extensibility \u2014 To provide developers the best experience possible, we needed to be able to introduce different cryptographic schemes with a standardized model in order to support different data workflows. The Data Integrity and JOSE proof formats work well with the VC model and allow extensibility and use of different cryptographic suites.</p> <p>Scalability concerns and technology lock-in \u2014 Through rigorous testing, including with customers in production, we encountered concerning scalability issues with ledger throughput for Indy Node and the indy-sdk. The complexity introduced by requiring certain artifacts to be written to a specific ledger exasperated the problem. In addition, the inflexibility of the architecture of the open source implementations made it difficult to extend our platform or build customized experiences, and we found the efforts by the open source community to address these problems lacking.</p> <p>Ledger costs and transaction fees \u2014 The high costs to write data to production Indy ledgers, and the difficulty in forecasting those costs, was a significant barrier for many developers going to production. In addition, we found the centralized governance of existing production Indy ledgers to result in \"rug-pulls\", \"single points of failure\", and sustainability concerns that introduced additional risks for developers in building a business on those networks.</p> <p>Customized wallet experience \u2014 The developers in our community consistently wanted something the Aries-based platform couldn't provide--a platform for building a customized wallet experience for their end-users, whether in a standalone wallet product or embedded into an existing product. Strong wallet products need features like cross-device synchronization, multi-language SDK support, small SDK size, offline support, all while keeping the highest security standards. See our documentation on Wallets for more.</p>"},{"location":"learn/migrate/#who-should-consider-migration","title":"Who should consider migration?","text":"<ul> <li>Teams looking to manage their own identity data in the ecosystem</li> <li>Your solution requires support for ecosystem governance</li> <li>You are looking to use open standard and need interoperability with VC, JWT, or OIDC</li> <li>Teams looking to reduce transaction costs of writing to decentralized ledgers</li> <li>Developers looking to provide custom wallet experience or customized integration</li> </ul>"},{"location":"learn/migrate/#concepts-comparison","title":"Concepts Comparison","text":"<p>Direct comparsions of technical details between the two platforms may be enclosed in colored blocks as shown below:</p> <p>Description of concepts as found in our existing platform</p> <p>Description of concepts as found in our new platform</p> <p>Let's take a deeper look of how different problems and concepts map between the existing and new platform.</p> <ul> <li>Migration Guidelines</li> <li>Motivations to build the new platform</li> <li>Who should consider migration?</li> <li>Concepts Comparison<ul> <li>Organizations and Tenants</li> <li>Identity Wallets</li> <li>Ledgers and Decentralized Infrastructure</li> <li>Credential Formats</li> <li>Anoncreds vs BBS</li> <li>Revocation Registries</li> <li>Verification Workflows</li> <li>What's next?</li> </ul> </li> </ul>"},{"location":"learn/migrate/#organizations-and-tenants","title":"Organizations and Tenants","text":"<p>The concept of an organization (or tenant) as a top level scope of identity network is now represented as a more expanded concept of an ecosystem. Ecosystems represent your enterprise network as an established model of relationships between different entities. Providers define the contracts of how verifiable data can be exchanged and governed in an ecosystem. Individual holders of credentials will be assigned a wallet within the scope of an ecosystem.</p> <p>Managed through Provider API endpoints</p> <p>Managed through Provider Service SDK</p>"},{"location":"learn/migrate/#identity-wallets","title":"Identity Wallets","text":"<p>In our existing platform, our customers needed to choose between requiring end-users to download a standalone wallet to self-manage their credentials and keys on their mobile device, or use our Wallet API to create a purely custodial service. The former had the security advantage of all private material being stored on the user's device, but comes with the cost of backup &amp; recovery questions, inability to access data from secondary devices/browers, and difficulty embedding into existing applications. The latter afforded a fantastic developer experience (indeed, 95% of developers chose this option to ship products quickly) but introduced a less-than-ideal security profile, and was inaccessible in an offline setting.</p> <p>Our new platform uses hyrbid wallets with cloud-hosted credential storage and edge-managed access security through our SDK. Wallet data is accessed through our new API which allows developers to take advantage of a great experience building their own wallet-enabled products as a web app, mobile app, etc.  without compromising on security or offline usage. Custodial wallets also allow us to support more standards and interoperability profiles, leading to better products for our customers.</p> <p>Future considerations</p> <p>We are actively working to improve the features of our hybrid wallet experience with things like encrypted query/search and the ability to export wallet data to remove lock-in for users.</p>"},{"location":"learn/migrate/#ledgers-and-decentralized-infrastructure","title":"Ledgers and Decentralized Infrastructure","text":"<p>Our existing platform uses decentralized ledgers based on Indy Node to store credential artifacts in a public network. These artifacts include DIDs, Schemas, Credential Definitions and Revocation Registries. The instances of Indy networks we supported includes Sovrin, Indicio and BCovrin, for production and test workloads.</p> <p>The new platform uses decentralized ledgers or blockchains for DIDs only. Schemas and revocation registries use web infrastructure and are published at a well known URL address. The need for credential definitions is removed thanks to improved credential signature schemes. The new platform is built independent of a single network, thus being truly ledger agnostic. Currently supported networks for DIDs are Bitcoin (using layer 2 protocol Sidetree), Indy, EBSI, with more to come.</p> <ul> <li>Indy Node based</li> <li>Supported networks: Sovrin, Indicio, BCovrin</li> </ul> <ul> <li>Self-asserting identifiers</li> <li>Bitcoin layer 2 using Sidetree</li> <li>Indy Node based</li> <li>EBSI</li> </ul>"},{"location":"learn/migrate/#credential-formats","title":"Credential Formats","text":"<p>Credential formats were generally represented as a collection of attributes defined with a schema and version. The schemas were represented with a schema ID like <code>Gs6cQcvrtWoZKsbBhD3dQJ:2:Certificate of Attendance:2.0</code>. This schema contains attributes and is associated with a transaction on the ledger. The flat schemas do not support any heirarchy, severely limiting the use cases they are suited for.</p> <p>Under the new model, schemas are part of a credential template and are represented as a standard JSON schema where each attribute can be defined with a specific data type and extended properties. Additionally, templates reference a JSON-LD vocabulary which adds semantic definition of each attribute under the Linked Data guidelines. This vocabulary is used during the process of issuance and verification of credentials, technically known as data canonicalization. The schemas are not written on a ledger, they are instead published as a web resource with a static URL.</p> <ul> <li>Schemas are represented as JSON array of attribute names</li> </ul> <pre><code>{\n\"name\": \"Identity Card\",\n\"version\": \"1.0\",\n\"attr_names\": [\n\"firstName\",\n\"lastName\",\n\"dateOfBirth\"\n]\n}\n</code></pre> <ul> <li>Credential definitions are required and their value must be written on the ledger</li> <li>Data structure supports flat hierarchy</li> <li>Schema ID is identifier <code>Gs6cQcvrtWoZKsbBhD3dQJ:2:Certificate of Attendance:2.0</code></li> </ul> <ul> <li>Schemas are JSON objects</li> </ul> <pre><code>{\n\"id\": \"https://schema.trinsic.cloud/default/identity-card\",\n\"properties\": {\n\"firstName\": { \"type\": \"string\", \"description\": \"First or given name\" },\n\"lastName\": { \"type\": \"string\", \"description\": \"Last or family name\" },\n\"dateOfBirth\": { \"type\": \"datetime\", \"description\": \"Date of birth\" },\n}\n}\n</code></pre> <ul> <li>No credential definition required</li> <li>Data structure can be any complex JSON graph</li> <li>Schema ID is URL <code>https://schema.trinsic.cloud/default/identity-card</code></li> </ul>"},{"location":"learn/migrate/#anoncreds-vs-bbs","title":"Anoncreds vs BBS","text":"<p>Our existing platform uses the cryptographic suite Anoncreds to provide different credential exchange solutions. In our new platform, we introduced BBS signatures, as a replacement for Anoncreds. The main motivating factors for this are:</p> <ul> <li>Standardized data models for the signature suites using JSON Schema and Verifiable Credentials</li> <li>Fast and small signature size (cryptographic signatures based on pairing-friendly curves)</li> <li>No setup required (Anoncreds require creating credential definition which is very slow and requires ledger write)</li> <li>Flexible proof format (Data Integrity, JOSE)</li> </ul>"},{"location":"learn/migrate/#revocation-registries","title":"Revocation Registries","text":"<p>Revocation in our existing platform uses Anoncreds with RSA accumulator. This is a powerful, privacy preserving solution, but cumbersome when it comes to maintaining accumulator states. It requires publishing revocation registry state on the ledger, writing to the ledger whenever credentials are revoked, publishing a tails file on a web resource, and layering workarounds on top to make it all scalable. Even after all of this, the performance of holders creating non-revocation proofs was below an acceptable level for production use.</p> <p>Our new platform uses a more flexible solution based on Status List. This approach is based on a W3C community published specification with a much simpler and flexible approach to revocation, albeit without the same privacy guarantees.</p> <p>Future considerations</p> <p>At the time of writing this article, we are actively looking to add support for additional revocation solutions, such as one based on accumulators for pairing-friendly curves. These are significant improvements over RSA accumulators with an improvement in data privacy, performance and scalability.</p>"},{"location":"learn/migrate/#verification-workflows","title":"Verification Workflows","text":"<p>In our existing platform we use Aries protocols to exchange data between two parties. To verify a credential, the verifier must prepare a verification request and communicate this to the user via URL (or QR code). The holder then resolves the URL (or scans the code) to respond to the request, most often through use of a mobile app.</p> <p>Our new platform is intended to support a broader set of verification options for developers, including widely-adopted protocols such as OpenID Connect. Today we support an interactive protocol based on OpenID for Verifiable Presentations (OIDC4VP). During verification, the holder is redirected to Trinsic's OIDC provider (which can be customized on a per-ecosystem basis) which allows the user access to their identity wallet to respond to the verification request. We'll continue to support additional verification protocols as they're needed by our customers to succeed in production.</p> <p>An example verification request payload</p> <pre><code>{\n\"name\": \"verification-request\",\n\"version\": \"1.0\",\n\"attributes\": [{\n\"policyName\": \"verify-name\",\n\"attributeNames\": [ \"firstName\" ],\n\"restrictions\": [{\n\"issuerID\": \"string\"\n}]\n}],\n\"predicates\": [],\n\"revocationRequirement\": {\n\"validNow\": true\n}\n}\n</code></pre> <p>Example OIDC request for verifiable presentation</p> <pre><code>GET https://connect.trinsic.cloud/authorize?\n    &amp;response_type=code\n    &amp;scope=openid\n    &amp;client_id=client01\n    &amp;trinsic%3Aecosystem=example\n    &amp;redirect_uri=https://example.com/callback\n    &amp;nonce=n-0S6_WzA2Mj HTTP/1.1\n</code></pre>"},{"location":"learn/migrate/#whats-next","title":"What's next?","text":"<p>If you're looking to do a migration and need help, please drop us a line on Slack or Intercom. Otherwise, feel free to explore our documentation, try the Getting Started guide or watch an introductory video.</p>"},{"location":"learn/concepts/credentials/","title":"Credentials","text":"<p>\"Verifiable Credentials,\" or \"VCs\" are standardized, cryptographically-signed documents that attest information about an entity. They provide an interoperable way to attest and authenticate any kind of data in an IDtech application. </p> <p>A verifiable credential is a set of tamper-evident claims and metadata that cryptographically prove who issued it. - W3C VC Data Model </p> <p>Trinsic currently uses a verifiable credential format that complies with the W3C Verifiable Credential Data Model, but we\u2019re watching competing standards as they evolve as well (e.g. IETF ACDCs, ISO 13018-5, Anoncreds, etc). For more details on the standards we use, see Standards.</p> <p>Verifiable credentials are unique from other kinds of digital documents because they enable you to verify the following things:</p> <ol> <li>The original issuing entity (the source of the data)</li> <li>It was issued to the entity presenting it (the subject of the data)</li> <li>It hasn't been tampered with (the veracity of the data)</li> <li>Whether the issuer revoked the credential as of a particular point in time (the status of the data)</li> </ol>"},{"location":"learn/concepts/credentials/#components-of-a-credential","title":"Components of a credential","text":"<p>To break down the components of a credential, we'll use a digital driver's license as an example.</p>"},{"location":"learn/concepts/credentials/#attributes-or-data","title":"Attributes, or Data","text":"<p>The most important part of a credential is the data inside it. </p> <p>In its simplest form, attributes are key-value pairs in a JSON object. These attributes are populated at issuance on a per-credential basis, based on a template. </p> <p>Verifiers use attributes to request only the data from credentials that they need\u2014for example, an age-checking verifier may only request <code>date_of_birth</code> from a driver\u2019s license, instead of the entire credential.</p>"},{"location":"learn/concepts/credentials/#templates","title":"Templates","text":"<p>Credentials are issued from templates, an abstraction provided by Trinsic that makes getting started and ongoing management easy, and enables tighter integration with other features in the Trinsic platform such as governance. </p> <p>When you understand how templates work in Trinsic, you will get the benefits of semantic interoperability and governance without needing to understand the nuts and bolts of schemas, credential definitions, JSON-LD contexts, credential restrictions, and more. See our page on templates to learn more.</p>"},{"location":"learn/concepts/credentials/#issuer-id","title":"Issuer ID","text":"<p>Each verifiable credential is cryptographically signed by an issuer. The signature, along with the issuer\u2019s identifier, strongly identify the issuer, ensuring anyone can verify the source of the data in the credential. </p> <p>In order to be trustworthy, the issuer\u2019s identifier needs to be resolvable. We use decentralized identifiers (DIDs), a W3C standard, for this purpose. Trinsic offers providers a number of choices of DID methods for the issuers in their ecosystems. To learn more, read more about the standards we use and Decentralized Identifiers .</p>"},{"location":"learn/concepts/dids/","title":"Identifiers","text":"<p>Identifiers are necessary to assign to each member of an ecosystem. Identity wallets manage identifiers on behalf of the holder(s) that control(s) the wallet. At Trinsic we use \u201cDecentralized identifiers\u201d or \u201cDIDs,\u201d which are globally unique, cryptographically verifiable URIs that are not bound to a centralized registry. DIDs provide a way to separate a public identifier from public keys, which is an important requirement for resilient identity systems.</p> <p>Trinsic aims to abstract the complexities of interacting with DIDs. So while this section provides a brief explanation of DIDs, you do not need to fully grok them in order to build an identity product using Trinsic.</p>"},{"location":"learn/concepts/dids/#working-with-dids-on-trinsic","title":"Working with DIDs on Trinsic","text":"<p>Trinsic abstracts away the complexities of working with DIDs and cryptography, allowing you to focus on building a great identity product.</p> <p>When a\u00a0wallet\u00a0is created, Trinsic generates a cryptographic keypair and securely stores it; this keypair is what will be used to sign credentials issued by the wallet. Additionally, Trinsic generates a\u00a0<code>did:key</code>\u00a0DID, which encodes the public information necessary to verify credentials issued by the wallet; this is the\u00a0<code>public_did</code>\u00a0field of the wallet object.</p>"},{"location":"learn/concepts/dids/#upgrading-wallet-dids","title":"Upgrading wallet DIDs","text":"<p>Providers of an ecosystem may\u00a0upgrade\u00a0a wallet's DID from\u00a0<code>did:key</code>\u00a0to any of the supported methods via\u00a0a simple API call. Trinsic handles the complexities of this process for you.</p> <p>Many DID methods are based on distributed ledgers (commonly known as \"blockchains\"), so the following should be kept in mind when registering a DID which uses a ledger:</p> <p>Data Protection &amp; Compliance</p> <p>When writing an identifier to a public, permanent resource like a blockchain, it\u2019s important to be extremely sure that you want that data to remain there forever. Permanence is hard to reconcile with \u201cright to be forgotten\u201d, and the jury is out on whether a person\u2019s identifiers are considered personal data (literally).</p> <p>For these reasons, it is ***not advisable*** to upgrade DIDs controlled by wallets whose holders are natural persons (in other words, DIDs whose subjects are persons). If doing so is important for your use case, we strongly recommend you work with legal counsel to understand all of the implications before doing so.</p> <p>Fees</p> <p>Depending on the DID method chosen, registering a DID may incur a transaction fee, which is different for each ledger.\u00a0You are responsible for these fees.</p> <p>Documentation of these fees will be visible through our Dashboard and on our pricing page. You should keep this in mind before you programmatically upgrade DIDs through the API.</p> <p>Resolution</p> <p>Newly-registered DIDs may not be immediately resolvable, as distributed ledgers typically cannot provide instantaneous writes.</p> <p>Issuance and verification of credentials against these DIDs will still function during this time, but only within the Trinsic platform.</p>"},{"location":"learn/concepts/dids/#supported-did-methods","title":"Supported DID methods","text":"<p>More to come</p> <p>We plan to grow the list of supported DID methods as we move towards general availability of this feature.</p> Method Type Notes did:key Static The default DID method for all wallets. Encodes key information directly in the DID; as a result, key rotation requires a new DID. did:ion Distributed Ledger ION\u00a0is a sidetree/Layer-2 protocol on top of the Bitcoin blockchain. Registering a DID will incur charges if on the\u00a0mainnet\u00a0network. IonOptions did:indy Distributed Ledger INDY\u00a0is a Hyperledger Indy based protocol. Registering a DID will incur charges if on the main (non test) networks IndyOptions did:sov Distributed Ledger SOV\u00a0is the Sovrin Foundation implementation of Hyperledger Indy. It is available via <code>did:indy:sov</code> prefix Under IndyOptions above. Registering a DID will incur charges if on the main (non test / non builder) networks"},{"location":"learn/concepts/dids/#how-dids-work","title":"How DIDs work","text":"<p>DIDs serve as identifiers of subjects (most commonly individuals); a DID can be\u00a0resolved\u00a0to retrieve a\u00a0DID Document, which contains information about how to interact with the subject (chiefly, cryptographic keys associated with the subject which can be used for verifiable communication).</p> <p>DIDs always start with the\u00a0<code>did:</code>\u00a0prefix, but can take many forms. For example,\u00a0<code>did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK</code>\u00a0and\u00a0<code>did:ion:test:EiAmZrbqZvA81YBazg3h3ucL6yIYh_OTxaj_W_ggeEEOYA</code>\u00a0are both valid DIDs, but have different prefixes. In this example,\u00a0<code>key</code>\u00a0and\u00a0<code>ion</code>\u00a0are the\u00a0DID methods\u00a0of these DIDs, respectively. Other DID Methods include\u00a0<code>did:web</code>\u00a0and\u00a0<code>did:indy</code>.</p> <p>The method of a DID determines how to resolve it to retrieve its associated DID Document; there is no common strategy. For example, resolving a\u00a0<code>did:ion</code>\u00a0DID requires interacting with the Bitcoin blockchain, whereas\u00a0<code>did:key</code>\u00a0encodes the DID Document information (the public keys) directly into the URI enabling local resolution.</p> <p>To sum up, the goal of DIDs is to provide a decentralized, method-agnostic way to bundle an identifier together with information about how to communicate and interact securely with the subject attached to said identifier.</p>"},{"location":"learn/concepts/dids/#how-dids-are-used-with-verifiable-credentials","title":"How DIDs are used with Verifiable Credentials","text":"<p>DIDs are an important component of the Verifiable Credential spec; they enable decentralized issuance and verification of credentials.</p> <p>When someone (or something) issues a credential, they set the\u00a0<code>issuer</code>\u00a0field of the credential to their own DID. They then generate (or \"sign\") a cryptographic proof against the contents of the credential, using their own private key, and store this in the\u00a0<code>proof</code>\u00a0field of the credential. Critically, the public key associated with the signing private key is stored in the issuer's DID Document.</p> <p>To verify a credential, the verifier first looks at the DID contained in the\u00a0<code>issuer</code>\u00a0field, and resolves it to fetch its associated DID Document. Then, they verify that the\u00a0<code>proof</code>\u00a0field is cryptographically valid and was generated using one of the keys in the DID Document.</p> <p>This scheme enables verifiers to guarantee the following cryptographically:</p> <ol> <li>The\u00a0<code>issuer</code>\u00a0claimed by the credential is indeed the entity which signed the credential.</li> <li>The credential has not been modified or tampered with; all of its data is attested to by the issuer.</li> </ol> <p>Using this scheme, one must only maintain a list of issuer DIDs which are trusted to issue credentials of a certain type (this might be accomplished by a\u00a0Trust Registry); the cryptographic guarantees of DIDs and VCs take care of the rest.</p>"},{"location":"learn/concepts/ecosystems/","title":"Ecosystems","text":"<p>Successful IDtech products can be broken down into two parts:</p> <ul> <li>An identity wallet: a representation of the user\u2019s identity</li> <li>An ecosystem: the set of entities that can interact with the user\u2019s identity</li> </ul> <p>We\u2019ve made it simple to create both wallets and ecosystems. In this section, we\u2019ll break down the concept of an ecosystem and how Trinsic can help your ecosystem thrive. </p>"},{"location":"learn/concepts/ecosystems/#example-ecosystems-from-the-real-world","title":"Example ecosystems from the real world","text":"<p>Trust ecosystems exist all around us, but most are analog and disaggregated and therefore filled with inefficiencies and fraud. </p> <p>Example 1: Payments</p> <p>The first trust ecosystems to go digital were payments networks. Visa, MasterCard, etc. introduced a standard mechanism to allow consumers to make purchases with any merchant using credit from any bank. Visa created an enduring business while simultaneously unlocking value for all participants involved.</p> <ul> <li>Wallet: users carry credit cards in their physical, leather wallets and in digital wallets held on their smart devices</li> <li>Ecosystem: the banks issuing cards and the merchants accepting cards comprise this ecosystem</li> </ul> <p>Example 2: Health pass</p> <p>As Covid-19 swept over the world, jurisdictions of various kinds sought to curb the spread of the virus by instituting restrictions on travel. Health passes of various kinds were instituted across the world, enabling people who could prove recent test results or vaccine status to travel again.</p> <ul> <li>Wallet: users obtained paper vaccine cards or digital health passes on their smart devices</li> <li>Ecosystem: the airlines, community centers, venues, cruise lines, customs departments, and other places where health passes were accepted comprise this ecosystem</li> </ul>"},{"location":"learn/concepts/ecosystems/#anatomy-of-a-trust-ecosystem","title":"Anatomy of a trust ecosystem","text":"<p>As you dive deeper into how ecosystems work, it\u2019s helpful to understand wallets, credentials, templates, and governance. We recommend referring back and forth between these pages to get a full picture. </p> <p>Provider</p> <p>At the helm of a trust ecosystem sits a provider. Providers develop IDtech products that solve problems for the other participants of an ecosystem. They develop the software, adoption tools (such as templates), business models &amp; incentives, and the governance that enables an ecosystem to be successful. </p> <p>Before Stripe, every growing internet platform had a payments team. Today, every growing internet platform has an Identity team. Identity verification is a core piece of economic infrastructure for online businesses. - Stripe </p> <p>Trinsic\u2019s product is built from the ground-up for providers. Successful providers usually target a niche or industry with the aim of creating a sustainable, growing business.</p> <p>Issuer</p> <p>Issuers are the source of data in an ecosystem. They transform their raw data into verifiable credentials that are usable more broadly via the user\u2019s wallet. Common examples of issuers include universities issuing diplomas, insurance companies issuing insurance cards, and libraries issuing library cards\u2014but with digitally-native identity, so many more possibilities open up. </p> <p>Every company in the world already has valuable data and functionality housed within its systems. Capitalizing on this value, however, means liberating it from silos and making it interoperable and reusable in different contexts - Google\u2019s \u201cState of API Economy 2021\u201d report </p> <p>The value for issuers often stems from extending their existing business into a new, digital format, which can either reduce costs or increase revenue. </p> <p>Proxy issuers can help bootstrap an ecosystem\u2014this is when a provider uses 3rd-party APIs to verify user attributes to seed their wallet (e.g. using Twilio to verify a phone number vs getting a verifiable credential issued by AT&amp;T).</p> <p>Holder or Subject</p> <p>Holder is the umbrella term for the person or organization who controls the identity in question. Whenever possible, you should build your product to put the holder in control of their own identity. The holder should always be able to give consent before their data is shared. </p> <p>Usually, the \u201csubject\u201d of the identity and the holder are the same. When Alice controls an identity wallet filled with Alice\u2019s credentials, the holder and subject are the same. However, if Alice is a 2-year-old child, it\u2019s likely that Alice\u2019s father, Bob, will control her wallet. In that case, Bob is the holder and Alice is the subject. The holder and subject can also differ for business wallets, refugee/homeless/incarcerated person wallets, or for inanimate objects. </p> <p>Verifier </p> <p>Verifiers are the big winners of the move toward digital identity. They\u2019re able to verify people with less friction and more trust, all with less expense than current systems.</p> <p>Providers serve two important roles relative to verifiers. First, providers can aggregate the trusted issuers inside &amp; outside the ecosystem to enable verifiers to trust a credential without maintaining their own infrastructure or registry. Second, providers can impose rules on verifiers to make sure they\u2019re following data minimization and data protection best practices and regulations.</p>"},{"location":"learn/concepts/templates/","title":"Templates","text":"<p>\u201cTemplates\u201d enable providers to define the formats and types of verifiable credentials that will be issued to holders inside and outside of their ecosystem. Templates are an abstraction provided by Trinsic that makes getting started easy, improves ongoing management of an ecosystem, and enables tighter integration with other features in the Trinsic platform such as governance. </p> <p>When you understand how templates work in Trinsic, you inherit the benefits of semantic interoperability and governance without needing to understand the nuts and bolts of schemas, credential definitions, JSON-LD contexts, credential restrictions, and more. </p> <p>Defining templates isn\u2019t just helpful for issuer and verifier adoption, but when done correctly also provides increased interoperability. </p>"},{"location":"learn/concepts/templates/#how-to-approach-templates-in-your-product","title":"How to approach templates in your product","text":"<p>Templates enable you to to remove friction for the participants of your ecosystem. Therefore first and foremost, you should ensure whatever templates you provide satisfy the needs of the issuers and verifiers you\u2019re working with. </p> <p>Before you create your own template, you should consider whether a schema for your desired credential already exists. Standards bodies or industry best-practice sometimes dictate the kind of data that should be issued. For example, you may use this document as a starting point for a Covid-19 vaccine credential or this document for a driver\u2019s license in the USA.</p> <p>Verifiable credentials enable the decoupling of datasets included in issuance and verification. That means you can provide a template for issuers to issue 10 attributes, even if the verifiers in your ecosystem only plan to verify 5 attributes. This allows you to be forward-looking as you\u2019re considering the use cases for a given credential. That said, for simplicity\u2019s sake, we tend to recommend limiting the attributes included in a template to those which you can reasonably foresee being useful in the near- to medium-term.</p> <p>Because attributes from different credentials can be combined together into a \u201ccompound proof\u201d, you do not need to worry about fitting all possible attributes into a single template.</p> <p>We do not yet allow you to edit a template after it\u2019s been created, nor do we pre-populate or recommend templates for you to use. If you\u2019re interested in either of these features, please contact us.</p>"},{"location":"learn/concepts/templates/#anatomy-of-a-template","title":"Anatomy of a template","text":"<p>When you create a template, you do the following:</p> <ol> <li>Decide which attributes are included</li> <li>Determine the type of data (string, integer, etc.)</li> <li>Optionally, you may<ol> <li>Assign optional or required value to each attribute</li> <li>Provide a description of the attribute</li> </ol> </li> </ol> <p>Trinsic then translates that input into a JSON schema and JSON-LD context, generates a unique identifier for the template, creates a resource with the details needed to maintain public resolution of these artifacts, and hosts it on your behalf.</p> <p>For example, you may create a template with the following:</p> <pre><code>{\n    \"name\": {\n        \"type\": \"string\",\n        \"description\": \"Name of the business\",\n    },\n    \"website\": {\n        \"type\": \"string\",\n        \"description\": \"More information about the business\"\n    },\n    \"rating\":{\n        \"type\": \"number\",\n        \"description\": \"rating on scale of 1-10\",\n        \"optional\": false\n    },\n    \"details\":{\n        \"type\": \"string\",\n        \"description\": \"An individual's last name\",\n        \"optional\": false\n    }\n}\n</code></pre> <p>This will create a Template that has the following structure:</p> <pre><code>TemplateData {\n    id: \"urn:template:alices-local-guides:review\",\n    name: \"Review\",\n    version: 1,\n    fields: {\n        \"name\": TemplateField {\n            description: \"Name of the business\",\n            optional: false,\n            r#type: String,\n        },\n        \"rating\": TemplateField {\n            description: \"rating on scale of 1-10\",\n            optional: false,\n            r#type: Number,\n        },\n        \"details\": TemplateField {\n            description: \"An individual's last name\",\n            optional: false,\n            r#type: String,\n        },\n        \"website\": TemplateField {\n            description: \"More information about the business\",\n            optional: false,\n            r#type: String,\n        },\n    },\n    allow_additional_fields: true,\n    schema_uri: \"https://staging-schema.trinsic.cloud/__default/review\",\n    context_uri: \"https://staging-schema.trinsic.cloud/__default/review/context\",\n    ecosystem_id: \"__default\",\n    r#type: \"VerifiableCredential\",\n}\n</code></pre> <p>At any point you can view the <code>schema_uri</code> and the <code>context_uri</code> in the browser as raw JSON.</p>"},{"location":"learn/concepts/trust-registries/","title":"Governance","text":"<p>Governance refers to the ability of a provider to add business and legal policies into an ecosystem that improve adoption, safety, and compliance, while enabling some providers to monetize their ecosystem in a sustainable way. While governance is a massive topic, Trinsic\u2019s implementation is lightweight and is designed to enable the minimum amount of overhead needed to effectively bootstrap an ecosystem.</p>"},{"location":"learn/concepts/trust-registries/#the-case-for-governance","title":"The case for governance","text":"<p>Adding the right amount of governance to your product can enable both faster growth and lower risk. </p> <p>For example, you can grow faster when you remove the need for verifiers to maintain their own list of trustworthy issuers\u2014especially in an ecosystem with dozens of issuers that may come and go. This is an important way some successful providers have monetized their ecosystem. </p> <p>Risk in your ecosystem can be reduced by imposing rules that must be met before credentials can be issued or verified inside or outside of your ecosystem. For example, you can improve safety for the users of your wallet by restricting their ability to share sensitive data with unverified 3rd-parties (or warning them beforehand).</p>"},{"location":"learn/concepts/trust-registries/#anatomy-of-governance","title":"Anatomy of governance","text":"<p>One of the core building blocks of our governance implementation is the interoperable Trust Registry specified at the Trust Over IP Foundation. We contributed to the original\u00a0specification and later open-sourced our implementation so the broader community can benefit from these features.</p>"},{"location":"learn/concepts/verifications/","title":"Verifications","text":"<p>\u201cVerifications\u201d are the mechanism for requesting, consenting, and authenticating data from the verifiable credentials in an identity wallet. Designing the way verifications will be done in your ecosystem is arguably the most important step in creating a successful IDtech product.</p> <p>A verification is an abstraction provided by Trinsic that makes it easy to utilize W3C-conformant Verifiable Presentations, OpenID Connect, zero-knowledge proofs, and other identity specifications without having to spend months becoming an expert or writing your own implementation. For more on the standards we use, see our Standards page.</p>"},{"location":"learn/concepts/verifications/#components-of-a-verification","title":"Components of a verification","text":"<p>\u201cVerifications\u201d are privacy-preserving proofs of data inside a VC. </p>"},{"location":"learn/concepts/verifications/#zero-knowledge-proofs","title":"Zero-knowledge proofs","text":"<p>A zero-knowledge proof (ZKP) allows a user to prove some information is true without revealing the information itself. The classic example is proving you\u2019re over 18 without revealing your birthdate. </p> <p>The most important application of zero-knowledge proofs today is the ability to perform selective disclosure on the contents of a verifiable credential. This is important for the obvious privacy reasons related to data minimization, but it\u2019s also important for the less-obvious privacy reasons of obfuscating correlatable identifiers from verifiable presentations. Over time we will add the capability for providers to offer verifiers ZKP capabilities that allow computation on values, such as \u2018is <code>GPA</code> &gt; 3.0\u2019 or \u2018does <code>home_address</code> contain \u201cNew York\u201d\u2019.</p> <p>Trinsic\u2019s ZKP implementation is based on an extremely performant algorithm called BBS+ which is currently being standardized. To learn more, see here.</p>"},{"location":"learn/concepts/verifications/#using-verifications-in-your-app","title":"Using verifications in your app","text":"<p>Instantly verifying data to access a product, service, or resource is the bread and butter of an IDtech product. It is the point value is realized. So designing a user-friendly method for verification is critical.</p> <p>Verification policies</p> <p>The first step is to understand the requirements for verification, according to your use case\u2014verifying medical information will have much different constraints than verifying a library card. And authenticating medical information online differs from sharing that information in-person.</p> <p>As a provider, you should design verification templates that enable verifiers to collect the data they need from a holder, but no more. This is an important part of the data minimization principles underpinning Trinsic\u2019s infrastructure.</p> <p>Most successful providers do significant product work to understand how users and verifiers want to interact to optimize their desired outcomes. Trinsic\u2019s infrastructure is designed to enable this verification flexibility across various use cases.</p>"},{"location":"learn/concepts/verifications/#adoption-tools","title":"Adoption tools","text":"<p>The first adoption tool Trinsic provides for easy verifications is an OpenID Connect (OIDC) service to fit into the legacy systems and mental models that verifiers and consumers are already familiar with. To learn more about setting up your OIDC app, please see the following documentation.</p>"},{"location":"learn/concepts/wallets/","title":"Wallets","text":"<p>In Trinsic\u2019s platform, identity wallets are secure, partitioned data stores scoped to a single holder, capable of storing and sharing credentials and proofs. Endless configurations of wallets exist (custodial, non-custodial, etc.) each with different trade-offs; Trinsic has designed a hybrid-cloud wallet system intended to strike the ideal balance between security and usability: </p> <ul> <li>Cloud-based data store</li> <li>Edge-based authentication keys</li> </ul> <p>For a deeper-dive into how hybrid-cloud wallets work, see our security overview. </p>"},{"location":"learn/concepts/wallets/#how-to-use-wallets-in-your-app","title":"How to use wallets in your app","text":"<p>When a user creates an account in your product, you will create a wallet for them. This wallet is tied to the user\u2019s identity using either their email or phone number (for now) - after the user enters the code to prove control of their identifier and claim their wallet, you\u2019ll be off to the races. </p> <p>The user will interact with and control their wallet through your application. From your application\u2019s perspective, wallet storage should be treated in parallel with the database you use to manage user data. When users obtain credentials from inside or outside your ecosystem, those credentials will be inserted in the wallet. When users want to share credentials with verifiers, your product will need to obtain user consent before the data is shared.</p> <p>All the participants in an ecosystem, not just holders, will technically have wallets behind them. Therefore any participant can issue, verify, and hold credentials to establish trust.</p>"},{"location":"learn/platform/security/","title":"Security Infrastructure","text":""},{"location":"learn/platform/security/#overview","title":"Overview","text":"<p>Our cloud services are secured using a novel method of authentication based on zero-knowledge proofs . This approach allows us to introduce passwordless client authentication with improved security and user experience.</p> <p>Compared to traditional security methods that store users' credentials on the server, our approach relies on a one-time client/server negotiation without storing any user secrets on our servers. All secrets are stored with the user client and are entirely in their control. During authentication, users present proof of knowledge of these secret tokens, instead of the actual tokens. This proof is generated with each request and is unique for that request only.</p>"},{"location":"learn/platform/security/#oberon-auth-scheme","title":"Oberon Auth Scheme","text":"<p>A succinct ZKP protocol for authentication. It works by using techniques similar to Identity-Based/Attribute-Based signatures.</p> <p>Oberon allows endpoints to issue multi-factor capable tokens to consumers who can prove their validity without disclosing the tokens themselves and without requiring email, SMS, or authenticator apps. Endpoints only need to store a single public key and not any tokens. An attacker that breaks into the server doesn't have any password/token files to steal and only would see a public key. The proof of token validity is only 256 bytes while the token itself is only 48 bytes. The issuing party and verifying servers can be separate entities.</p> <p>Crypto details for Oberon </p>"},{"location":"learn/platform/security/#account-registration","title":"Account Registration","text":"<p>The below diagram illustrates how client and server interact during the registration process and negotiate the data for authentication:</p> <pre><code>sequenceDiagram\n  actor Client\n  Client-&gt;&gt;Server: Register new account or ecosystem\n  Server--&gt;&gt;Client: Generated token\n  Note right of Server: Does not store token\n  opt\n    Note over Client: Apply multi-factor security&lt;br /&gt;using PIN, word phrase, HSM, etc.&lt;br /&gt;by cryptographically blinding&lt;br/&gt;the secret token\n    Client-&gt;&gt;Client: Token protection\n  end\n  Client-&gt;&gt;Client: Save token on client device</code></pre>"},{"location":"learn/platform/security/#api-requests","title":"API Requests","text":"<p>The process of making authenticated API requests against the server involves generating a proof of knowledge and appending it to the request headers. This proof is:</p> <ul> <li>valid for a limited time only (order of milliseconds)</li> <li>unique and cannot be used twice (replay protection)</li> <li>bound to the current request payload (mitm protection)</li> </ul> <p>The diagram below illustrates the steps involved in generating proof and interacting with the server.</p> <pre><code>sequenceDiagram\n    actor U as Client\n    participant A as Server\n\n    U-&gt;&gt;U: Read Token\n    U-&gt;&gt;U: Generate proof of token\n    U-&gt;&gt;A: Make API Request\n    note right of U: Proof is added in 'Authorization' header\n\n    A-&gt;&gt;A: Check authorization\n\n    alt sucesss\n        A-&gt;&gt;A: Process request\n        A--&gt;&gt;U: Send response\n    else invalid proof\n        A--&gt;&gt;U: 401 Unauthorized\n    end</code></pre>"},{"location":"learn/platform/standards/","title":"Technology Standards","text":"<p>Our mission is to make the world more accessible. Standards are an important part of the Trinsic product stack because they help us do that. On this page we\u2019ll break down the standards we use and why.</p>"},{"location":"learn/platform/standards/#standards-make-the-world-go-round","title":"Standards make the world go round","text":""},{"location":"learn/platform/standards/#interoperability","title":"Interoperability","text":"<p>There are two kinds of interoperability:</p> <ol> <li>Everyone use the same code, so everyone is interoperable</li> <li>Everyone implements against a common, agreed-upon standard</li> </ol> <p>Realistically any interoperability will exist on a spectrum between these two points. For example, NFTs on Ethereum will be interoperable within that community if they adhere to the EIP-721, and seed phrase recovery for Bitcoin wallets will be interoperable within that community if they adhere to the BIP39 standard. While these examples sound like the second kind of interoperability, those NFTs won\u2019t work outside the Ethereum ecosystem, nor will Bitcoin wallets be recoverable into wallets that don\u2019t support Bitcoin. Thus we see, interoperability is not a black &amp; white issue.</p> <p>Various levels of interoperability have been achieved in subsets of the decentralized identity community in the past as well. We believe interoperability is good for business. One of Trinsic\u2019s key values is to achieve and maintain interoperability in areas that are important for our customers, so they can spend their time building a valuable business. Doing so will drive adoption of their products and help us achieve our mission.</p>"},{"location":"learn/platform/standards/#avoid-vendor-lock-in","title":"Avoid vendor lock-in","text":"<p>Standards also enable us to avoid vendor lock-in\u2014that is, avoid locking our customers in to Trinsic. We want to be chosen by our customers because we make them more successful by providing a valuable service, not because they\u2019re stuck. In addition, trapping users in a silo we control is antithetical to our values. And finally, we\u2019ve seen that \u201cno vendor lock-in\u201d is also a valuable benefit for our customers as they take their solutions to market. </p>"},{"location":"learn/platform/standards/#standards-we-use","title":"Standards we use","text":"<p>Standards are such a core part of how we all do business that it wouldn\u2019t make sense to add each one here. Instead, we\u2019ll surface standards that are important for interoperability, security, privacy, or other feature that you probably care about.</p>"},{"location":"learn/platform/standards/#verifiable-credentials","title":"Verifiable Credentials","text":"<p>Verifiable credentials provide an interoperable way to attest and authenticate any kind of data. For an introductory post to verifiable credentials, see our blog post on the subject.</p> <p>A verifiable credential is a set of tamper-evident claims and metadata that cryptographically prove who issued it.</p> <p>From the W3C VC Data Model</p> <p>Trinsic currently uses a verifiable credential format that complies with the W3C Verifiable Credential Data Model, but we\u2019re watching competing standards as they evolve as well (e.g. IETF ACDCs, ISO 13018-5, Anoncreds, etc).</p>"},{"location":"learn/platform/standards/#openid-connect","title":"OpenID Connect","text":"<p>OpenID Connect (OIDC) is a widely-adopted standard for enabling federated identity online. Because consumers are so used to it, and verifiers have adopted it so widely, it is an ideal way to verify credentials. The only difference is that instead of redirecting users to an external Idp such as Facebook or Google, users are redirected to their own wallet to provide a verification.</p>"},{"location":"learn/platform/standards/#decentralized-identifiers","title":"Decentralized Identifiers","text":"<p>Decentralized identifiers (DIDs) are globally unique, cryptographically verifiable URIs that are not bound to a centralized registry. They\u2019re like URLs without ICANN and domain registrars. In identity, DIDs provide an abstraction between a public identifier and public keys. For more information on DIDs, see our section on DIDs.</p>"},{"location":"learn/platform/standards/#linked-data","title":"Linked Data","text":"<p>When ecosystem participants begin to share credentials outside of your immediate ecosystem, a problem starts to occur. Suppose a credential has an attribute \u201cclass\u201d. How can a verifier know whether that word means 1. class, as in school; 2. class, as in category; or 3. class, as in sophistication? Although this might be a silly example, semantic interoperability is one of the most challenging problems to widespread data usefulness. Linked Data helps solve this by providing a format for representing structured data with self-contained descriptors of that data.</p> <p>Linked data is to spreadsheets and databases what the web of hypertext documents is to word processor files.                                                                                                            -\u00a0W3C Wiki on Linked Data</p>"},{"location":"learn/platform/standards/#additional-standards","title":"Additional standards","text":"<p>Revocation List 2020 - This approach allows us to add a simple, interoperable revocation mechanism for credentials. A revocation approach based on cryptographic accumulators is on our roadmap.</p> <p>BBS+ Signatures - A cryptographic signature algorithm based on BLS keys that leads to very small, performant ZKP-enabled credentials. Is on standards stack but is not a standard.</p>"},{"location":"learn/platform/standards/#linked-data_1","title":"Linked Data","text":"<p>When we consider credentials getting exchanged online far and wide, a problem starts to occur - how does everyone know what everyone else means when they show a credential? To the rescue comes Linked Data, a format for representing structured data with self-contained descriptors of that data.</p> <p>\"Linked data is to spreadsheets and databases what the web of hypertext documents is to word processor files\" - W3C Wiki on Linked Data</p>"},{"location":"learn/platform/webhooks/","title":"Webhooks","text":""},{"location":"learn/platform/webhooks/#overview","title":"Overview","text":"<p>Webhooks enable providers to receive updates whenever an event occurs within the ecosystem they manage.</p>"},{"location":"learn/platform/webhooks/#configuring-webhooks","title":"Configuring Webhooks","text":"<p>Webhooks may be added to an ecosystem using the AddWebhook method; either with the CLI or any of our SDKs. In the future, webhooks will also be configurable through a web dashboard.</p> <p>The value chosen for <code>secret</code> should be a UTF-8 string which is never published anywhere; it is used to verify incoming payloads.</p> <p>The <code>destination_url</code> of a webhook must be an HTTPS URL accessible over the internet.</p> <p>Event Type Filtering</p> <p>By default, webhooks receive all event types, but can be configured to only trigger on a specific subset of events.</p>"},{"location":"learn/platform/webhooks/#receiving-webhooks","title":"Receiving Webhooks","text":"<p>Webhooks are sent as JSON strings to your specified URL (which must be HTTPS) using the <code>POST</code> method. </p>"},{"location":"learn/platform/webhooks/#structure","title":"Structure","text":"<p>The structure of a webhook payload is shown below. Event-specific information is stored in <code>data</code>; its format is event-specific.</p> Field Type Description id <code>string</code> The ID of the event which triggered the webhook timestamp <code>timestamp</code> The timestamp of the event type <code>string</code> The type of event contained in <code>data</code> data <code>object</code> The data of the event itself"},{"location":"learn/platform/webhooks/#verification","title":"Verification","text":"<p>Because webhooks are URLs accessible over the internet, it is necessary to ensure that a webhook comes from Trinsic and not an attacker.    </p> <p>Trinsic hashes payloads using HMAC-SHA256, using the <code>secret</code> you provided during webhook creation as the secret key, and the raw <code>POST</code> body as the message contents.</p> <p>This hash is sent with the request as a header named <code>trinsic-signature-sha256</code>.</p> <p>Your verification code may look like the following pseudocode:</p> Pseudocode <pre><code>message = http_request.post_body\ntrinsic_hash = http_request.headers[\"trinsic-signature-sha256\"]\n\ncomputed_hash = hmac_sha256(message, stored_secret)\n\nif(trinsic_hash != computed_hash) {\n    // Hash failed verification. This is not a genuine webhook from Trinsic.\n}\n</code></pre> <p>Use a library</p> <p>It is highly recommended that you use a library to compute and verify HMACs.</p> <p>Many languages have native support for HMAC-SHA256; for those that don't, high-quality open source libraries exist.</p>"},{"location":"learn/platform/webhooks/#enabling-wallet-events","title":"Enabling Wallet Events","text":"<p>Events which occur on a wallet will not be sent to your webhooks unless the wallet holder has opted in.</p> <p>To receive webhooks for wallet events, the AuthorizeWebhook method must be called for each wallet which is opting-in to propagate wallet events to the ecosystem provider.</p> <p>This call must be performed using the wallet's authentication token.</p>"},{"location":"learn/platform/webhooks/#event-types","title":"Event Types","text":"<p>For a list of all event types and their structures, see the Events Reference page.</p>"},{"location":"node/","title":"The Trinsic Javascript / Node SDK","text":"<p>The Trinsic Node SDK makes it easy to interact with the Trinsic API from any backend javascript application. The most recent version of the library can be found on npm. You can find the SDKs source on Github.</p>"},{"location":"node/#installation","title":"Installation","text":"<p>Install the package for Node from npmjs.com </p> Install <pre><code>npm i @trinsic/trinsic\n</code></pre>"},{"location":"node/#next-steps","title":"Next Steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference.</p> <p>Start Walkthrough Explore API</p>"},{"location":"python/","title":"The Trinsic Python SDK","text":"<p>The Trinsic Python SDK makes it easy to interact with the Trinsic API from any Python application. The most recent version of the library can be found on PyPi. You can find the SDKs source on Github.</p>"},{"location":"python/#installation-and-configuration","title":"Installation and Configuration","text":"<ul> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>LD_LIBRARY_PATH</code>, even on Windows.</li> <li>Recommended: Create a virtual environment</li> <li>Install the trinsic package <pre><code>pip install trinsic-sdk\n</code></pre></li> <li> <p>Test installation by running the following shell command: <pre><code># May be \"python\" or \"python3\" depending on your install\npython -m trinsic\n</code></pre></p> </li> <li> <p>The output should look something like this: <pre><code>Package successfully installed. Sample profile below\n</code></pre></p> </li> </ul>"},{"location":"python/#next-steps","title":"Next Steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Python API Reference</p>"},{"location":"reference/","title":"Overview","text":"<p>This section serves as the reference for the Trinsic API, which can be accessed using any of our SDKs.</p>"},{"location":"reference/#authentication","title":"Authentication","text":""},{"location":"reference/#auth-tokens","title":"Auth Tokens","text":"<p>Authentication with the Trinsic platform uses auth tokens, which are strings that operate similarly to API keys.</p> <p>Unlike API keys, however, Trinsic utilizes zero-knowledge proofs to sign SDK calls using an auth token, without ever transmitting the auth token itself down the wire. This provides increased security compared to API keys, while being more convenient than other auth schemes, such as public/private tokens.</p>"},{"location":"reference/#custom-protection-of-auth-tokens","title":"Custom Protection of Auth Tokens","text":"<p>We provide helper methods to protect auth tokens -- enabling you to perform custom security operations. An auth token, once protected with a code, is unusable until unprotected with that same code. Protection and unprotection are performed entirely on-device.</p>"},{"location":"reference/#using-auth-tokens-in-the-sdk","title":"Using Auth Tokens in the SDK","text":"<p>Whenever you perform an SDK call which returns an auth token (signing in to an account, or creating an ecosystem), our SDKs will automatically store the auth token in memory and use it for subsequent calls.</p> <p>You can also manually set the auth token used by the SDK (such as when loading an auth token from storage):</p> Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic config --auth-token {AUTH_TOKEN}\n</code></pre> <pre><code>trinsic.options.authToken = authToken;\n</code></pre> <pre><code>trinsic.SetAuthToken(authToken);\n</code></pre> <pre><code>trinsic.service_options.auth_token = auth_token\n</code></pre> <pre><code>trinsic.SetAuthToken(authToken)\n</code></pre> <pre><code>trinsic.setAuthToken(authToken);\n</code></pre>"},{"location":"reference/#services","title":"Services","text":"<p>Our SDK is broken down into the following logical services, each of which is accessible through a single <code>TrinsicService</code> instance:</p> <ul> <li>Account Service</li> <li>Credential Service</li> <li>Provider Service</li> <li>Template Service</li> <li>Trust Registry Service</li> <li>Wallet Service</li> </ul>"},{"location":"reference/#using-an-sdk-service","title":"Using an SDK Service","text":"<p>If you are using one of the Trinsic SDKs, you will need to create an instance of a <code>TrinsicService</code> in order to use it.</p> TypeScriptC#PythonGoJava <pre><code>const trinsic = new TrinsicService();\n</code></pre> <pre><code>var trinsic = new TrinsicService(_options);\n</code></pre> <pre><code>trinsic_service = TrinsicService(server_config=trinsic_config())\n</code></pre> <pre><code>trinsic, err := NewTrinsic(WithTestEnv())\nif !assert2.Nil(err) {\nreturn\n}\n</code></pre> <pre><code>var trinsic = new TrinsicService(TrinsicUtilities.getTrinsicServiceOptions());\n</code></pre> <p>The constructor accepts a ServiceOptions object as an argument, allowing you to specify a default ecosystem and other configuration properties:</p> ServiceOptionsConfiguration for Trinsic SDK Servicesserver_endpoint stringTrinsic API endpoint. Defaults to `prod.trinsic.cloud`server_port int32Trinsic API port; defaults to `443`server_use_tls boolWhether TLS is enabled between SDK and Trinsic API; defaults to `true`auth_token stringAuthentication token for SDK calls; defaults to empty string (unauthenticated)  Default ecosystem ID to use for various SDK calls; defaults to `default` string default_ecosystem = 5; <p>The exact structure of this object will depend on the language you are working with. You can always rely on your editor's intellisense when in doubt. </p>"},{"location":"reference/events/","title":"Events Reference","text":""},{"location":"reference/events/#overview","title":"Overview","text":"<p>This page documents each event type raised by Trinsic's platform.</p> <p>To consume events, set up a webhook.</p>"},{"location":"reference/events/#events","title":"Events","text":""},{"location":"reference/events/#ping","title":"ping","text":"PingV1Event name: <code>ping</code>Webhook test eventid stringUUID of this pingwebhook_id stringUUID of the webhook receiving the pingtimestamp stringTimestamp ping was requested, in ISO 8601 format (ex. `2022-07-07T08:09:10.11Z`)message stringArbitrary message specified when ping was requestedecosystem_id stringEcosystem where this event originated, if any."},{"location":"reference/events/#governance_framework_created","title":"governance_framework_created","text":"GovernanceFrameworkCreatedV1Event name: <code>governance_framework_created</code>Entity Governance Framework created and attached to ecosystemid stringUUID of the governance frameworkecosystem_id stringUUID of the ecosystem that owns this EGFtrust_registry stringTrust registry associated with this EGFgoverning_authority stringWallet ID of the authority for this EGFtype stringType of EGFname stringUser-friendly name for the EGFdescription stringDescription of the EGFgovernance_framework stringURI for the EGFtimestamp stringTimestamp event occurred, in ISO 8601 format (ex. `2022-07-07T08:09:10.11Z`)"},{"location":"reference/events/#template_created","title":"template_created","text":"TemplateCreatedV1Event name: <code>template_created</code>Template created in ecosystemid stringUUID of the templateecosystem_id stringUUID of the ecosystem that owns this templatename stringTemplate nametype stringTemplate typecreated_by stringWalletID that created the templatetimestamp stringTimestamp event occurred, in ISO 8601 format (ex. `2022-07-07T08:09:10.11Z`)"},{"location":"reference/events/#item_received","title":"item_received","text":"ItemReceivedV1Event name: <code>item_received</code>Item inserted into walletid stringUUID of the new itemreceived stringTimestamp when the item was received, in ISO 8601 format (ex. `2022-07-07T08:09:10.11Z`)wallet_id stringID of walletecosystem_id stringEcosystem where this event originated, if any."},{"location":"reference/other/openid/","title":"OpenID Credential Exchange Service","text":""},{"location":"reference/other/openid/#overview","title":"Overview","text":"<p>Trinsic provides an OpenID Connect  (\"OIDC\") service which enables verifiers to request credentials from a user's cloud wallet in a simple and secure way.</p> <p>This service does not require the use of Trinsic's SDKs in the user's browser, and is therefore lightweight and easy to integrate.</p> <p>Credential Issuance</p> <p>Currently, Trinsic's OpenID Connect service only enables the sharing of a credential between holder and verifier. We plan to support issuance through this service at a later date.</p> <p>In the meantime, use the InsertItem SDK call to store credentials in a holder's wallet.</p>"},{"location":"reference/other/openid/#integration","title":"Integration","text":""},{"location":"reference/other/openid/#openid-connect-protocol","title":"OpenID Connect Protocol","text":"<p>Because this is an OpenID Connect service, any compliant library may be used -- as long as it enables you to specify additional custom query parameters on the initial outbound URL.</p> <p>OIDC Flow Implementation</p> <p>The specifics of the OpenID Connect protocol -- and how to implement it -- are out of scope for this documentation.</p> <p>If you would like to see an example implementation of a verification flow against this service, see the sample below.</p>"},{"location":"reference/other/openid/#configuration","title":"Configuration","text":"<p>Configure your OIDC library with the following parameters:</p> Parameter Description General Parameters <code>authority</code> <code>https://connect.trinsic.cloud</code> <code>response_type</code> <code>code</code> <code>scope</code> <code>openid</code> <code>client_id</code> Any string which uniquely represents your client application <code>redirect_uri</code> The URI your user should be redirected to once they have completed (or canceled) the flow <code>nonce</code> (Optional) Random nonce value that will be used to bind the generated presentation to the issued token. If not specified, one will be randomly generated. Use this to prevent presentation replays. Trinsic-Specific Parameters <code>trinsic:ecosystem</code> ID of ecosystem user wallet resides in <code>trinsic:schema</code> (Optional) Comma-separated listed of Schema URLs. Only credentials which match one of these schemas will be returned. <code>trinsic:issuer</code> (Optional) Comma-separated list of Issuer DIDs. Only credentials issued by one of these issuers will be returned. <code>trinsic:egf</code> (Optional) Comma-separated list of Entity Governance Framework IDs. Only credentials bound to one of these EGF IDs will be returned. <code>trinsic:mode</code> (Optional) Can be <code>redirect</code> (default), <code>popup</code>, or <code>silent</code>."},{"location":"reference/other/openid/#presentation-replays-and-id-tokens","title":"Presentation Replays and ID Tokens","text":"<p>In order to prevent verifiable presentation replays, always specify the <code>nonce</code> parameter in the initial call to the authorization endpoint. This will ensure that the generated presentation and the ID token match the current request.</p>"},{"location":"reference/other/openid/#response-data","title":"Response Data","text":"<p>Once the user has returned to your redirect URL, exchange the authorization code (added to your redirect URI as a query parameter named <code>code</code>) for an identity token using your OIDC library.</p> <p>You will receive a JSON object of the following form:</p> Response JSON<pre><code>{\n\"id_token\": \"{JWT containing same data as vp_token}\",\n\"access_token\":\"invalid\",\n\"token_type\":\"Bearer\",\n\"vp_token\":{\n\"@context\":[\n\"https://www.w3.org/2018/credentials/v1\",\n\"https://w3id.org/bbs/v1\",\n...\n],\n\"id\":\"{UUID of Holder Wallet}\",\n\"type\":[\n...,\n\"VerifiableCredential\"\n],\n\"credentialSchema\":{\n...\n},\n\"credentialStatus\":{\n...\n},\n\"credentialSubject\":{\n...\n},\n\"issuanceDate\":\"{Issue date of credential}\",\n\"issuer\":\"{DID of Issuer}\",\n\"proof\":{\n...\n}\n}\n}\n</code></pre> <p>Credential Format</p> <p>Note that the above data has been modified for brevity.</p> <p>The <code>@context</code> and <code>type</code> arrays will contain additional entries which are specific to the credential.</p>"},{"location":"reference/other/openid/#verify-the-received-proof","title":"Verify the Received Proof","text":"<p><code>vp_token</code> is a Verifiable Proof; before making use of its data, you must verify it.</p> <p>This proof can be verified with any library that supports VC verifications for BBS+ signatures. It can also be verified using Trinsic's SDK; this is as simple as passing the proof to the VerifyProof call.</p> <p>If you specified a <code>nonce</code> in the authorization request, always verify that the <code>nonce</code> claim in the JWT ID token matches the similarly named value in the <code>_vp_token</code> document. You may find the nonce in the <code>_vp_token.proof.nonce</code> path in the JSON structure. Note that the value in this proof may be specified in base64 format, so you may need to reformat your nonce before comparing. If you specified the nonce as base64 in the request, the two values should match with direct string comparison.</p> <p>Always Verify</p> <p>It may be tempting to simply take the data in <code>vp_token</code> and act upon it without first verifying the proof.</p> <p>Always verify the proof before making use of its data.</p> <p>Without verification, the received proof is of no more value than an unsubstantiated claim made by your user.</p>"},{"location":"reference/other/openid/#sample","title":"Sample","text":"<p>We've prepared a sample demonstrating client-side OIDC Verification.</p> <ul> <li> <p> Sample Source</p> <p>The source for this sample is available on GitHub</p> </li> </ul>"},{"location":"reference/other/openid/#oidc-libraries","title":"OIDC Libraries","text":"<p>Libraries exist enabling OIDC functionality for all major languages.</p> <p>The OpenID Connect website lists a number of certified libraries; we've included links to some of these below.</p> <ul> <li> TypeScript/JavaScript</li> <li> Python</li> <li> C#</li> <li> Go</li> <li> Java</li> <li> Ruby</li> </ul>"},{"location":"reference/proto/","title":"Protocol Documentation","text":"<p>This page documents the Protobuf Services and Messages which compose the Trinsic API.</p> <p></p> <p>Top</p>"},{"location":"reference/proto/#servicesverifiable-credentialstemplatesv1templatesproto","title":"services/verifiable-credentials/templates/v1/templates.proto","text":""},{"location":"reference/proto/#service-credentialtemplates","title":"Service - CredentialTemplates","text":"Method Name Request Type Response Type Description Create CreateCredentialTemplateRequest CreateCredentialTemplateResponse Create a credential template in the current ecosystem Get GetCredentialTemplateRequest GetCredentialTemplateResponse Fetch a credential template by ID List ListCredentialTemplatesRequest ListCredentialTemplatesResponse Search credential templates using SQL, returning strongly-typed template data Search SearchCredentialTemplatesRequest SearchCredentialTemplatesResponse Search credential templates using SQL, returning raw JSON data Delete DeleteCredentialTemplateRequest DeleteCredentialTemplateResponse Delete a credential template from the current ecosystem by ID"},{"location":"reference/proto/#createcredentialtemplaterequest","title":"CreateCredentialTemplateRequest","text":"<p>Request to create a new template</p> Field Type Description name string Name of new template fields CreateCredentialTemplateRequest.FieldsEntry[] Fields which compose the template allow_additional_fields bool Whether credentials may be issued against this template which have fields not specified in <code>fields</code> <p></p>"},{"location":"reference/proto/#createcredentialtemplaterequestfieldsentry","title":"CreateCredentialTemplateRequest.FieldsEntry","text":"Field Type Description key string value TemplateField"},{"location":"reference/proto/#createcredentialtemplateresponse","title":"CreateCredentialTemplateResponse","text":"<p>Response to <code>CreateCredentialTemplateRequest</code></p> Field Type Description data TemplateData Created template <p></p>"},{"location":"reference/proto/#deletecredentialtemplaterequest","title":"DeleteCredentialTemplateRequest","text":"<p>Request to delete a template by ID</p> Field Type Description id string ID of template to delete <p></p>"},{"location":"reference/proto/#deletecredentialtemplateresponse","title":"DeleteCredentialTemplateResponse","text":"<p>Response to <code>DeleteCredentialTemplateRequest</code></p> <p></p>"},{"location":"reference/proto/#getcredentialtemplaterequest","title":"GetCredentialTemplateRequest","text":"<p>Request to fetch a template by ID</p> Field Type Description id string ID of template to fetch <p></p>"},{"location":"reference/proto/#getcredentialtemplateresponse","title":"GetCredentialTemplateResponse","text":"<p>Response to <code>GetCredentialTemplateRequest</code></p> Field Type Description template TemplateData Template fetched by ID <p></p>"},{"location":"reference/proto/#gettemplaterequest","title":"GetTemplateRequest","text":"<p>Unused</p> Field Type Description id string <p></p>"},{"location":"reference/proto/#gettemplateresponse","title":"GetTemplateResponse","text":"<p>Unused</p> Field Type Description data TemplateData <p></p>"},{"location":"reference/proto/#listcredentialtemplatesrequest","title":"ListCredentialTemplatesRequest","text":"<p>Request to list templates using a SQL query</p> Field Type Description query string SQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code> continuation_token string Token provided by previous <code>ListCredentialTemplatesResponse</code> if more data is available for query <p></p>"},{"location":"reference/proto/#listcredentialtemplatesresponse","title":"ListCredentialTemplatesResponse","text":"<p>Response to <code>ListCredentialTemplatesRequest</code></p> Field Type Description templates TemplateData[] Templates found by query has_more_results bool Whether more results are available for this query via <code>continuation_token</code> continuation_token string Token to fetch next set of resuts via <code>ListCredentialTemplatesRequest</code> <p></p>"},{"location":"reference/proto/#listtemplatesrequest","title":"ListTemplatesRequest","text":"<p>Unused</p> <p></p>"},{"location":"reference/proto/#listtemplatesresponse","title":"ListTemplatesResponse","text":"<p>Unused</p> Field Type Description templates TemplateData[] <p></p>"},{"location":"reference/proto/#searchcredentialtemplatesrequest","title":"SearchCredentialTemplatesRequest","text":"<p>Request to search templates using a SQL query</p> Field Type Description query string SQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code> continuation_token string Token provided by previous <code>SearchCredentialTemplatesResponse</code> if more data is available for query <p></p>"},{"location":"reference/proto/#searchcredentialtemplatesresponse","title":"SearchCredentialTemplatesResponse","text":"<p>Response to <code>SearchCredentialTemplatesRequest</code></p> Field Type Description items_json string Raw JSON data returned from query has_more bool Whether more results are available for this query via <code>continuation_token</code> continuation_token string Token to fetch next set of results via <code>SearchCredentialTemplatesRequest</code> <p></p>"},{"location":"reference/proto/#templatedata","title":"TemplateData","text":"<p>Credential Template</p> Field Type Description id string Template ID name string Template name version int32 Template version number fields TemplateData.FieldsEntry[] Fields defined for the template allow_additional_fields bool Whether credentials issued against this template may contain fields not defined by template schema_uri string URI pointing to template JSON schema document context_uri string Deprecated. URI pointing to template JSON-LD context document ecosystem_id string ID of ecosystem in which template resides type string Template type (<code>VerifiableCredential</code>) created_by string ID of template creator date_created string Date when template was created as ISO 8601 utc string <p></p>"},{"location":"reference/proto/#templatedatafieldsentry","title":"TemplateData.FieldsEntry","text":"Field Type Description key string value TemplateField"},{"location":"reference/proto/#templatefield","title":"TemplateField","text":"<p>A field defined in a template</p> Field Type Description description string Human-readable description of the field optional bool Whether this field may be omitted when a credential is issued against the template type FieldType The type of the field annotations TemplateField.AnnotationsEntry[] Annotations for the field that may be used to add additional information <p></p>"},{"location":"reference/proto/#templatefieldannotationsentry","title":"TemplateField.AnnotationsEntry","text":"Field Type Description key string value string"},{"location":"reference/proto/#fieldtype","title":"FieldType","text":"<p>Valid types for credential fields</p> Name Number Description STRING 0 NUMBER 1 BOOL 2 DATETIME 4 URI 5 <p></p> <p>Top</p>"},{"location":"reference/proto/#servicesverifiable-credentialsv1verifiable-credentialsproto","title":"services/verifiable-credentials/v1/verifiable-credentials.proto","text":""},{"location":"reference/proto/#service-verifiablecredential","title":"Service - VerifiableCredential","text":"Method Name Request Type Response Type Description Issue IssueRequest IssueResponse Sign and issue a verifiable credential from a submitted document. The document must be a valid JSON-LD document. IssueFromTemplate IssueFromTemplateRequest IssueFromTemplateResponse Sign and issue a verifiable credential from a pre-defined template. This process will also add schema validation and revocation registry values to the credential. CheckStatus CheckStatusRequest CheckStatusResponse Check credential status in the revocation registry UpdateStatus UpdateStatusRequest UpdateStatusResponse Update credential status by setting the revocation value CreateProof CreateProofRequest CreateProofResponse Create a proof from a signed document that is a valid verifiable credential and contains a signature from which a proof can be derived. VerifyProof VerifyProofRequest VerifyProofResponse Verifies a proof by checking the signature value, and if possible schema validation, revocation status, and issuer status against a trust registry Send SendRequest SendResponse Sends a document directly to a user's email within the given ecosystem"},{"location":"reference/proto/#checkstatusrequest","title":"CheckStatusRequest","text":"<p>Request to check a credential's revocation status</p> Field Type Description credential_status_id string Credential Status ID to check. This is not the same as the credential's ID. <p></p>"},{"location":"reference/proto/#checkstatusresponse","title":"CheckStatusResponse","text":"<p>Response to <code>CheckStatusRequest</code></p> Field Type Description revoked bool The credential's revocation status <p></p>"},{"location":"reference/proto/#createproofrequest","title":"CreateProofRequest","text":"<p>Request to create a proof for a Verifiable Credential using public key tied to caller. Either <code>item_id</code> or <code>document_json</code> may be provided, not both.</p> Field Type Description reveal_document_json string A valid JSON-LD frame describing which fields should be revealed in the generated proof. If unspecified, all fields in the document will be revealed reveal_template RevealTemplateAttributes Information about what sections of the document to reveal item_id string ID of wallet item stored in a Trinsic cloud wallet document_json string A valid JSON-LD Verifiable Credential document string with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet. nonce bytes Nonce value used to derive the proof. If not specified, a random nonce will be generated. This value may be represented in base64 format in the proof model. <p></p>"},{"location":"reference/proto/#createproofresponse","title":"CreateProofResponse","text":"<p>Response to <code>CreateProofRequest</code></p> Field Type Description proof_document_json string Valid JSON-LD proof for the specified credential <p></p>"},{"location":"reference/proto/#issuefromtemplaterequest","title":"IssueFromTemplateRequest","text":"<p>Request to create and sign a JSON-LD Verifiable Credential from a template using public key tied to caller</p> Field Type Description template_id string ID of template to use values_json string JSON document string with keys corresponding to the fields of the template referenced by <code>template_id</code> framework_id string Governance framework ID to use with issuance of this credential. If specified, the issued credential will contain extended issuer metadata with membership info for the given ecosystem governance framework (EGF) save_copy bool Save a copy of the issued credential to this user's wallet. This copy will only contain the credential data, but not the secret proof value. Issuers may use this data to keep track of the details for revocation status. <p></p>"},{"location":"reference/proto/#issuefromtemplateresponse","title":"IssueFromTemplateResponse","text":"<p>Response to <code>IssueFromTemplateRequest</code></p> Field Type Description document_json string Verifiable Credential document, in JSON-LD form, constructed from the specified template and values; signed with public key tied to caller of <code>IssueFromTemplateRequest</code> <p></p>"},{"location":"reference/proto/#issuerequest","title":"IssueRequest","text":"<p>Request to sign a JSON-LD Credential using public key tied to caller</p> Field Type Description document_json string Valid JSON-LD Credential document to be signed, in string form <p></p>"},{"location":"reference/proto/#issueresponse","title":"IssueResponse","text":"<p>Response to <code>IssueRequest</code></p> Field Type Description signed_document_json string Verifiable Credential document, signed with public key tied to caller of <code>IssueRequest</code> <p></p>"},{"location":"reference/proto/#revealtemplateattributes","title":"RevealTemplateAttributes","text":"Field Type Description template_attributes string[] A list of document attributes to reveal. If unset, all attributes will be returned."},{"location":"reference/proto/#sendrequest","title":"SendRequest","text":"<p>Request to send a document to another user's wallet</p> Field Type Description email string Email address of user to send item to wallet_id string DID of recipient (presently unsupported) string did_uri = 2 [deprecated=true]; DIDComm out-of-band invitation JSON (presently unsupported) string didcomm_invitation_json = 3 [deprecated=true]; Wallet ID of the recipient within the ecosystem send_notification bool Send email notification that credential has been sent to a wallet document_json string JSON document to send to recipient <p></p>"},{"location":"reference/proto/#sendresponse","title":"SendResponse","text":"<p>Response to <code>SendRequest</code></p> <p></p>"},{"location":"reference/proto/#updatestatusrequest","title":"UpdateStatusRequest","text":"<p>Request to update a credential's revocation status</p> Field Type Description credential_status_id string Credential Status ID to update. This is not the same as the credential's ID. revoked bool New revocation status of credential <p></p>"},{"location":"reference/proto/#updatestatusresponse","title":"UpdateStatusResponse","text":"<p>Response to <code>UpdateStatusRequest</code></p> <p></p>"},{"location":"reference/proto/#validationmessage","title":"ValidationMessage","text":"<p>Result of a validation check on a proof</p> Field Type Description is_valid bool Whether this validation check passed messages string[] If validation failed, contains messages explaining why <p></p>"},{"location":"reference/proto/#verifyproofrequest","title":"VerifyProofRequest","text":"<p>Request to verify a proof</p> Field Type Description proof_document_json string JSON-LD proof document string to verify <p></p>"},{"location":"reference/proto/#verifyproofresponse","title":"VerifyProofResponse","text":"<p>Response to <code>VerifyProofRequest</code></p> Field Type Description is_valid bool Whether all validations in <code>validation_results</code> passed validation_messages string[] Deprecated. Use <code>validation_results</code> instead validation_results VerifyProofResponse.ValidationResultsEntry[] Results of each validation check performed, such as schema conformance, revocation status, signature, etc. Detailed results are provided for failed validations. <p></p>"},{"location":"reference/proto/#verifyproofresponsevalidationresultsentry","title":"VerifyProofResponse.ValidationResultsEntry","text":"Field Type Description key string value ValidationMessage <p>Top</p>"},{"location":"reference/proto/#servicesproviderv1access-managementproto","title":"services/provider/v1/access-management.proto","text":""},{"location":"reference/proto/#service-accessmanagement","title":"Service - AccessManagement","text":"<p>Access Management service provides methods to manage access to ecosystem resources such by assigning roles and permissions to wallet accounts</p> Method Name Request Type Response Type Description AddRoleAssignment AddRoleAssignmentRequest AddRoleAssignmentResponse Adds a role assignment to an account RemoveRoleAssignment RemoveRoleAssignmentRequest RemoveRoleAssignmentResponse Removes a role assignment from the account ListRoleAssignments ListRoleAssignmentsRequest ListRoleAssignmentsResponse List the role assignments for the given account ListAvailableRoles ListAvailableRolesRequest ListAvailableRolesResponse List the roles available in the ecosystem <p></p>"},{"location":"reference/proto/#addroleassignmentrequest","title":"AddRoleAssignmentRequest","text":"<p>Role management</p> Field Type Description role string Role to assign email string Email address of account to assign role to. Mutually exclusive with <code>walletId</code>. wallet_id string Wallet ID of account to assign role to. Mutually exclusive with <code>email</code>. <p></p>"},{"location":"reference/proto/#addroleassignmentresponse","title":"AddRoleAssignmentResponse","text":""},{"location":"reference/proto/#listavailablerolesrequest","title":"ListAvailableRolesRequest","text":"<p>Request to fetch the available roles in the current ecosystem</p> <p></p>"},{"location":"reference/proto/#listavailablerolesresponse","title":"ListAvailableRolesResponse","text":"Field Type Description roles string[] List of roles"},{"location":"reference/proto/#listroleassignmentsrequest","title":"ListRoleAssignmentsRequest","text":"<p>Request to fetch the list of roles assigned to the current account</p> Field Type Description email string Email address of account to unassign role from. Mutually exclusive with <code>walletId</code>. wallet_id string Wallet ID of account to unassign role from. Mutually exclusive with <code>email</code>. <p></p>"},{"location":"reference/proto/#listroleassignmentsresponse","title":"ListRoleAssignmentsResponse","text":"Field Type Description roles string[] List of roles"},{"location":"reference/proto/#removeroleassignmentrequest","title":"RemoveRoleAssignmentRequest","text":"Field Type Description role string Role to unassign email string Email address of account to unassign role from. Mutually exclusive with <code>walletId</code>. wallet_id string Wallet ID of account to unassign role from. Mutually exclusive with <code>email</code>."},{"location":"reference/proto/#removeroleassignmentresponse","title":"RemoveRoleAssignmentResponse","text":"<p>Top</p>"},{"location":"reference/proto/#servicesproviderv1providerproto","title":"services/provider/v1/provider.proto","text":""},{"location":"reference/proto/#service-provider","title":"Service - Provider","text":"Method Name Request Type Response Type Description CreateEcosystem CreateEcosystemRequest CreateEcosystemResponse Create new ecosystem and assign the authenticated user as owner UpdateEcosystem UpdateEcosystemRequest UpdateEcosystemResponse Update an existing ecosystem GrantAuthorization GrantAuthorizationRequest GrantAuthorizationResponse Grant user authorization to ecosystem resources RevokeAuthorization RevokeAuthorizationRequest RevokeAuthorizationResponse Revoke user authorization to ecosystem resources GetAuthorizations GetAuthorizationsRequest GetAuthorizationsResponse Retrieve the list of permissions for this particular account/ecosystem AddWebhook AddWebhookRequest AddWebhookResponse Add a webhook endpoint to the ecosystem DeleteWebhook DeleteWebhookRequest DeleteWebhookResponse Delete a webhook endpoint from the ecosystem EcosystemInfo EcosystemInfoRequest EcosystemInfoResponse Get ecosystem information GetPublicEcosystemInfo GetPublicEcosystemInfoRequest GetPublicEcosystemInfoResponse Get public ecosystem information about any ecosystem GenerateToken GenerateTokenRequest GenerateTokenResponse Generates an unprotected authentication token that can be used to configure server side applications Invite InviteRequest InviteResponse Invite a user to the ecosystem InvitationStatus InvitationStatusRequest InvitationStatusResponse Check the status of an invitation GetOberonKey GetOberonKeyRequest GetOberonKeyResponse Returns the public key being used to create/verify oberon tokens GetEventToken GetEventTokenRequest GetEventTokenResponse Generate a signed token (JWT) that can be used to connect to the message bus UpgradeDID UpgradeDidRequest UpgradeDidResponse Upgrade a wallet's DID from <code>did:key</code> to another method RetrieveDomainVerificationRecord RetrieveDomainVerificationRecordRequest RetrieveDomainVerificationRecordResponse Retrieve a random hash TXT that can be used to verify domain ownership RefreshDomainVerificationStatus RefreshDomainVerificationStatusRequest RefreshDomainVerificationStatusResponse Call to verify domain SearchWalletConfigurations SearchWalletConfigurationsRequest SearchWalletConfigurationResponse Search for issuers/providers/verifiers in the current ecosystem"},{"location":"reference/proto/#addwebhookrequest","title":"AddWebhookRequest","text":"<p>Request to add a webhook to an ecosystem</p> Field Type Description destination_url string Destination to post webhook calls to. Must be a reachable HTTPS URL. secret string Secret string used for HMAC-SHA256 signing of webhook payloads to verify that a webhook comes from Trinsic events string[] Events to subscribe to. Default is \"*\" (all events) <p></p>"},{"location":"reference/proto/#addwebhookresponse","title":"AddWebhookResponse","text":"<p>Response to <code>AddWebhookRequest</code></p> Field Type Description ecosystem Ecosystem Ecosystem data with new webhook <p></p>"},{"location":"reference/proto/#createecosystemrequest","title":"CreateEcosystemRequest","text":"<p>Request to create an ecosystem</p> Field Type Description name string Globally unique name for the Ecosystem. This name will be part of the ecosystem-specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen. If not passed, ecosystem name will be auto-generated. description string Ecosystem description uri string Deprecated. External URL associated with your organization or ecosystem entity details services.account.v1.AccountDetails The account details of the owner of the ecosystem domain string New domain URL <p></p>"},{"location":"reference/proto/#createecosystemresponse","title":"CreateEcosystemResponse","text":"<p>Response to <code>CreateEcosystemRequest</code></p> Field Type Description ecosystem Ecosystem Details of the created ecosystem profile services.account.v1.AccountProfile Account profile for auth of the owner of the ecosystem confirmation_method services.account.v1.ConfirmationMethod Indicates if confirmation of account is required. <p></p>"},{"location":"reference/proto/#deletewebhookrequest","title":"DeleteWebhookRequest","text":"<p>Request to delete a webhook from an ecosystem</p> Field Type Description webhook_id string ID of webhook to delete <p></p>"},{"location":"reference/proto/#deletewebhookresponse","title":"DeleteWebhookResponse","text":"<p>Response to <code>DeleteWebhookRequest</code></p> Field Type Description ecosystem Ecosystem Ecosystem data after removal of webhook <p></p>"},{"location":"reference/proto/#ecosystem","title":"Ecosystem","text":"<p>Details of an ecosystem</p> Field Type Description id string URN of the ecosystem name string Globally unique name for the ecosystem description string Ecosystem description uri string Deprecated. External URL associated with the organization or ecosystem entity webhooks WebhookConfig[] Configured webhooks, if any display EcosystemDisplay Display details domain string Domain <p></p>"},{"location":"reference/proto/#ecosystemdisplay","title":"EcosystemDisplay","text":"Field Type Description light EcosystemDisplayDetails Removed the Dark after discussion with team, as we don't provide a dark UI anywhere (yet) in our platform. EcosystemDisplayDetails dark = 1;"},{"location":"reference/proto/#ecosystemdisplaydetails","title":"EcosystemDisplayDetails","text":"Field Type Description logo_url string string id = 1; string name = 2; color string"},{"location":"reference/proto/#ecosystemdisplaydetailsrequest","title":"EcosystemDisplayDetailsRequest","text":"Field Type Description color string string id = 1; string name = 2; string logo_url = 3; logo_data bytes logo_format string MIME type of the file"},{"location":"reference/proto/#ecosystemdisplayrequest","title":"EcosystemDisplayRequest","text":"Field Type Description light EcosystemDisplayDetailsRequest Removed the Dark after discussion with team, as we don't provide a dark UI anywhere (yet) in our platform. EcosystemDisplayDetailsRequest dark = 1;"},{"location":"reference/proto/#ecosysteminforequest","title":"EcosystemInfoRequest","text":"<p>Request to fetch information about an ecosystem</p> <p></p>"},{"location":"reference/proto/#ecosysteminforesponse","title":"EcosystemInfoResponse","text":"<p>Response to <code>InfoRequest</code></p> Field Type Description ecosystem Ecosystem Ecosystem corresponding to current ecosystem in the account token <p></p>"},{"location":"reference/proto/#generatetokenrequest","title":"GenerateTokenRequest","text":"<p>Request to generate an authentication token for the current account</p> Field Type Description description string Description to identify this token <p></p>"},{"location":"reference/proto/#generatetokenresponse","title":"GenerateTokenResponse","text":"<p>Response to <code>GenerateTokenRequest</code></p> Field Type Description profile services.account.v1.AccountProfile Account authentication profile that contains unprotected token <p></p>"},{"location":"reference/proto/#getauthorizationsrequest","title":"GetAuthorizationsRequest","text":"<p>Fetch list of grants that the current account has access to in its ecosystem</p> <p></p>"},{"location":"reference/proto/#getauthorizationsresponse","title":"GetAuthorizationsResponse","text":"<p>Response to <code>GetAuthorizationsRequest</code></p> Field Type Description grants Grant[] Grants attached to account <p></p>"},{"location":"reference/proto/#geteventtokenrequest","title":"GetEventTokenRequest","text":"<p>Generates an events token bound to the provided ed25519 public key.</p> Field Type Description pk bytes Raw public key to generate event token for <p></p>"},{"location":"reference/proto/#geteventtokenresponse","title":"GetEventTokenResponse","text":"<p>Response message containing a token (JWT) that can be used to connect directly to the message streaming architecture</p> Field Type Description token string JWT bound to the public key provided in <code>GetEventTokenRequest</code> <p></p>"},{"location":"reference/proto/#getoberonkeyrequest","title":"GetOberonKeyRequest","text":"<p>Request to fetch the Trinsic public key used to verify authentication token validity</p> <p></p>"},{"location":"reference/proto/#getoberonkeyresponse","title":"GetOberonKeyResponse","text":"<p>Response to <code>GetOberonKeyRequest</code></p> Field Type Description key string Oberon Public Key as RAW base64-url encoded string <p></p>"},{"location":"reference/proto/#getpublicecosysteminforequest","title":"GetPublicEcosystemInfoRequest","text":"<p>Request to fetch information about an ecosystem</p> Field Type Description ecosystem_id string <p></p>"},{"location":"reference/proto/#getpublicecosysteminforesponse","title":"GetPublicEcosystemInfoResponse","text":"<p>Response to <code>InfoRequest</code></p> Field Type Description ecosystem PublicEcosystemInformation Ecosystem corresponding to requested <code>ecosystem_id</code> <p></p>"},{"location":"reference/proto/#grant","title":"Grant","text":"<p>A grant authorizing <code>actions</code> on a <code>resourceId</code></p> Field Type Description resourceId string the urn of the resource actions string[] list of actions that are allowed child_grants Grant[] any child grants <p></p>"},{"location":"reference/proto/#grantauthorizationrequest","title":"GrantAuthorizationRequest","text":"<p>Grant permissions to a resource or path in the ecosystem</p> Field Type Description email string Email address of account being granted permission. Mutually exclusive with <code>walletId</code>. walletId string Wallet ID of account being granted permission. Mutually exclusive with <code>email</code>. resource string Resource string that account is receiving permissions for. Resources are specified as a RESTful path: /{ecoId}/{resource type}/{resource id}. <code>ecoId</code> may be omitted. action string Action to authorize. Default is \"*\" (all) <p></p>"},{"location":"reference/proto/#grantauthorizationresponse","title":"GrantAuthorizationResponse","text":"<p>Response to <code>GrantAuthorizationRequest</code></p> <p></p>"},{"location":"reference/proto/#indyoptions","title":"IndyOptions","text":"<p>Options for creation of DID on the SOV network</p> Field Type Description network IndyOptions.IndyNetwork SOV network on which DID should be published <p></p>"},{"location":"reference/proto/#invitationstatusrequest","title":"InvitationStatusRequest","text":"<p>Request details for the status of an invitation</p> Field Type Description invitation_id string ID of invitation, received from <code>InviteResponse</code> <p></p>"},{"location":"reference/proto/#invitationstatusresponse","title":"InvitationStatusResponse","text":"<p>Response to <code>InvitationStatusRequest</code></p> Field Type Description status InvitationStatusResponse.Status Status of invitation status_details string Human-readable string with details about invitation status <p></p>"},{"location":"reference/proto/#inviterequest","title":"InviteRequest","text":"<p>Request to invite a participant to an ecosystem</p> Field Type Description participant ParticipantType Type of participant being invited (individual/organization) description string Description of invitation details services.account.v1.AccountDetails Account details of invitee <p></p>"},{"location":"reference/proto/#inviterequestdidcomminvitation","title":"InviteRequest.DidCommInvitation","text":""},{"location":"reference/proto/#inviteresponse","title":"InviteResponse","text":"<p>Response to <code>InviteRequest</code></p> Field Type Description invitation_id string ID of created invitation invitation_code string Invitation code -- must be passed back in <code>LoginRequest</code> <p></p>"},{"location":"reference/proto/#ionoptions","title":"IonOptions","text":"<p>Options for creation of DID on the ION network</p> Field Type Description network IonOptions.IonNetwork ION network on which DID should be published <p></p>"},{"location":"reference/proto/#publicecosysteminformation","title":"PublicEcosystemInformation","text":"Field Type Description name string Public name of this ecosystem domain string Public domain for the owner of this ecosystem domain_verified bool Trinsic verified the domain is owned by the owner of this ecosystem style_display EcosystemDisplay Style display information description string Description of the ecosystem"},{"location":"reference/proto/#refreshdomainverificationstatusrequest","title":"RefreshDomainVerificationStatusRequest","text":""},{"location":"reference/proto/#refreshdomainverificationstatusresponse","title":"RefreshDomainVerificationStatusResponse","text":"Field Type Description domain string Domain URL verified domain_verified bool Specifies if the above <code>domain</code> was successfully verified"},{"location":"reference/proto/#retrievedomainverificationrecordrequest","title":"RetrieveDomainVerificationRecordRequest","text":""},{"location":"reference/proto/#retrievedomainverificationrecordresponse","title":"RetrieveDomainVerificationRecordResponse","text":"<p>Response message containing a TXT record content for domain url verification</p> Field Type Description verification_record_name string TXT record name to use for domain verification verification_record_Value string TXT code for domain verification <p></p>"},{"location":"reference/proto/#revokeauthorizationrequest","title":"RevokeAuthorizationRequest","text":"<p>Revoke permissions to a resource or path in the ecosystem</p> Field Type Description email string Email address of account having permission revoked. Mutually exclusive with <code>walletId</code>. walletId string Wallet ID of account having permission revoked. Mutually exclusive with <code>email</code>. resource string Resource string that account is losing permissions for. Resources are specified as a RESTful path: /{ecoId}/{resource type}/{resource id}. <code>ecoId</code> may be omitted. action string Action to revoke. Default is \"*\" (all) <p></p>"},{"location":"reference/proto/#revokeauthorizationresponse","title":"RevokeAuthorizationResponse","text":"<p>Response to <code>RevokeAuthorizationRequest</code></p> <p></p>"},{"location":"reference/proto/#searchwalletconfigurationresponse","title":"SearchWalletConfigurationResponse","text":"Field Type Description results WalletConfiguration[] Results matching the search query has_more bool Whether more results are available for this query via <code>continuation_token</code> continuation_token string Token to fetch next set of results via <code>SearchRequest</code>"},{"location":"reference/proto/#searchwalletconfigurationsrequest","title":"SearchWalletConfigurationsRequest","text":"<p>Search for issuers/holders/verifiers</p> Field Type Description query_filter string SQL filter to execute. <code>SELECT * FROM _ WHERE [**queryFilter**]</code> continuation_token string Token provided by previous <code>SearchResponse</code> if more data is available for query <p></p>"},{"location":"reference/proto/#updateecosystemrequest","title":"UpdateEcosystemRequest","text":"<p>Request to update an ecosystem's metadata</p> Field Type Description description string New description of the ecosystem uri string Deprecated. New external URL associated with the organization or ecosystem entity domain string New domain URL display EcosystemDisplayRequest New name string name = 4; Display details <p></p>"},{"location":"reference/proto/#updateecosystemresponse","title":"UpdateEcosystemResponse","text":"<p>Response to <code>UpdateEcosystemRequest</code></p> Field Type Description Ecosystem Ecosystem Current ecosystem metadata, post-update <p></p>"},{"location":"reference/proto/#upgradedidrequest","title":"UpgradeDidRequest","text":"<p>Request to upgrade a wallet</p> Field Type Description email string Email address of account to upgrade. Mutually exclusive with <code>walletId</code>. wallet_id string Wallet ID of account to upgrade. Mutually exclusive with <code>email</code>. method services.common.v1.SupportedDidMethod DID Method to which wallet should be upgraded ion_options IonOptions Configuration for creation of DID on ION network indy_options IndyOptions Configuration for creation of DID on INDY network <p></p>"},{"location":"reference/proto/#upgradedidresponse","title":"UpgradeDidResponse","text":"<p>Response to <code>UpgradeDIDRequest</code></p> Field Type Description did string New DID of wallet <p></p>"},{"location":"reference/proto/#walletconfiguration","title":"WalletConfiguration","text":"<p>Strongly typed information about wallet configurations</p> Field Type Description name string email string sms string wallet_id string public_did string config_type string <p></p>"},{"location":"reference/proto/#webhookconfig","title":"WebhookConfig","text":"<p>Webhook configured on an ecosystem</p> Field Type Description id string UUID of the webhook destination_url string HTTPS URL to POST webhook calls to events string[] Events the webhook is subscribed to status string Last known status of webhook (whether or not Trinsic can successfully reach destination) <p></p>"},{"location":"reference/proto/#indyoptionsindynetwork","title":"IndyOptions.IndyNetwork","text":"Name Number Description Danube 0 SovrinBuilder 1 SovrinStaging 2 Sovrin 3 IdUnionTest 4 IdUnion 5 IndicioTest 6 IndicioDemo 7 Indicio 8"},{"location":"reference/proto/#invitationstatusresponsestatus","title":"InvitationStatusResponse.Status","text":"Name Number Description Error 0 Onboarding resulted in error InvitationSent 1 The participant has been invited Completed 2 The participant has been onboarded Expired 3 The invite has expired"},{"location":"reference/proto/#ionoptionsionnetwork","title":"IonOptions.IonNetwork","text":"Name Number Description TestNet 0 MainNet 1"},{"location":"reference/proto/#participanttype","title":"ParticipantType","text":"<p>Type of participant being invited to ecosystem</p> Name Number Description participant_type_individual 0 Participant is an individual participant_type_organization 1 Participant is an organization <p></p> <p>Top</p>"},{"location":"reference/proto/#servicescommonv1commonproto","title":"services/common/v1/common.proto","text":""},{"location":"reference/proto/#nonce","title":"Nonce","text":"<p>Nonce used to generate an oberon proof</p> Field Type Description timestamp int64 UTC unix millisecond timestamp the request was made request_hash bytes blake3256 hash of the request body <p></p>"},{"location":"reference/proto/#responsestatus","title":"ResponseStatus","text":"Name Number Description SUCCESS 0 WALLET_ACCESS_DENIED 10 WALLET_EXISTS 11 ITEM_NOT_FOUND 20 SERIALIZATION_ERROR 200 UNKNOWN_ERROR 100"},{"location":"reference/proto/#supporteddidmethod","title":"SupportedDidMethod","text":"<p>Enum of all supported DID Methods https://docs.godiddy.com/en/supported-methods</p> Name Number Description KEY 0 The did:key method -- all wallets use this by default ION 1 The did:ion method -- Sidetree implementation on top of Bitcoin by Microsoft INDY 2 The did:sov method -- Hyperledger Indy based by Sovrin Foundation <p></p> <p>Top</p>"},{"location":"reference/proto/#servicesuniversal-walletv1universal-walletproto","title":"services/universal-wallet/v1/universal-wallet.proto","text":""},{"location":"reference/proto/#service-universalwallet","title":"Service - UniversalWallet","text":"Method Name Request Type Response Type Description GetItem GetItemRequest GetItemResponse Retrieve an item from the wallet with a given item identifier Search SearchRequest SearchResponse Search the wallet using a SQL syntax InsertItem InsertItemRequest InsertItemResponse Insert an item into the wallet UpdateItem UpdateItemRequest UpdateItemResponse Update an item in the wallet DeleteItem DeleteItemRequest DeleteItemResponse Delete an item from the wallet permanently"},{"location":"reference/proto/#deleteitemrequest","title":"DeleteItemRequest","text":"<p>Request to delete an item in a wallet</p> Field Type Description item_id string ID of item to delete <p></p>"},{"location":"reference/proto/#deleteitemresponse","title":"DeleteItemResponse","text":"<p>Response to <code>DeleteItemRequest</code></p> <p></p>"},{"location":"reference/proto/#getitemrequest","title":"GetItemRequest","text":"<p>Request to fetch an item from wallet</p> Field Type Description item_id string ID of item in wallet <p></p>"},{"location":"reference/proto/#getitemresponse","title":"GetItemResponse","text":"<p>Response to <code>GetItemRequest</code></p> Field Type Description item_json string Item data as a JSON string item_type string Type of item specified when item was inserted into wallet <p></p>"},{"location":"reference/proto/#insertitemrequest","title":"InsertItemRequest","text":"<p>Request to insert a JSON document into a wallet</p> Field Type Description item_json string Document to insert; must be stringified JSON item_type string Item type (ex. \"VerifiableCredential\") <p></p>"},{"location":"reference/proto/#insertitemresponse","title":"InsertItemResponse","text":"<p>Response to <code>InsertItemRequest</code></p> Field Type Description item_id string ID of item inserted into wallet <p></p>"},{"location":"reference/proto/#searchrequest","title":"SearchRequest","text":"<p>Request to search items in wallet</p> Field Type Description query string SQL Query to execute against items in wallet continuation_token string Token provided by previous <code>SearchResponse</code> if more data is available for query <p></p>"},{"location":"reference/proto/#searchresponse","title":"SearchResponse","text":"<p>Response to <code>SearchRequest</code></p> Field Type Description items string[] Array of query results, as JSON strings has_more bool Whether more results are available for this query via <code>continuation_token</code> continuation_token string Token to fetch next set of results via <code>SearchRequest</code> <p></p>"},{"location":"reference/proto/#updateitemrequest","title":"UpdateItemRequest","text":"<p>Request to update item in wallet</p> Field Type Description item_id string ID of item in wallet item_type string Item type (ex. \"VerifiableCredential\") <p></p>"},{"location":"reference/proto/#updateitemresponse","title":"UpdateItemResponse","text":"<p>Response to <code>UpdateItemRequest</code></p> <p></p> <p>Top</p>"},{"location":"reference/proto/#servicestrust-registryv1trust-registryproto","title":"services/trust-registry/v1/trust-registry.proto","text":""},{"location":"reference/proto/#service-trustregistry","title":"Service - TrustRegistry","text":"Method Name Request Type Response Type Description AddFramework AddFrameworkRequest AddFrameworkResponse Add a governance framework to the ecosystem RemoveFramework RemoveFrameworkRequest RemoveFrameworkResponse Remove a governance framework from the ecosystem SearchRegistry SearchRegistryRequest SearchRegistryResponse Search the ecosystem's governance frameworks RegisterMember RegisterMemberRequest RegisterMemberResponse Register an authoritative issuer for a credential schema UnregisterMember UnregisterMemberRequest UnregisterMemberResponse Removes an authoritative issuer for a credential schema from the trust registry GetMembershipStatus GetMembershipStatusRequest GetMembershipStatusResponse Fetch the membership status of an issuer for a given credential schema in a trust registry FetchData FetchDataRequest FetchDataResponse stream Not implemented."},{"location":"reference/proto/#addframeworkrequest","title":"AddFrameworkRequest","text":"<p>Request to register a new ecosystem governance framework in the current ecosystem</p> Field Type Description governance_framework_uri string URI of governance framework organization name string Name of governance framework organization description string Description of governance framework <p></p>"},{"location":"reference/proto/#addframeworkresponse","title":"AddFrameworkResponse","text":"<p>Response to <code>AddFrameworkRequest</code></p> Field Type Description id string Unique framework identifier governing_authority string DID URI of Trinsic account which created the governance framework trust_registry string URN of trust registry for governance framework <p></p>"},{"location":"reference/proto/#fetchdatarequest","title":"FetchDataRequest","text":"<p>Not implemented.</p> Field Type Description governance_framework_uri string query string <p></p>"},{"location":"reference/proto/#fetchdataresponse","title":"FetchDataResponse","text":"<p>Not implemented.</p> Field Type Description response_json string has_more_results bool continuation_token string <p></p>"},{"location":"reference/proto/#getmembershipstatusrequest","title":"GetMembershipStatusRequest","text":"<p>Request to fetch membership status in governance framework for a specific credential schema. Only one of <code>did_uri</code>, <code>x509_cert</code> may be specified.</p> Field Type Description governance_framework_uri string URI of governance framework did_uri string DID URI of member x509_cert string X.509 certificate of member schema_uri string URI of credential schema associated with membership <p></p>"},{"location":"reference/proto/#getmembershipstatusresponse","title":"GetMembershipStatusResponse","text":"<p>Response to <code>GetMembershipStatusRequest</code></p> Field Type Description status RegistrationStatus Status of member for given credential schema <p></p>"},{"location":"reference/proto/#governanceframework","title":"GovernanceFramework","text":"<p>Ecosystem Governance Framework</p> Field Type Description governance_framework_uri string URI of governance framework organization trust_registry_uri string URI of trust registry associated with governance framework description string Description of governance framework <p></p>"},{"location":"reference/proto/#registermemberrequest","title":"RegisterMemberRequest","text":"<p>Request to register a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.</p> Field Type Description did_uri string DID URI of member to register wallet_id string Trinsic Wallet ID of member to register email string Email address of member to register. Must be associated with an existing Trinsic account. schema_uri string URI of credential schema to register member as authorized issuer of valid_from_utc uint64 Unix Timestamp member is valid from. Member will not be considered valid before this timestamp. valid_until_utc uint64 Unix Timestamp member is valid until. Member will not be considered valid after this timestamp. framework_id string ID of the governance framework that member is being added to <p></p>"},{"location":"reference/proto/#registermemberresponse","title":"RegisterMemberResponse","text":"<p>Response to <code>RegisterMemberRequest</code></p> <p></p>"},{"location":"reference/proto/#removeframeworkrequest","title":"RemoveFrameworkRequest","text":"<p>Request to remove a governance framework from the current ecosystem</p> Field Type Description id string ID of governance framework to remove <p></p>"},{"location":"reference/proto/#removeframeworkresponse","title":"RemoveFrameworkResponse","text":"<p>Response to <code>RemoveFrameworkRequest</code></p> <p></p>"},{"location":"reference/proto/#searchregistryrequest","title":"SearchRegistryRequest","text":"<p>Request to search all governance frameworks within ecosystem</p> Field Type Description query string SQL query to execute against frameworks. Example: <code>SELECT c from c where c.type == 'GovernanceFramework'</code> continuation_token string Token to fetch next set of results, from previous <code>SearchRegistryResponse</code> <p></p>"},{"location":"reference/proto/#searchregistryresponse","title":"SearchRegistryResponse","text":"<p>Response to <code>SearchRegistryRequest</code></p> Field Type Description items_json string JSON string containing array of resultant objects has_more bool Whether more data is available to fetch for query continuation_token string Token to fetch next set of results via <code>SearchRegistryRequest</code> <p></p>"},{"location":"reference/proto/#unregistermemberrequest","title":"UnregisterMemberRequest","text":"<p>Request to unregister a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.</p> Field Type Description did_uri string DID URI of member to unregister wallet_id string Trinsic Wallet ID of member to unregister email string Email address of member to unregister. Must be associated with an existing Trinsic account. schema_uri string URI of credential schema to unregister member as authorized issuer of framework_id string ID of the governance framework that member is being removed from <p></p>"},{"location":"reference/proto/#unregistermemberresponse","title":"UnregisterMemberResponse","text":"<p>Response to <code>UnregisterMemberRequest</code></p> <p></p>"},{"location":"reference/proto/#registrationstatus","title":"RegistrationStatus","text":"Name Number Description CURRENT 0 Member is currently authorized, as of the time of the query EXPIRED 1 Member's authorization has expired TERMINATED 2 Member has voluntarily ceased Issuer role under the specific EGF REVOKED 3 Member authority under specific EGF was terminated by the governing authority NOT_FOUND 10 Member is not associated with given credential schema in the EGF <p>Top</p>"},{"location":"reference/proto/#servicesoptionsfield-optionsproto","title":"services/options/field-options.proto","text":""},{"location":"reference/proto/#sdktemplateoption","title":"SdkTemplateOption","text":"Field Type Description anonymous bool Whether the service endpoint allows anonymous (no auth token necessary) authentication This is used by the <code>protoc-gen-trinsic-sdk</code> plugin for metadata. ignore bool Whether the SDK template generator should ignore this method. This method will be wrapped manually. no_arguments bool Whether the SDK template generator should generate this method without arguments, eg ProviderService.GetEcosystemInfo() where the request object is empty"},{"location":"reference/proto/#file-level-extensions","title":"File-level Extensions","text":"Extension Type Base Number Description optional bool .google.protobuf.FieldOptions 60000 Whether field is optional in Trinsic's backend. This is not the same as an <code>optional</code> protobuf label; it only impacts documentation generation for the field. sdk_template_option SdkTemplateOption .google.protobuf.MethodOptions 60001 <p>Top</p>"},{"location":"reference/proto/#serviceseventv1eventproto","title":"services/event/v1/event.proto","text":""},{"location":"reference/proto/#apicall","title":"APICall","text":"Field Type Description source string request bytes response bytes"},{"location":"reference/proto/#governanceframeworkcreatedv1","title":"GovernanceFrameworkCreatedV1","text":"<p>Entity Governance Framework created and attached to ecosystem</p> Field Type Description id string UUID of the governance framework ecosystem_id string UUID of the ecosystem that owns this EGF trust_registry string Trust registry associated with this EGF governing_authority string Wallet ID of the authority for this EGF type string Type of EGF name string User-friendly name for the EGF description string Description of the EGF governance_framework string URI for the EGF timestamp string Timestamp event occurred, in ISO 8601 format (ex. <code>2022-07-07T08:09:10.11Z</code>) <p></p>"},{"location":"reference/proto/#itemreceivedv1","title":"ItemReceivedV1","text":"<p>Item inserted into wallet</p> Field Type Description id string UUID of the new item received string Timestamp when the item was received, in ISO 8601 format (ex. <code>2022-07-07T08:09:10.11Z</code>) wallet_id string ID of wallet ecosystem_id string Ecosystem where this event originated, if any. <p></p>"},{"location":"reference/proto/#pingv1","title":"PingV1","text":"<p>Webhook test event</p> Field Type Description id string UUID of this ping webhook_id string UUID of the webhook receiving the ping timestamp string Timestamp ping was requested, in ISO 8601 format (ex. <code>2022-07-07T08:09:10.11Z</code>) message string Arbitrary message specified when ping was requested ecosystem_id string Ecosystem where this event originated, if any. <p></p>"},{"location":"reference/proto/#templatecreatedv1","title":"TemplateCreatedV1","text":"<p>Template created in ecosystem</p> Field Type Description id string UUID of the template ecosystem_id string UUID of the ecosystem that owns this template name string Template name type string Template type created_by string WalletID that created the template timestamp string Timestamp event occurred, in ISO 8601 format (ex. <code>2022-07-07T08:09:10.11Z</code>) <p></p>"},{"location":"reference/proto/#eventtype","title":"EventType","text":"<p>All event types</p> Name Number Description PING 0 LOG 1 GOVERNANCE_FRAMEWORK_CREATED 5 GOVERNANCE_FRAMEWORK_MEMBER_REGISTERED 6 GOVERNANCE_FRAMEWORK_MEMBER_UNREGISTERED 7 TEMPLATE_CREATED 10 TEMPLATE_DELETED 11 WALLET_CREATED 15 ITEM_RECEIVED 16 CREDENTIAL_ISSUED 17 <p></p>"},{"location":"reference/proto/#file-level-extensions_1","title":"File-level Extensions","text":"Extension Type Base Number Description event_type EventType .google.protobuf.MessageOptions 60002 Event type associated with this Event message. <p>Top</p>"},{"location":"reference/proto/#servicesfile-managementv1file-managementproto","title":"services/file-management/v1/file-management.proto","text":""},{"location":"reference/proto/#service-filemanagement","title":"Service - FileManagement","text":"Method Name Request Type Response Type Description UploadFile UploadFileRequest UploadFileResponse Upload a file to Trinsic's CDN GetFile GetFileRequest GetFileResponse Fetch information about a file by its ID DeleteFile DeleteFileRequest DeleteFileResponse Delete a file by its ID ListFiles ListFilesRequest ListFilesResponse List files the calling account has uploaded GetStorageStats GetStorageStatsRequest GetStorageStatsResponse Get statistics about files uploaded by the calling account"},{"location":"reference/proto/#deletefilerequest","title":"DeleteFileRequest","text":"<p>Request to delete a file from Trinsic's CDN by ID</p> Field Type Description id string ID of file to delete <p></p>"},{"location":"reference/proto/#deletefileresponse","title":"DeleteFileResponse","text":"<p>Response to <code>DeleteFileRequest</code>. Empty payload.</p> <p></p>"},{"location":"reference/proto/#file","title":"File","text":"<p>Contains information about a file stored in Trinsic's CDN</p> Field Type Description id string ID of file, generated randomly by Trinsic on upload uploader_id string Wallet ID of uploader size uint32 Size, in bytes, of file mime_type string Uploader-provided MIME type of file uploaded string ISO 8601 timestamp of when file was uploaded to Trinsic url string CDN URL of file <p></p>"},{"location":"reference/proto/#getfilerequest","title":"GetFileRequest","text":"<p>Request to fetch information about a stored file</p> Field Type Description id string ID of file to fetch <p></p>"},{"location":"reference/proto/#getfileresponse","title":"GetFileResponse","text":"<p>Response to <code>GetFileRequest</code></p> Field Type Description file File File specified by <code>id</code> parameter of <code>GetFileRequest</code>. <p></p>"},{"location":"reference/proto/#getstoragestatsrequest","title":"GetStorageStatsRequest","text":"<p>Request to get statistics about files uploaded by this account</p> <p></p>"},{"location":"reference/proto/#getstoragestatsresponse","title":"GetStorageStatsResponse","text":"<p>Response to <code>GetStorageStatsRequest</code></p> Field Type Description stats StorageStats Statistics about files uploaded by the calling account <p></p>"},{"location":"reference/proto/#listfilesrequest","title":"ListFilesRequest","text":"<p>Request to list files</p> Field Type Description query string Query to search with. If not specified, will return the most recent 100 files. continuation_token string Token provided by previous <code>ListFilesRequest</code> if more data is available for query <p></p>"},{"location":"reference/proto/#listfilesresponse","title":"ListFilesResponse","text":"<p>Response to <code>ListFilesRequest</code></p> Field Type Description files File[] Files found by query has_more_results bool Whether more results are available for this query via <code>continuation_token</code> continuation_token string Token to fetch next set of resuts via <code>ListFilesRequest</code> <p></p>"},{"location":"reference/proto/#storagestats","title":"StorageStats","text":"<p>Represents aggregate statistics of all files uploaded by a single issuer</p> Field Type Description num_files uint32 Number of files uploaded by this account total_size uint64 Sum total size of all files, in bytes <p></p>"},{"location":"reference/proto/#uploadfilerequest","title":"UploadFileRequest","text":"<p>Request to upload a file to Trinsic's CDN</p> Field Type Description contents bytes Raw content of file mime_type string MIME type describing file contents <p></p>"},{"location":"reference/proto/#uploadfileresponse","title":"UploadFileResponse","text":"<p>Response to <code>UploadFileRequest</code></p> Field Type Description uploaded_file File Information about newly-uploaded file <p></p> <p>Top</p>"},{"location":"reference/proto/#servicesaccountv1accountproto","title":"services/account/v1/account.proto","text":""},{"location":"reference/proto/#service-account","title":"Service - Account","text":"Method Name Request Type Response Type Description SignIn SignInRequest SignInResponse Sign in to an already existing account Login LoginRequest LoginResponse Begin login flow for specified account, creating one if it does not already exist LoginConfirm LoginConfirmRequest LoginConfirmResponse Finalize login flow with two-factor confirmation code Info AccountInfoRequest AccountInfoResponse Get account information ListDevices ListDevicesRequest ListDevicesResponse List all connected devices RevokeDevice RevokeDeviceRequest RevokeDeviceResponse Revoke device access to the account's cloud wallet AuthorizeWebhook AuthorizeWebhookRequest AuthorizeWebhookResponse Authorize Ecosystem to receive webhook events"},{"location":"reference/proto/#accountdetails","title":"AccountDetails","text":"<p>Account registration details</p> Field Type Description name string Account name email string Email address of account sms string SMS number including country code <p></p>"},{"location":"reference/proto/#accountecosystem","title":"AccountEcosystem","text":"<p>Deprecated</p> Field Type Description id string name string description string uri string <p></p>"},{"location":"reference/proto/#accountinforequest","title":"AccountInfoRequest","text":"<p>Request for information about the account used to make the request</p> <p></p>"},{"location":"reference/proto/#accountinforesponse","title":"AccountInfoResponse","text":"<p>Information about the account used to make the request</p> Field Type Description details AccountDetails The account details associated with the calling request context ecosystems AccountEcosystem[] Deprecated. Use <code>ecosystem_id</code> instead wallet_id string The wallet ID associated with this account device_id string The device ID associated with this account session ecosystem_id string The ecosystem ID within which this account resides public_did string The public DID associated with this account. This DID is used as the <code>issuer</code> when signing verifiable credentials authorized_webhooks string[] Webhook events, if any, this wallet has authorized <p></p>"},{"location":"reference/proto/#accountprofile","title":"AccountProfile","text":"<p>Device profile containing sensitive authentication data. This information should be stored securely</p> Field Type Description profile_type string The type of profile, used to differentiate between protocol schemes or versions auth_data bytes Auth data containg information about the current device access auth_token bytes Secure token issued by server used to generate zero-knowledge proofs protection TokenProtection Token security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication. <p></p>"},{"location":"reference/proto/#authorizewebhookrequest","title":"AuthorizeWebhookRequest","text":"<p>Request to authorize Ecosystem provider to receive webhooks for events which occur on this wallet.</p> Field Type Description events string[] Events to authorize access to. Default is \"*\" (all events) <p></p>"},{"location":"reference/proto/#authorizewebhookresponse","title":"AuthorizeWebhookResponse","text":"<p>Response to <code>AuthorizeWebhookRequest</code></p> <p></p>"},{"location":"reference/proto/#listdevicesrequest","title":"ListDevicesRequest","text":""},{"location":"reference/proto/#listdevicesresponse","title":"ListDevicesResponse","text":""},{"location":"reference/proto/#loginconfirmrequest","title":"LoginConfirmRequest","text":"<p>Request to finalize login flow</p> Field Type Description challenge bytes Challenge received from <code>Login</code> confirmation_code_hashed bytes Two-factor confirmation code sent to account email or phone, hashed using Blake3. Our SDKs will handle this hashing process for you. <p></p>"},{"location":"reference/proto/#loginconfirmresponse","title":"LoginConfirmResponse","text":"<p>Response to <code>LoginConfirmRequest</code></p> Field Type Description profile AccountProfile Profile response; must be unprotected using unhashed confirmation code. Our SDKs will handle this process for you, and return to you an authentication token string. <p></p>"},{"location":"reference/proto/#loginrequest","title":"LoginRequest","text":"<p>Request to begin login flow</p> Field Type Description email string Email address of account. If unspecified, an anonymous account will be created. invitation_code string Deprecated. DEPRECATED, will be removed April 1st 2023 Invitation code associated with this registration ecosystem_id string ID of Ecosystem to sign into. Ignored if <code>invitation_code</code> is passed. <p></p>"},{"location":"reference/proto/#loginresponse","title":"LoginResponse","text":"<p>Response to <code>LoginRequest</code></p> Field Type Description challenge bytes Random byte sequence unique to this login request. If present, two-factor confirmation of login is required. Must be sent back, unaltered, in <code>LoginConfirm</code>. profile AccountProfile Account profile response. If present, no confirmation of login is required. <p></p>"},{"location":"reference/proto/#revokedevicerequest","title":"RevokeDeviceRequest","text":""},{"location":"reference/proto/#revokedeviceresponse","title":"RevokeDeviceResponse","text":""},{"location":"reference/proto/#signinrequest","title":"SignInRequest","text":"<p>Request for creating or signing into an account</p> Field Type Description details AccountDetails Account registration details invitation_code string Deprecated. DEPRECATED, will be removed April 1st 2023 Invitation code associated with this registration ecosystem_id string ID of Ecosystem to use Ignored if <code>invitation_code</code> is passed <p></p>"},{"location":"reference/proto/#signinresponse","title":"SignInResponse","text":"<p>Response for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc.</p> Field Type Description confirmation_method ConfirmationMethod Indicates if confirmation of account is required. profile AccountProfile Contains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data. <p></p>"},{"location":"reference/proto/#tokenprotection","title":"TokenProtection","text":"<p>Token protection info</p> Field Type Description enabled bool Indicates if token is protected using a PIN, security code, HSM secret, etc. method ConfirmationMethod The method used to protect the token <p></p>"},{"location":"reference/proto/#confirmationmethod","title":"ConfirmationMethod","text":"<p>Confirmation method type for two-factor workflows</p> Name Number Description None 0 No confirmation required Email 1 Email confirmation required Sms 2 SMS confirmation required ConnectedDevice 3 Confirmation from a connected device is required Other 10 Third-party method of confirmation is required <p></p> <p>Top</p>"},{"location":"reference/proto/#sdkoptionsv1optionsproto","title":"sdk/options/v1/options.proto","text":""},{"location":"reference/proto/#serviceoptions","title":"ServiceOptions","text":"<p>Configuration for Trinsic SDK Services</p> Field Type Description server_endpoint string Trinsic API endpoint. Defaults to <code>prod.trinsic.cloud</code> server_port int32 Trinsic API port; defaults to <code>443</code> server_use_tls bool Whether TLS is enabled between SDK and Trinsic API; defaults to <code>true</code> auth_token string Authentication token for SDK calls; defaults to empty string (unauthenticated) <p>Default ecosystem ID to use for various SDK calls; defaults to <code>default</code> string default_ecosystem = 5; |</p>"},{"location":"reference/proto/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"reference/services/account-service/","title":"Account Service","text":"<p>The Account Service allows you to create and sign in to accounts.</p> <p>Wallets vs Accounts</p> <p>Wallets and accounts are related and often interchangeable -- each account has an associated wallet, and operations on a wallet are performed using an account's access token.</p> <p>Every account has exactly one wallet.</p> <p>Authentication Tokens</p> <p>When you create or sign in to an account, the response is an authentication token string.</p> <p>This string is an encoded form of your account profile, as well as an access key to perform calls using the account.</p> <p>These are effectively API keys; they should be kept safe and never published.</p>"},{"location":"reference/services/account-service/#login","title":"Login","text":"<p>Attempts the first step of the login process for the specified account, creating it if it does not already exist.</p> <p>Trinsic will response with a <code>challenge</code>, and send an authentication code to the account's email address.</p> <p>The authentication code must be passed along with <code>challenge</code> to LoginConfirm to finalize the login.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic account login --email \"bob@example.com\" --ecosystem \"&lt;ecosystem id or name&gt;\"\n</code></pre> <pre><code>const loginResponse = await trinsic.account().login(\nLoginRequest.fromPartial({\necosystemId: myEcosystemIdOrName(),\nemail: \"bob@example.com\",\n})\n);\n</code></pre> <pre><code>var loginResponse = await trinsic.Account.LoginAsync(new() {\n// ecosystem id or name\nEcosystemId = ecosystemId,\nEmail = \"bob@example.com\"\n});\n</code></pre> <pre><code>login_response = await trinsic.account.login(\n    request=LoginRequest(\n        email=\"bob@example.com\", ecosystem_id=\"&lt;ecosystem id or name&gt;\"\n    )\n)\n</code></pre> <pre><code>loginResponse, err := trinsic.Account().Login(context.Background(), &amp;account.LoginRequest{\nEmail:       \"bob@example.com\",\nEcosystemId: myEcosystemIdOrName,\n})\n</code></pre> <pre><code>var loginResponse =\ntrinsic\n.account()\n.login(\nLoginRequest.newBuilder()\n.setEmail(\"bob@example.com\")\n.setEcosystemId(myEcosystemIdOrName)\n.build())\n.get();\n</code></pre> <p>LoginRequestRequest to begin login flowemail optional stringEmail address of account. If unspecified, an anonymous account will be created.invitation_code optional stringDEPRECATED, will be removed April 1st 2023 Invitation code associated with this registrationecosystem_id optional stringID of Ecosystem to sign into. Ignored if <code>invitation_code</code> is passed.</p> <p>LoginResponseResponse to <code>LoginRequest</code>challenge bytesRandom byte sequence unique to this login request. If present, two-factor confirmation of login is required. Must be sent back, unaltered, in <code>LoginConfirm</code>.profile AccountProfileAccount profile response. If present, no confirmation of login is required.Show child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is required</p> <p>Anonymous Login</p> <p>Anonymous accounts are accounts which are not tied to any email or phone number, and do not require any authentication. They are typically used for testing and prototypes.</p> <p>To create an anonymous account with an SDK, use the <code>TrinsicService.LoginAnonymous()</code> method.</p> <p>To create an anonymous account with the CLI, simply leave the <code>email</code> parameter unspecified.</p>"},{"location":"reference/services/account-service/#login-confirm","title":"Login Confirm","text":"<p>Finalizes the login process.</p> <p>You must pass <code>challenge</code> as it was received in response to Login, along with the confirmation code that was sent in an email.</p> <p>Our SDK will take care of hashing the confirmation code for you.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic account login --email \"bob@example.com\"\n</code></pre> <pre><code>const authToken = await trinsic\n.account()\n.loginConfirm(loginResponse.challenge, \"12345\");\n</code></pre> <pre><code>var authToken = await trinsic.Account.LoginConfirmAsync(loginResponse.Challenge, authCode);\n</code></pre> <pre><code>auth_token = await trinsic.account.login_confirm(\n    challenge=login_response.challenge, auth_code=\"12345\"\n)\n</code></pre> <pre><code>authToken, err := trinsic.Account().LoginConfirm(context.Background(), loginResponse.GetChallenge(), \"12345\")\n</code></pre> <pre><code>var authToken = trinsic.account().loginConfirm(myLoginResponse.getChallenge(), \"12345\").get();\n</code></pre> <p>LoginConfirmRequestRequest to finalize login flowchallenge bytesChallenge received from <code>Login</code>confirmation_code_hashed bytesTwo-factor confirmation code sent to account email or phone, hashed using Blake3. Our SDKs will handle this hashing process for you.</p> <p>LoginConfirmResponseResponse to <code>LoginConfirmRequest</code>profile AccountProfileProfile response; must be unprotected using unhashed confirmation code. Our SDKs will handle this process for you, and return to you an authentication token string.Show child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is required</p>"},{"location":"reference/services/account-service/#get-account-info","title":"Get Account Info","text":"<p>Returns the account information (name, email address, phone number, etc.) used to create the currently-active account profile.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic account info\n</code></pre> <pre><code>const info = await accountService.info();\n</code></pre> <pre><code>var info = await trinsic.Account.GetInfoAsync();\n</code></pre> <pre><code>info = await service.get_info()\n</code></pre> <pre><code>info2, err2 := trinsic.Account().GetInfo(context.Background())\n</code></pre> <pre><code>var info = trinsic.account().getInfo().get();\n</code></pre> <p>AccountInfoRequestRequest for information about the account used to make the requestThis message has no fields</p> <p>AccountInfoResponseInformation about the account used to make the requestdetails AccountDetailsThe account details associated with the calling request contextShow child attributesdetails.name optional stringAccount namedetails.email optional stringEmail address of accountdetails.sms optional stringSMS number including country codeecosystems AccountEcosystem[]Use <code>ecosystem_id</code> insteadShow child attributesecosystems[i].id stringecosystems[i].name stringecosystems[i].description stringecosystems[i].uri stringwallet_id stringThe wallet ID associated with this accountdevice_id stringThe device ID associated with this account sessionecosystem_id stringThe ecosystem ID within which this account residespublic_did stringThe public DID associated with this account. This DID is used as the <code>issuer</code> when signing verifiable credentialsauthorized_webhooks string[]Webhook events, if any, this wallet has authorized</p> <p>Note</p> <p>This call returns the information associated with the authentication token used to create the request; therefore, it is not possible to pass a different authentication token to this call. Otherwise, Trinsic's zero-knowledge proof authentication scheme would be violated.</p> <p>When using the CLI, this will return information for the account most recently logged in to.</p> <p>When using the SDK, this will return information for the authentication token stored in the <code>AccountService</code> instance's <code>ServiceOptions.AuthToken</code> field, which will be the account most recently logged in to, unless you have manually set this value yourself.</p>"},{"location":"reference/services/account-service/#authorize-webhook","title":"Authorize Webhook","text":"<p>Authorizes the ecosystem provider to receive webhooks pertaining to this wallet.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic account authorize-webhook --events \"*\"\n</code></pre> <pre><code>const response = await trinsic.account().authorizeWebhook(\nAuthorizeWebhookRequest.fromPartial({\nevents: [\"*\"], // Authorize all events\n})\n);\n</code></pre> <pre><code>var request = new AuthorizeWebhookRequest();\nrequest.Events.Add(\"*\"); //Authorize all events\n\nawait trinsic.Account.AuthorizeWebhookAsync(request);\n</code></pre> <pre><code>request = AuthorizeWebhookRequest()\nrequest.events.append(\"*\")\nresponse = await trinsic.account.authorize_webhook(request=request)\n</code></pre> <pre><code>request := &amp;account.AuthorizeWebhookRequest{\nEvents: []string{\"*\"}, //Authorize all events\n}\n\nauthResponse, err := trinsic.Account().AuthorizeWebhook(context.Background(), request)\n</code></pre> <pre><code>var authorizeResponse =\ntrinsic\n.account()\n.authorizeWebhook(\nAuthorizeWebhookRequest.newBuilder()\n.addEvents(\"*\") // Authorize all events\n.build())\n.get();\n</code></pre> <p>AuthorizeWebhookRequestRequest to authorize Ecosystem provider to receive webhooks for events which occur on this wallet.events string[]Events to authorize access to. Default is \"*\" (all events)</p> <p>AuthorizeWebhookResponseResponse to <code>AuthorizeWebhookRequest</code>This message has no fields</p>"},{"location":"reference/services/account-service/#protect-account-profile","title":"Protect Account Profile","text":"<p>Deprecated Sign-in Flow</p> <p>This section is related to the the deprecated SignIn endpoint; the new Login flow does not require the use of <code>Protect</code> and <code>Unprotect</code>.</p> <p>Protects the specified account profile with a security code. It is not possible to execute this call using the CLI.</p> TypeScriptC#PythonGoJava <pre><code>const protectedProfile = await accountService.protect(accountProfile, \"1234\");\n</code></pre> <pre><code>var securityCode = \"1234\";\nvar myProtectedProfile = AccountService.Protect(myProfile!, securityCode);\nvar myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n</code></pre> <pre><code>code = b\"1234\"\nmy_protected_profile = account_service.protect(\n    profile=my_profile, security_code=code\n)\nmy_unprotected_profile = account_service.unprotect(\n    profile=my_protected_profile, security_code=code\n)\n</code></pre> <pre><code>securityCode := \"1234\"\nprotectedProfile, err := trinsic.Account().Protect(profile, securityCode)\nif !assert2.Nil(err) {\nreturn\n}\nunprotectedProfile, err := trinsic.Account().Unprotect(protectedProfile, securityCode)\nif !assert2.Nil(err) {\nreturn\n}\n</code></pre> <pre><code>var code = \"1234\";\nvar myProtectedProfile = AccountService.protect(myProfile, code);\nvar myUnprotectedProfile = AccountService.unprotect(myProtectedProfile, code);\n</code></pre> <p>Info</p> <p>In this context, \"protection\" refers to a cryptographic operation on the authorization token for an account.</p> <p>Protecting an account profile with code <code>c</code> returns a new access token which is unusable until it is unprotected with the same code <code>c</code>. It is not possible to reverse the protection process without the original protection code.</p> <p>You will receive a protected account profile from Trinsic if you attempt to sign in to an account via email, SMS, or any other method which requires authentication. Trinsic will send a security code to the email or phone number associated with the account, which can be used to unprotect the account profile.</p> <p>Specifically, Trinsic is using Oberon to handle access tokens; protection and unprotection is handled using the blinding/unblinding features of Oberon.</p>"},{"location":"reference/services/account-service/#unprotect-account-profile","title":"Unprotect Account Profile","text":"<p>Deprecated Sign-in Flow</p> <p>This section is related to the the deprecated SignIn endpoint; the new Login flow does not require the use of <code>Protect</code> and <code>Unprotect</code>.</p> <p>Unprotects the specified account profile using the given code. It is not possible to execute this call using the CLI.</p> <p>The profile must have been previously protected using the same code that is being used to unprotect it. Profiles can be protected using any arbitrary code via the Protect method.</p> <p>Most commonly, this method is used on a protected profile received from the Sign In method. The code to unprotect it will have been sent to the account owner via email or SMS.</p> TypeScriptC#PythonGoJava <pre><code>const accountProfile = await accountService.unprotect(protectedProfile, \"1234\");\n</code></pre> <pre><code>var securityCode = \"1234\";\nvar myProtectedProfile = AccountService.Protect(myProfile!, securityCode);\nvar myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n</code></pre> <pre><code>code = b\"1234\"\nmy_protected_profile = account_service.protect(\n    profile=my_profile, security_code=code\n)\nmy_unprotected_profile = account_service.unprotect(\n    profile=my_protected_profile, security_code=code\n)\n</code></pre> <pre><code>securityCode := \"1234\"\nprotectedProfile, err := trinsic.Account().Protect(profile, securityCode)\nif !assert2.Nil(err) {\nreturn\n}\nunprotectedProfile, err := trinsic.Account().Unprotect(protectedProfile, securityCode)\nif !assert2.Nil(err) {\nreturn\n}\n</code></pre> <pre><code>var code = \"1234\";\nvar myProtectedProfile = AccountService.protect(myProfile, code);\nvar myUnprotectedProfile = AccountService.unprotect(myProtectedProfile, code);\n</code></pre>"},{"location":"reference/services/account-service/#deprecated-sign-in","title":"[Deprecated] Sign In","text":"<p>Deprecated</p> <p>This endpoint is deprecated, and will be removed in the near future.</p> <p>Please use Login and LoginConfirm.</p> <p>Sign in to an existing account, or create a new one.</p> <p>If no account details are passed to this method, an anonymous account will be created.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic account login --email &lt;PROFILE_EMAIL&gt; --name &lt;PROFILE_NAME&gt;\n</code></pre> <pre><code>const allison = (await accountService.signIn()).getProfile();\n</code></pre> <pre><code>var myProfile = await trinsic.Account.LoginAnonymousAsync(myEcosystemId);\n</code></pre> <pre><code>my_profile = await account_service.login_anonymous(\n    ecosystem_id=my_ecosystem_id_or_name\n)\n</code></pre> <pre><code>profile, err := trinsic.Account().LoginAnonymous(context.Background(), myEcosystemIdOrName)\nif !assert2.Nil(err) {\nreturn\n}\n</code></pre> <pre><code>var myProfile = trinsic.account().signIn(myEcosystemIdOrName).get();\n</code></pre> <p>SignInRequestRequest for creating or signing into an accountdetails optional AccountDetailsAccount registration detailsShow child attributesdetails.name optional stringAccount namedetails.email optional stringEmail address of accountdetails.sms optional stringSMS number including country codeinvitation_code optional stringDEPRECATED, will be removed April 1st 2023 Invitation code associated with this registrationecosystem_id optional stringID of Ecosystem to use Ignored if <code>invitation_code</code> is passed</p> <p>SignInResponseResponse for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc.confirmation_method ConfirmationMethodIndicates if confirmation of account is required.Show enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is requiredprofile AccountProfileContains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data.Show child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is required</p> <p>This operation, if successful, returns an authentication token string.</p> <p>Protected Authentication Tokens</p> <p>If you are attempting to login to a non-anonymous account (by specifying an email address or phone number), the authentication token returned will be protected, and cannot be used until it has been unprotected.</p> <p>Trinsic will have sent a security code to the account's email address or phone number; this security code must be used with the Unprotect call to receive a usable authentication token.</p> <p>In the future, we will provide an SDK call to determine if an authentication token is protected.</p>"},{"location":"reference/services/credential-service/","title":"Credential Service","text":"<p>The Credential Service exposes functionality for issuance, proof generation, verification, and revocation of Verifiable Credentials.</p> <p>Signature Format</p> <p>The Credential service currently supports BBS+ Signatures , which enable selective disclosure of credential fields during proof generation.</p> <p>Credentials are signed, and proofs are created, using a key pair unique to the signing / holding wallet. This key pair is created and managed by Trinsic upon account creation.</p>"},{"location":"reference/services/credential-service/#issue-credential","title":"Issue Credential","text":"<p>Issues a credential from a valid JSON-LD document. Issued credentials are not automatically stored in any wallet.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic vc issue --document &lt;JSONLD_FILE&gt; --out &lt;OUTPUT_FILE&gt;\n</code></pre> <pre><code>const issueResponse = await trinsic\n.credential()\n.issue(IssueRequest.fromPartial({ documentJson: credentialJSON }));\n</code></pre> <pre><code>var credential = await trinsic.Credential.IssueAsync(new() { DocumentJson = credentialJson });\n</code></pre> <pre><code>issue_response = await trinsic_service.credential.issue(\n    request=IssueRequest(document_json=credential_json)\n)\n</code></pre> <pre><code>issueResponse, err := trinsic.Credential().Issue(context.Background(),\n&amp;credential.IssueRequest{\nDocumentJson: unsignedCredential,\n})\n</code></pre> <pre><code>var issueResult =\ntrinsic\n.credential()\n.issue(IssueRequest.newBuilder().setDocumentJson(unsignedCredential).build())\n.get();\n\nvar signedCredentialJson = issueResult.getSignedDocumentJson();\n</code></pre> <p>IssueRequestRequest to sign a JSON-LD Credential using public key tied to callerdocument_json stringValid JSON-LD Credential document to be signed, in string form</p> <p>IssueResponseResponse to <code>IssueRequest</code>signed_document_json stringVerifiable Credential document, signed with public key tied to caller of <code>IssueRequest</code></p> <p>Warning</p> <p><code>IssueCredential</code> requires a valid JSON-LD document to be provided. Do not confuse this operation with Issue Credential From Template.</p> <p>When provided a valid credential, this endpoint creates and appends the <code>proof</code> object, using a key pair tied to the issuing Trinsic account.</p> <p>You can learn more about how to create these documents, and about VC data models in general, from W3C: VC Data Model v1.1.</p>"},{"location":"reference/services/credential-service/#issue-credential-from-template","title":"Issue Credential from Template","text":"<p>Issues a credential from a previously-defined template.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic vc issue-from-template [OPTIONS] --template-id &lt;ID&gt;\n\n# OPTIONS\n# --out &lt;OUTPUT_FILE&gt;     (Optional) Output file to store the issued credential\n# --values-data &lt;JSON&gt;    The JSON values of the credential subject\n# --values-file &lt;FILE&gt;    The file with JSON values of the credential subject\n</code></pre> <pre><code>let request = IssueFromTemplateRequest.fromPartial({\ntemplateId: templateResponse?.data?.id ?? \"\",\nvaluesJson: JSON.stringify({\nname: \"Alice\",\nnumberOfBags: 2,\ndateOfBirth: new Date(\"1/1/2000\").toISOString(),\nvaccinated: true,\n}),\n});\n\nlet response = await trinsic.credential().issueFromTemplate(request);\n</code></pre> <pre><code>var credentialJson = await trinsic.Credential.IssueFromTemplateAsync(new() {\nTemplateId = templateId,\nValuesJson = values\n});\n</code></pre> <pre><code>values = json.dumps({\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"age\": \"42\"})\nissue_response = await trinsic_service.credential.issue_from_template(\n    request=IssueFromTemplateRequest(\n        template_id=template.data.id, values_json=values\n    )\n)\n</code></pre> <pre><code>issueTemplateResponse, err := trinsic.Credential().IssueFromTemplate(context.Background(),\n&amp;credential.IssueFromTemplateRequest{\nValuesJson: valuesJson,\nTemplateId: templateId,\n})\n</code></pre> <pre><code>var valuesMap = new HashMap&lt;String, Object&gt;();\nvaluesMap.put(\"firstName\", \"Jane\");\nvaluesMap.put(\"lastName\", \"Doe\");\nvaluesMap.put(\"age\", 42);\nvar valuesJson = new Gson().toJson(valuesMap);\nvar issueResponse =\ntrinsic\n.credential()\n.issueFromTemplate(\nIssueFromTemplateRequest.newBuilder()\n.setTemplateId(template.getData().getId())\n.setValuesJson(valuesJson)\n.build())\n.get();\n</code></pre> <p>IssueFromTemplateRequestRequest to create and sign a JSON-LD Verifiable Credential from a template using public key tied to callertemplate_id stringID of template to usevalues_json stringJSON document string with keys corresponding to the fields of the template referenced by <code>template_id</code>framework_id optional stringGovernance framework ID to use with issuance of this credential. If specified, the issued credential will contain extended issuer metadata with membership info for the given ecosystem governance framework (EGF)save_copy boolSave a copy of the issued credential to this user's wallet. This copy will only contain the credential data, but not the secret proof value. Issuers may use this data to keep track of the details for revocation status.</p> <p>IssueFromTemplateResponseResponse to <code>IssueFromTemplateRequest</code>document_json stringVerifiable Credential document, in JSON-LD form, constructed from the specified template and values; signed with public key tied to caller of <code>IssueFromTemplateRequest</code></p>"},{"location":"reference/services/credential-service/#check-revocation-status","title":"Check Revocation Status","text":"<p>Checks a credential's revocation status by its <code>credential_status_id</code>.</p> <p>A <code>credential_status_id</code> can be found in a credential's <code>credentialStatus.id</code> field, if present.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic vc get-status --credential-status-id &lt;ID&gt;\n</code></pre> <pre><code>let checkStatusResponse = await trinsic\n.credential()\n.checkStatus(CheckStatusRequest.fromPartial({}));\n</code></pre> <pre><code>var checkResponse = await trinsic.Credential.CheckStatusAsync(new() { CredentialStatusId = \"\" });\n</code></pre> <pre><code>#     check_response = await trinsic_service.credential.check_status(\n#         request=CheckStatusRequest(credential_status_id=\"\")\n#     )\n</code></pre> <pre><code>status, err := trinsic.Credential().CheckStatus(context.Background(), &amp;credential.CheckStatusRequest{CredentialStatusId: \"\"})\n</code></pre> <pre><code>var checkStatusResponse =\ntrinsic.credential().checkStatus(CheckStatusRequest.newBuilder().build()).get();\n</code></pre> <p>CheckStatusRequestRequest to check a credential's revocation statuscredential_status_id stringCredential Status ID to check. This is not the same as the credential's ID.</p> <p>CheckStatusResponseResponse to <code>CheckStatusRequest</code>revoked boolThe credential's revocation status</p>"},{"location":"reference/services/credential-service/#update-revocation-status","title":"Update Revocation Status","text":"<p>Updates the revocation status of a credential (revoke or unrevoke).</p> <p>A <code>credential_status_id</code> can be found in a credential's <code>credentialStatus.id</code> field, if present.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code># Revoke a credential\ntrinsic vc update-status --revoked --credential-status-id &lt;ID&gt;\n\n# Unrevoke a credential\ntrinsic vc update-status --unrevoked --credential-status-id &lt;ID&gt;\n</code></pre> <pre><code>let updateStatusResponse = await trinsic\n.credential()\n.updateStatus(UpdateStatusRequest.fromPartial({}));\n</code></pre> <pre><code>await trinsic.Credential.UpdateStatusAsync(new() { CredentialStatusId = \"\", Revoked = true });\n</code></pre> <pre><code>#     update_response = await trinsic_service.credential.update_status(\n#         request=UpdateStatusRequest(credential_status_id=\"\", revoked=True)\n#     )\n</code></pre> <pre><code>updateResponse, err := trinsic.Credential().UpdateStatus(context.Background(), &amp;credential.UpdateStatusRequest{CredentialStatusId: \"\", Revoked: true})\n</code></pre> <pre><code>trinsic.credential().updateStatus(UpdateStatusRequest.newBuilder().build());\n</code></pre> <p>UpdateStatusRequestRequest to update a credential's revocation statuscredential_status_id stringCredential Status ID to update. This is not the same as the credential's ID.revoked boolNew revocation status of credential</p> <p>UpdateStatusResponseResponse to <code>UpdateStatusRequest</code>This message has no fields</p>"},{"location":"reference/services/credential-service/#create-proof","title":"Create Proof","text":"<p>Creates and signs a proof for a valid JSON-LD credential, using the BBS+ Signature Suite.</p> <p>If the credential is stored in a Trinsic cloud wallet, pass its <code>item_id</code>; otherwise, pass the raw JSON-LD credential via <code>document_json</code>.</p> <p>Selective Disclosure</p> <p>BBS+ Signatures support the ability to generate a proof for a subset of a credential's fields, instead of every field.</p> <pre><code>This enables increased user privacy: fields which aren't included in `reveal_document_json` will not be present in the generated proof.\n\n1. If `reveal_document_json` is passed, a proof will be generated for only the fields specified. This is a JSON-LD frame.\n2. Rather than formulating a complete JSON-LD frame, you can instead provide a list of proof attributes to reveal, and the service will construct the JSON-LD proof frame internally\n3. If neither is provided, the entire proof will be returned.\n</code></pre>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic vc create-proof --document-id &lt;STRING&gt; --out &lt;OUTPUT_FILE&gt; --reveal-document &lt;JSONLD_FRAME_FILE&gt;\n</code></pre> <pre><code>let proof = await trinsic.credential().createProof(\nCreateProofRequest.fromPartial({\nitemId: insertItemResponse.itemId,\nrevealDocumentJson: getVaccineCertFrameJSON(),\n})\n);\nlet selectiveProof = await trinsic.credential().createProof(\nCreateProofRequest.fromPartial({\nitemId: insertItemResponse.itemId,\nrevealTemplate: {\ntemplateAttributes: [\"firstName\", \"lastName\"]\n}\n})\n);\n</code></pre> <pre><code>var proof = await trinsic.Credential.CreateProofAsync(new() {\nDocumentJson = credentialJson.DocumentJson,\nRevealDocumentJson = frame.ToString(Formatting.None)\n});\nvar selectiveProof = await trinsic.Credential.CreateProofAsync(new() {\nDocumentJson = credentialJson.DocumentJson,\nRevealTemplate = new() {\n// The other field, not disclosed, is \"age\"\nTemplateAttributes = { \"firstName\",\"lastName\" }\n}\n});\n</code></pre> <pre><code>proof_response = await trinsic_service.credential.create_proof(\n    request=CreateProofRequest(\n        reveal_document_json=proof_request_json, document_json=credential_json\n    )\n)\nselective_proof_response = await trinsic_service.credential.create_proof(\n    request=CreateProofRequest(\n        document_json=credential_json,\n        reveal_template=RevealTemplateAttributes(\n            template_attributes=[\"firstName\", \"lastName\"]\n        ),\n    )\n)\n</code></pre> <pre><code>request := &amp;credential.CreateProofRequest{\nProof: &amp;credential.CreateProofRequest_DocumentJson{\nDocumentJson: credentialJson,\n},\n}\n\nproofResponse, err := trinsic.Credential().CreateProof(context.Background(), request)\n\nselectiveRequest := &amp;credential.CreateProofRequest{\nProof: &amp;credential.CreateProofRequest_DocumentJson{\nDocumentJson: credentialJson,\n},\nDisclosure: &amp;credential.CreateProofRequest_RevealTemplate{RevealTemplate: &amp;credential.RevealTemplateAttributes{TemplateAttributes: []string{\"name\"}}},\n}\n\nselectiveResponse, err2 := trinsic.Credential().CreateProof(context.Background(), selectiveRequest)\n</code></pre> <pre><code>var createProofResponse =\ntrinsic\n.credential()\n.createProof(\nCreateProofRequest.newBuilder()\n.setDocumentJson(signedCredentialJson)\n.setRevealDocumentJson(proofRequestJson)\n.build())\n.get();\n\nvar credentialProof = createProofResponse.getProofDocumentJson();\n\nvar selectiveProofResponse =\ntrinsic\n.credential()\n.createProof(\nCreateProofRequest.newBuilder()\n.setDocumentJson(signedCredentialJson)\n.setRevealTemplate(\nRevealTemplateAttributes.newBuilder()\n.addTemplateAttributes(\"batchNumber\")\n.build())\n.build())\n.get();\n\nvar selectiveProof = selectiveProofResponse.getProofDocumentJson();\n</code></pre> <p>CreateProofRequestRequest to create a proof for a Verifiable Credential using public key tied to caller. Either <code>item_id</code> or <code>document_json</code> may be provided, not both.reveal_document_json stringA valid JSON-LD frame describing which fields should be revealed in the generated proof. If unspecified, all fields in the document will be revealedreveal_template RevealTemplateAttributesInformation about what sections of the document to revealShow child attributesreveal_template.template_attributes string[]A list of document attributes to reveal. If unset, all attributes will be returned.item_id stringID of wallet item stored in a Trinsic cloud walletdocument_json stringA valid JSON-LD Verifiable Credential document string with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet.nonce optional bytesNonce value used to derive the proof. If not specified, a random nonce will be generated. This value may be represented in base64 format in the proof model.</p> <p>CreateProofResponseResponse to <code>CreateProofRequest</code>proof_document_json stringValid JSON-LD proof for the specified credential</p>"},{"location":"reference/services/credential-service/#verify-proof","title":"Verify Proof","text":"<p>Verifies a proof for validity and authenticity. Only supports BBS+ Signatures at present.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code># The JSONLD_FILE refers to the proof document obtained from a CreateProofResponse\ntrinsic vc issuer verify-proof --proof-document &lt;JSONLD_FILE&gt;\n</code></pre> <pre><code>let verifyResponse = await trinsic.credential().verifyProof({\nproofDocumentJson: proof.proofDocumentJson,\n});\n\n\u22ef\n\nproofDocumentJson: selectiveProof.proofDocumentJson,\n</code></pre> <pre><code>var valid = await trinsic.Credential.VerifyProofAsync(new() { ProofDocumentJson = proof.ProofDocumentJson });\n</code></pre> <pre><code>verify_result = await trinsic_service.credential.verify_proof(\n    request=VerifyProofRequest(proof_document_json=credential_proof)\n)\nselective_verify_result = await trinsic_service.credential.verify_proof(\n    request=VerifyProofRequest(\n        proof_document_json=selective_proof_response.proof_document_json\n    )\n)\n</code></pre> <pre><code>verifyResponse, err := trinsic.Credential().VerifyProof(context.Background(), &amp;credential.VerifyProofRequest{\nProofDocumentJson: proofJson,\n})\n</code></pre> <pre><code>var verifyProofResponse =\ntrinsic\n.credential()\n.verifyProof(\nVerifyProofRequest.newBuilder().setProofDocumentJson(credentialProof).build())\n.get();\n\nboolean isValid = verifyProofResponse.getIsValid();\n</code></pre> <p>VerifyProofRequestRequest to verify a proofproof_document_json stringJSON-LD proof document string to verify</p> <p>VerifyProofResponseResponse to <code>VerifyProofRequest</code>is_valid boolWhether all validations in <code>validation_results</code> passedvalidation_messages string[]Use <code>validation_results</code> insteadvalidation_results map(string -&gt; ValidationMessage)Results of each validation check performed, such as schema conformance, revocation status, signature, etc. Detailed results are provided for failed validations.Show child attributesvalidation_results[key].is_valid boolWhether this validation check passedvalidation_results[key].messages string[]If validation failed, contains messages explaining why</p> Validation Results <p>The verification process performs a number of validations, each of which may fail independently of the others.</p> <p>For example, a credential may be expired or revoked, but otherwise perfectly valid.</p> <p><code>validation_results</code> contains an entry for each of the following verification steps:</p> Name Description <code>SignatureVerification</code> The cryptographic proof over the entire Verifiable Credential, specifically using BBS+ Proof of Signature <code>CredentialStatus</code> (if supported by credential) Checks if credential has been revoked <code>SchemaConformance</code> Ensures credential conforms with its schema. It is possible to issue a credential omitting a required field (as captured in the credential template). If your use case allows this kind of omission, you can ignore this validation entry. <code>TrustRegistryMembership</code> (if relevant) Verifies that credential issuer is an authorized member of the credential's governing Trust Registry <code>IssuerIsSigner</code> Document <code>issuer</code> is same DID as document signer. If false, it is not safe to assume that the claimed <code>issuer</code> actually issued the credential."},{"location":"reference/services/credential-service/#exchange-credentials","title":"Exchange Credentials","text":""},{"location":"reference/services/credential-service/#send-via-email","title":"Send via Email","text":"<p>Sends a credential to a user via email.</p> <p>The specified email address must be tied to an existing account in the same ecosystem.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic vc send --email &lt;EMAIL_ADDRESS&gt; --item &lt;FILE&gt;\n</code></pre> <pre><code>await trinsic.credential().send(SendRequest.fromPartial({\nemail: \"\",\ndocumentJson: JSON.stringify({}),\n}));\n</code></pre> <pre><code>var sendResponse = await trinsic.Credential.SendAsync(new() { Email = \"example@trinsic.id\" });\n</code></pre> <pre><code>send_response = await trinsic_service.credential.send(\n    request=SendRequest(\n        document_json=credential_json, email=\"example@trinsic.id\"\n    )\n)\n</code></pre> <pre><code>sendResponse, err := trinsic.Credential().Send(context.Background(), &amp;credential.SendRequest{\nDeliveryMethod: &amp;credential.SendRequest_Email{\nEmail: \"example@trinsic.id\",\n},\nDocumentJson: credentialJson,\n})\n</code></pre> <pre><code>trinsic\n.credential()\n.send(\nSendRequest.newBuilder()\n.setDocumentJson(signedCredentialJson)\n.setEmail(recipientEmail)\n.build());\n</code></pre> <p>SendRequestRequest to send a document to another user's walletemail stringEmail address of user to send item towallet_id stringDID of recipient (presently unsupported) string did_uri = 2 [deprecated=true]; DIDComm out-of-band invitation JSON (presently unsupported) string didcomm_invitation_json = 3 [deprecated=true]; Wallet ID of the recipient within the ecosystemsend_notification boolSend email notification that credential has been sent to a walletdocument_json stringJSON document to send to recipient</p> <p>SendResponseResponse to <code>SendRequest</code>This message has no fields</p> <p>Alternative Exchange Protocols</p> <p>Credentials may only be sent to a wallet via email address or with the InsertItem call.</p> <p>There are a number of ongoing industry efforts to standardize exchange protocols, such as:</p> <ul> <li>DIDComm Messaging </li> <li>Wallet And Credential Interactions </li> <li>OpenID Connect Credential Provider </li> </ul> <p>We aim to provide support for these methods as they mature.</p>"},{"location":"reference/services/provider-service/","title":"Provider Service","text":"<p>The Provider Service enables the creation and management of ecosystems and webhooks.</p> <p>Named vs Anonymous ecosystems</p> <p>There are two types of ecosystems: named and anonymous.</p> <p>Named ecosystems are suitable for production, and will be prepared for you by Trinsic during onboarding.</p> <p>Anonymous ecosystems have auto-generated names (such as <code>eager-elephant-94jkn5h</code>), and may be created by anyone at any time.</p> <p>Using an anonymous ecosystem for purposes other than prototyping and testing is considered an unauthorized use of Trinsic's platform.</p>"},{"location":"reference/services/provider-service/#create-ecosystem","title":"Create Ecosystem","text":"<p>Creates a new ecosystem, along with a root controlling account.</p> <p>If <code>name</code> is left empty, an anonymous ecosystem will be created.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic provider create-ecosystem --name &lt;ECOSYSTEM_NAME&gt; --email &lt;OWNER_EMAIL&gt;\n</code></pre> <pre><code>let createResponse = await trinsic.provider().createEcosystem(\nCreateEcosystemRequest.fromPartial({\ndescription: \"Test ecosystem from Node\",\nuri: \"https://example.com\",\n})\n);\n</code></pre> <pre><code>var (ecosystem, authToken) = await trinsic.Provider.CreateEcosystemAsync(new() {\nDescription = \"My ecosystem\",\nDomain = \"https://example.com\"\n});\n</code></pre> <pre><code>actual_create = await trinsic_service.provider.create_ecosystem(\n    request=CreateEcosystemRequest(\n        description=\"My ecosystem\", uri=\"https://example.com\"\n    )\n)\n</code></pre> <pre><code>actualCreate, err := trinsic.Provider().CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\nDescription: \"My ecosystem\",\nUri:         \"https://example.com\",\n})\n</code></pre> <pre><code>var response =\ntrinsic\n.provider()\n.createEcosystem(\nCreateEcosystemRequest.newBuilder()\n.setDescription(\"My ecosystem\")\n.setUri(\"https://example.com\")\n.build())\n.get();\n</code></pre> <p>CreateEcosystemRequestRequest to create an ecosystemname optional stringGlobally unique name for the Ecosystem. This name will be part of the ecosystem-specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen. If not passed, ecosystem name will be auto-generated.description optional stringEcosystem descriptionuri optional stringExternal URL associated with your organization or ecosystem entitydetails AccountDetailsThe account details of the owner of the ecosystemShow child attributesdetails.name optional stringAccount namedetails.email optional stringEmail address of accountdetails.sms optional stringSMS number including country codedomain stringNew domain URL</p> <p>CreateEcosystemResponseResponse to <code>CreateEcosystemRequest</code>ecosystem EcosystemDetails of the created ecosystemShow child attributesecosystem.id stringURN of the ecosystemecosystem.name stringGlobally unique name for the ecosystemecosystem.description stringEcosystem descriptionecosystem.uri stringExternal URL associated with the organization or ecosystem entityecosystem.webhooks WebhookConfig[]Configured webhooks, if anyShow child attributesecosystem.webhooks[i].id stringUUID of the webhookecosystem.webhooks[i].destination_url stringHTTPS URL to POST webhook calls toecosystem.webhooks[i].events string[]Events the webhook is subscribed toecosystem.webhooks[i].status stringLast known status of webhook (whether or not Trinsic can successfully reach destination)ecosystem.display EcosystemDisplayDisplay detailsShow child attributesecosystem.display.light EcosystemDisplayDetailsRemoved the Dark after discussion with team, as we don't provide a dark UI anywhere (yet) in our platform.    EcosystemDisplayDetails dark = 1;Show child attributesecosystem.display.light.logo_url stringstring id = 1; string name = 2;ecosystem.display.light.color stringecosystem.domain stringDomainprofile AccountProfileAccount profile for auth of the owner of the ecosystemShow child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is requiredconfirmation_method ConfirmationMethodIndicates if confirmation of account is required.Show enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is required</p>"},{"location":"reference/services/provider-service/#update-ecosystem","title":"Update Ecosystem","text":"<p>Updates the active ecosystem's <code>description</code> or <code>uri</code>.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic provider update-ecosystem \\\n--description \"New description\" \\\n--uri \"https://new-example.com\"\n</code></pre> <pre><code>let updateResponse = await trinsic.provider().updateEcosystem(\nUpdateEcosystemRequest.fromPartial({\ndescription: \"New ecosystem description\",\nuri: \"https://new-example.com\",\n})\n);\n</code></pre> <pre><code>var updateResult = await trinsic.Provider.UpdateEcosystemAsync(new() {\nDescription = \"New ecosystem description\",\nDomain = \"New ecosystem URI\"\n});\n</code></pre> <pre><code>request = UpdateEcosystemRequest(\n    description=\"My new description\", uri=\"https://example.com\"\n)\nresponse = await trinsic.provider.update_ecosystem(request=request)\n</code></pre> <pre><code>updateRequest := &amp;provider.UpdateEcosystemRequest{\nDescription: \"My new description\",\nUri:         \"https://new-example.com\",\n}\n\nupdateResponse, err := trinsic.Provider().UpdateEcosystem(context.Background(), updateRequest)\n</code></pre> <pre><code>var updateResponse =\ntrinsic\n.provider()\n.updateEcosystem(\nUpdateEcosystemRequest.newBuilder().setDescription(\"My updated ecosystem\").build())\n.get();\n</code></pre> <p>UpdateEcosystemRequestRequest to update an ecosystem's metadatadescription stringNew description of the ecosystemuri stringNew external URL associated with the organization or ecosystem entitydomain stringNew domain URLdisplay EcosystemDisplayRequestNew name string name = 4; Display detailsShow child attributesdisplay.light EcosystemDisplayDetailsRequestRemoved the Dark after discussion with team, as we don't provide a dark UI anywhere (yet) in our platform. EcosystemDisplayDetailsRequest dark = 1;Show child attributesdisplay.light.color stringstring id = 1; string name = 2;    string logo_url = 3;display.light.logo_data bytesdisplay.light.logo_format stringMIME type of the file</p> <p>UpdateEcosystemResponseResponse to <code>UpdateEcosystemRequest</code>Ecosystem EcosystemCurrent ecosystem metadata, post-updateShow child attributesEcosystem.id stringURN of the ecosystemEcosystem.name stringGlobally unique name for the ecosystemEcosystem.description stringEcosystem descriptionEcosystem.uri stringExternal URL associated with the organization or ecosystem entityEcosystem.webhooks WebhookConfig[]Configured webhooks, if anyShow child attributesEcosystem.webhooks[i].id stringUUID of the webhookEcosystem.webhooks[i].destination_url stringHTTPS URL to POST webhook calls toEcosystem.webhooks[i].events string[]Events the webhook is subscribed toEcosystem.webhooks[i].status stringLast known status of webhook (whether or not Trinsic can successfully reach destination)Ecosystem.display EcosystemDisplayDisplay detailsShow child attributesEcosystem.display.light EcosystemDisplayDetailsRemoved the Dark after discussion with team, as we don't provide a dark UI anywhere (yet) in our platform.    EcosystemDisplayDetails dark = 1;Show child attributesEcosystem.display.light.logo_url stringstring id = 1; string name = 2;Ecosystem.display.light.color stringEcosystem.domain stringDomain</p>"},{"location":"reference/services/provider-service/#get-ecosystem-info","title":"Get Ecosystem Info","text":"<p>Fetches information about the active ecosystem.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic provider ecosystem-info\n</code></pre> <pre><code>const infoResponse = await trinsic\n.provider()\n.ecosystemInfo(EcosystemInfoRequest.fromPartial({}));\n\nconst ecosystem = infoResponse.ecosystem;\n</code></pre> <pre><code>var infoResult = await trinsic.Provider.EcosystemInfoAsync(new());\n</code></pre> <pre><code>response = await trinsic.provider.ecosystem_info(request=EcosystemInfoRequest())\necosystem = response.ecosystem\n</code></pre> <pre><code>infoResponse, err := trinsic.Provider().EcosystemInfo(context.Background(), &amp;provider.EcosystemInfoRequest{})\n</code></pre> <pre><code>var infoResponse =\ntrinsic.provider().ecosystemInfo(EcosystemInfoRequest.getDefaultInstance()).get();\n</code></pre> <p>EcosystemInfoRequestRequest to fetch information about an ecosystemThis message has no fields</p> <p>EcosystemInfoResponseResponse to <code>InfoRequest</code>ecosystem EcosystemEcosystem corresponding to current ecosystem in the account tokenShow child attributesecosystem.id stringURN of the ecosystemecosystem.name stringGlobally unique name for the ecosystemecosystem.description stringEcosystem descriptionecosystem.uri stringExternal URL associated with the organization or ecosystem entityecosystem.webhooks WebhookConfig[]Configured webhooks, if anyShow child attributesecosystem.webhooks[i].id stringUUID of the webhookecosystem.webhooks[i].destination_url stringHTTPS URL to POST webhook calls toecosystem.webhooks[i].events string[]Events the webhook is subscribed toecosystem.webhooks[i].status stringLast known status of webhook (whether or not Trinsic can successfully reach destination)ecosystem.display EcosystemDisplayDisplay detailsShow child attributesecosystem.display.light EcosystemDisplayDetailsRemoved the Dark after discussion with team, as we don't provide a dark UI anywhere (yet) in our platform.    EcosystemDisplayDetails dark = 1;Show child attributesecosystem.display.light.logo_url stringstring id = 1; string name = 2;ecosystem.display.light.color stringecosystem.domain stringDomain</p>"},{"location":"reference/services/provider-service/#add-webhook","title":"Add Webhook","text":"<p>Adds a webhook to an ecosystem.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic provider add-webhook \\\n--url \"https://example.com/webhooks/trinsic\" \\\n--secret \"my well-kept secret\" \\\n--events \"*\"\n</code></pre> <pre><code>let addResponse = await trinsic.provider().addWebhook(\nAddWebhookRequest.fromPartial({\ndestinationUrl: \"https://example.com/webhooks/trinsic\",\nsecret: \"my well-kept secret\",\nevents: [\"*\"],\n})\n);\n</code></pre> <pre><code>var addWebhookResponse = await trinsic.Provider.AddWebhookAsync(new() {\nDestinationUrl = \"https://example.com/webhooks/trinsic\",\nSecret = \"my well-kept secret\"\n});\n</code></pre> <pre><code>request = AddWebhookRequest(\n    destination_url=\"https://example.com/webhooks/trinsic\",\n    secret=\"my well-kept secret\",\n)\nrequest.events.append(\"*\")  # Enable all events\n\nresponse = await trinsic.provider.add_webhook(request=request)\n</code></pre> <pre><code>request := &amp;provider.AddWebhookRequest{\nDestinationUrl: \"https://example.com/webhooks/trinsic\",\nSecret:         \"my well-kept secret\",\nEvents:         []string{\"*\"}, // All events\n}\n\nresponse, err := trinsic.Provider().AddWebhook(context.Background(), request)\n</code></pre> <pre><code>var addWebhookResponse =\ntrinsic\n.provider()\n.addWebhook(\nAddWebhookRequest.newBuilder()\n.setDestinationUrl(\"https://example.com/webhooks/trinsic\")\n.setSecret(\"my well-kept secret\")\n.addEvents(\"*\") // All events\n.build())\n.get();\n</code></pre> <p>AddWebhookRequestRequest to add a webhook to an ecosystemdestination_url stringDestination to post webhook calls to. Must be a reachable HTTPS URL.secret stringSecret string used for HMAC-SHA256 signing of webhook payloads to verify that a webhook comes from Trinsicevents string[]Events to subscribe to. Default is \"*\" (all events)</p> <p>AddWebhookResponseResponse to <code>AddWebhookRequest</code>ecosystem EcosystemEcosystem data with new webhookShow child attributesecosystem.id stringURN of the ecosystemecosystem.name stringGlobally unique name for the ecosystemecosystem.description stringEcosystem descriptionecosystem.uri stringExternal URL associated with the organization or ecosystem entityecosystem.webhooks WebhookConfig[]Configured webhooks, if anyShow child attributesecosystem.webhooks[i].id stringUUID of the webhookecosystem.webhooks[i].destination_url stringHTTPS URL to POST webhook calls toecosystem.webhooks[i].events string[]Events the webhook is subscribed toecosystem.webhooks[i].status stringLast known status of webhook (whether or not Trinsic can successfully reach destination)ecosystem.display EcosystemDisplayDisplay detailsShow child attributesecosystem.display.light EcosystemDisplayDetailsRemoved the Dark after discussion with team, as we don't provide a dark UI anywhere (yet) in our platform.    EcosystemDisplayDetails dark = 1;Show child attributesecosystem.display.light.logo_url stringstring id = 1; string name = 2;ecosystem.display.light.color stringecosystem.domain stringDomain</p> <p>Webhook Limits</p> <p>At present, an ecosystem can have no more than 10 webhooks.</p> <p>Wallet Webhook Events</p> <p>In order to receive webhooks for events which occur on a wallet, an additional authorization step must be performed.</p> <p>See AuthorizeWebhook for more info.</p>"},{"location":"reference/services/provider-service/#delete-webhook","title":"Delete Webhook","text":"<p>Deletes a webhook from an ecosystem.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic provider delete-webhook --webhook-id &lt;WEBHOOK_ID&gt;\n</code></pre> <pre><code>let deleteResponse = await trinsic.provider().deleteWebhook(\nDeleteWebhookRequest.fromPartial({\nwebhookId: webhookId,\n})\n);\n</code></pre> <pre><code>var deleteWebhookResponse = await trinsic.Provider.DeleteWebhookAsync(new() {\nWebhookId = webhookId\n});\n</code></pre> <pre><code>response = await trinsic.provider.delete_webhook(\n    request=DeleteWebhookRequest(webhook_id)\n)\n</code></pre> <pre><code>request := &amp;provider.DeleteWebhookRequest{\nWebhookId: webhookId,\n}\n\ndeleteResponse, err := trinsic.Provider().DeleteWebhook(context.Background(), request)\n</code></pre> <pre><code>var deleteWebhookResponse =\ntrinsic\n.provider()\n.deleteWebhook(DeleteWebhookRequest.newBuilder().setWebhookId(webhookId).build())\n.get();\n</code></pre> <p>DeleteWebhookRequestRequest to delete a webhook from an ecosystemwebhook_id stringID of webhook to delete</p> <p>DeleteWebhookResponseResponse to <code>DeleteWebhookRequest</code>ecosystem EcosystemEcosystem data after removal of webhookShow child attributesecosystem.id stringURN of the ecosystemecosystem.name stringGlobally unique name for the ecosystemecosystem.description stringEcosystem descriptionecosystem.uri stringExternal URL associated with the organization or ecosystem entityecosystem.webhooks WebhookConfig[]Configured webhooks, if anyShow child attributesecosystem.webhooks[i].id stringUUID of the webhookecosystem.webhooks[i].destination_url stringHTTPS URL to POST webhook calls toecosystem.webhooks[i].events string[]Events the webhook is subscribed toecosystem.webhooks[i].status stringLast known status of webhook (whether or not Trinsic can successfully reach destination)ecosystem.display EcosystemDisplayDisplay detailsShow child attributesecosystem.display.light EcosystemDisplayDetailsRemoved the Dark after discussion with team, as we don't provide a dark UI anywhere (yet) in our platform.    EcosystemDisplayDetails dark = 1;Show child attributesecosystem.display.light.logo_url stringstring id = 1; string name = 2;ecosystem.display.light.color stringecosystem.domain stringDomain</p>"},{"location":"reference/services/provider-service/#upgrade-wallet-did","title":"Upgrade Wallet DID","text":"<p>Restricted API</p> <p>This feature is not yet publicly available, and the list of supported DID Methods is not final.</p> <p>Please contact Trinsic to enable this endpoint on your account.</p> <p>Ledger Interactions</p> <p>Depending on the DID Method chosen, you may be responsible for ledger write fees; additionally, there are some logistical concerns to be aware of.</p> <p>Click here to learn more. </p> <p>Upgrades a wallet's DID from the default <code>did:key</code> to another DID Method. This endpoint may only be called by an ecosystem provider.</p> <p>Trinsic will register a DID Document for you, and update the wallet's <code>public_did</code> property to the newly-registered DID. Credentials previously issued by this wallet will not have their <code>issuer</code> field updated to the new DID, but they will still verify correctly.</p> <p>Presently, once a wallet's DID has been upgraded, its DID Method cannot be changed again. However, it is possible to perform further upgrades within a method, to go from a testing to production network (for example, <code>did:ion:test</code> to <code>did:ion</code>). </p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic provider upgrade-did --wallet-id {wallet_id} --method ion --method-options testnet\n</code></pre> <pre><code>let upgradeResponse = await trinsic.provider().upgradeDID(\nUpgradeDidRequest.fromPartial({\nwalletId: walletId,\nmethod: SupportedDidMethod.ION,\nionOptions: IonOptions.fromPartial({\nnetwork: IonOptions_IonNetwork.TestNet,\n}),\n})\n);\n</code></pre> <pre><code>var upgradeResponse = await trinsic.Provider.UpgradeDIDAsync(new() {\nWalletId = walletId,\nMethod = SupportedDidMethod.Ion,\nIonOptions = new() {\nNetwork = IonOptions.Types.IonNetwork.TestNet\n}\n});\n</code></pre> <pre><code>upgrade_response = await trinsic.provider.upgrade_did(\n    request=UpgradeDidRequest(\n        wallet_id=wallet_id,\n        method=SupportedDidMethod.ION,\n        ion_options=IonOptions(network=IonOptionsIonNetwork.TestNet),\n    )\n)\n</code></pre> <pre><code>upgradeResponse, err := trinsic.Provider().UpgradeDID(context.Background(), &amp;provider.UpgradeDidRequest{\nAccount: &amp;provider.UpgradeDidRequest_WalletId{\nWalletId: walletId,\n},\nMethod: common.SupportedDidMethod_ION,\nOptions: &amp;provider.UpgradeDidRequest_IonOptions{\nIonOptions: &amp;provider.IonOptions{\nNetwork: provider.IonOptions_TestNet,\n},\n},\n})\n</code></pre> <pre><code>var upgradeRequest =\nUpgradeDidRequest.newBuilder()\n.setWalletId(walletId)\n.setMethod(SupportedDidMethod.ION)\n.setIonOptions(\nIonOptions.newBuilder().setNetwork(IonOptions.IonNetwork.TestNet).build())\n.build();\n\nvar upgradeResponse = trinsic.provider().upgradeDID(upgradeRequest).get();\n</code></pre> <p>UpgradeDidRequestRequest to upgrade a walletemail stringEmail address of account to upgrade. Mutually exclusive with <code>walletId</code>.wallet_id stringWallet ID of account to upgrade. Mutually exclusive with <code>email</code>.method SupportedDidMethodDID Method to which wallet should be upgradedShow enum valuesSupportedDidMethod.KEY  = 0The did:key method -- all wallets use this by defaultSupportedDidMethod.ION  = 1The did:ion method -- Sidetree implementation on top of Bitcoin by MicrosoftSupportedDidMethod.INDY  = 2The did:sov method -- Hyperledger Indy based by Sovrin Foundationion_options IonOptionsConfiguration for creation of DID on ION networkShow child attributesion_options.network IonNetworkION network on which DID should be publishedShow enum valuesIonNetwork.TestNet  = 0IonNetwork.MainNet  = 1indy_options IndyOptionsConfiguration for creation of DID on INDY networkShow child attributesindy_options.network IndyNetworkSOV network on which DID should be publishedShow enum valuesIndyNetwork.Danube  = 0IndyNetwork.SovrinBuilder  = 1IndyNetwork.SovrinStaging  = 2IndyNetwork.Sovrin  = 3IndyNetwork.IdUnionTest  = 4IndyNetwork.IdUnion  = 5IndyNetwork.IndicioTest  = 6IndyNetwork.IndicioDemo  = 7IndyNetwork.Indicio  = 8</p> <p>UpgradeDidResponseResponse to <code>UpgradeDIDRequest</code>did stringNew DID of wallet</p>"},{"location":"reference/services/template-service/","title":"Template Service","text":"<p>The Template Service allows you to manage and search Credential Templates.</p> <p>Templates are optional</p> <p>Templates are designed to be a helpful abstraction over the complexities of producing valid JSON-LD Verifiable Credentials.</p> <p>You aren't required to use templates; if you produce valid JSON-LD VCs yourself, they can be issued through Trinsic.</p>"},{"location":"reference/services/template-service/#create-template","title":"Create Template","text":"<p>Creates a new credential template.</p> <p>In the background, Trinsic will also generate and save a valid JSON-LD Context and schema for your template.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic template create --name 'My Credential' --fields-data '{\\\"field1\\\":{}}'\n</code></pre> <pre><code>const credentialTemplateName = `My First Credential Template-${uuid()}`;\nconst nameField = TemplateField.fromPartial({\ndescription: \"The name of the person\",\ntype: FieldType.STRING,\noptional: false,\n});\n\nconst numberOfBags = TemplateField.fromPartial({\ntype: FieldType.NUMBER,\ndescription: \"The number of bags the person is taking on the trip\",\noptional: false,\n});\n\nconst dateOfBirth = TemplateField.fromPartial({\ntype: FieldType.DATETIME,\ndescription: \"The date of birth of the person\",\noptional: false,\n});\n\nconst isVaccinated = TemplateField.fromPartial({\ntype: FieldType.BOOL,\ndescription: \"Whether or not the person has been vaccinated\",\noptional: false,\n});\n</code></pre> <pre><code>CreateCredentialTemplateRequest templateRequest = new() {\nName = \"An Example Credential\",\nAllowAdditionalFields = false\n};\ntemplateRequest.Fields.Add(\"firstName\", new() { Description = \"Given name\" });\ntemplateRequest.Fields.Add(\"lastName\", new());\ntemplateRequest.Fields.Add(\"age\", new() { Optional = true }); // TODO - use FieldType.NUMBER once schema validation is fixed.\n\nvar template = await trinsic.Template.CreateAsync(templateRequest);\n</code></pre> <pre><code>template = await trinsic_service.template.create(\n    request=CreateCredentialTemplateRequest(\n        name=f\"An Example Credential: {uuid.uuid4()}\",\n        allow_additional_fields=False,\n        fields={\n            \"firstName\": TemplateField(description=\"Given name\"),\n            \"lastName\": TemplateField(),\n            \"age\": TemplateField(optional=True, type=FieldType.NUMBER),\n        },\n    )\n)\n</code></pre> <pre><code>templateRequest := &amp;template.CreateCredentialTemplateRequest{Name: fmt.Sprintf(\"Example Template - %s\", uuid.New()), AllowAdditionalFields: false, Fields: make(map[string]*template.TemplateField)}\ntemplateRequest.Fields[\"firstName\"] = &amp;template.TemplateField{Description: \"Given name\"}\ntemplateRequest.Fields[\"lastName\"] = &amp;template.TemplateField{}\ntemplateRequest.Fields[\"age\"] = &amp;template.TemplateField{Type: template.FieldType_NUMBER, Optional: true}\n\ntemplateResponse, err := trinsic.Template().Create(context.Background(), templateRequest)\n</code></pre> <pre><code>var fields = new HashMap&lt;String, TemplateField&gt;();\nfields.put(\"firstName\", TemplateField.newBuilder().setDescription(\"Given name\").build());\nfields.put(\"lastName\", TemplateField.newBuilder().build());\nfields.put(\n\"age\", TemplateField.newBuilder().setType(FieldType.NUMBER).setOptional(true).build());\nvar templateRequest =\nCreateCredentialTemplateRequest.newBuilder()\n.setName(\"My Example Credential-\" + UUID.randomUUID())\n.setAllowAdditionalFields(false)\n.putAllFields(fields)\n.build();\nvar template = trinsic.template().create(templateRequest).get();\n</code></pre> <p>CreateCredentialTemplateRequestRequest to create a new templatename stringName of new templatefields map(string -&gt; TemplateField)Fields which compose the templateShow child attributesfields[key].description stringHuman-readable description of the fieldfields[key].optional boolWhether this field may be omitted when a credential is issued against the templatefields[key].type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4FieldType.URI  = 5fields[key].annotations map(string -&gt; string)Annotations for the field that may be used to add additional informationallow_additional_fields boolWhether credentials may be issued against this template which have fields not specified in <code>fields</code></p> <p>CreateCredentialTemplateResponseResponse to <code>CreateCredentialTemplateRequest</code>data TemplateDataCreated templateShow child attributesdata.id stringTemplate IDdata.name stringTemplate namedata.version int32Template version numberdata.fields map(string -&gt; TemplateField)Fields defined for the templateShow child attributesdata.fields[key].description stringHuman-readable description of the fielddata.fields[key].optional boolWhether this field may be omitted when a credential is issued against the templatedata.fields[key].type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4FieldType.URI  = 5data.fields[key].annotations map(string -&gt; string)Annotations for the field that may be used to add additional informationdata.allow_additional_fields boolWhether credentials issued against this template may contain fields not defined by templatedata.schema_uri stringURI pointing to template JSON schema documentdata.context_uri stringURI pointing to template JSON-LD context documentdata.ecosystem_id stringID of ecosystem in which template residesdata.type stringTemplate type (<code>VerifiableCredential</code>)data.created_by stringID of template creatordata.date_created stringDate when template was created as ISO 8601 utc string</p>"},{"location":"reference/services/template-service/#get-template","title":"Get Template","text":"<p>Fetches a template definition by <code>id</code>.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic template get --id &lt;TEMPLATE_ID&gt;\n</code></pre> <pre><code>let getTemplateResponse = await trinsic.template().get(GetCredentialTemplateRequest.fromPartial({\nid: \"id\"\n}));\n</code></pre> <pre><code>var getTemplateResponse = await trinsic.Template.GetAsync(new() { Id = template.Data.Id });\n</code></pre> <pre><code>get_template_response = await trinsic_service.template.get(\n    request=GetCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre> <pre><code>getResponse, err := trinsic.Template().Get(context.Background(), &amp;template.GetCredentialTemplateRequest{Id: templateResponse.Data.Id})\n</code></pre> <pre><code>var getResponse =\ntrinsic.template().get(GetCredentialTemplateRequest.newBuilder().setId(id).build()).get();\n</code></pre> <p>GetCredentialTemplateRequestRequest to fetch a template by IDid stringID of template to fetch</p> <p>GetCredentialTemplateResponseResponse to <code>GetCredentialTemplateRequest</code>template TemplateDataTemplate fetched by IDShow child attributestemplate.id stringTemplate IDtemplate.name stringTemplate nametemplate.version int32Template version numbertemplate.fields map(string -&gt; TemplateField)Fields defined for the templateShow child attributestemplate.fields[key].description stringHuman-readable description of the fieldtemplate.fields[key].optional boolWhether this field may be omitted when a credential is issued against the templatetemplate.fields[key].type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4FieldType.URI  = 5template.fields[key].annotations map(string -&gt; string)Annotations for the field that may be used to add additional informationtemplate.allow_additional_fields boolWhether credentials issued against this template may contain fields not defined by templatetemplate.schema_uri stringURI pointing to template JSON schema documenttemplate.context_uri stringURI pointing to template JSON-LD context documenttemplate.ecosystem_id stringID of ecosystem in which template residestemplate.type stringTemplate type (<code>VerifiableCredential</code>)template.created_by stringID of template creatortemplate.date_created stringDate when template was created as ISO 8601 utc string</p>"},{"location":"reference/services/template-service/#delete-template","title":"Delete Template","text":"<p>Deletes a credential template by <code>id</code>.</p>  Sample Request Response Trinsic CLIC#PythonGoJava <pre><code>trinsic tamplate delete --id &lt;TEMPLATE_ID&gt;\n</code></pre> <pre><code>var deleteTemplateResponse = await trinsic.Template.DeleteAsync(new() { Id = template.Data.Id });\n</code></pre> <pre><code>delete_template_response = await trinsic_service.template.delete(\n    request=DeleteCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre> <pre><code>deleteResponse, err := trinsic.Template().Delete(context.Background(), &amp;template.DeleteCredentialTemplateRequest{Id: templateResponse.Data.Id})\n</code></pre> <pre><code>var deleteResponse =\ntrinsic\n.template()\n.delete(DeleteCredentialTemplateRequest.newBuilder().setId(id).build())\n.get();\n</code></pre> <p>DeleteCredentialTemplateRequestRequest to delete a template by IDid stringID of template to delete</p> <p>DeleteCredentialTemplateResponseResponse to <code>DeleteCredentialTemplateRequest</code>This message has no fields</p>"},{"location":"reference/services/template-service/#search-templates","title":"Search Templates","text":"<p>Searches all templates defined in the current ecosystem, and a <code>continuation_token</code> to paginate large result sets.</p> <p>If no <code>query</code> is specified, this call by default returns the first 100 templates.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic wallet search \\\n--query \"SELECT * FROM c\"\n</code></pre> <pre><code>let searchTemplateResponse = await trinsic.template().search(\nSearchCredentialTemplatesRequest.fromPartial({\nquery: \"Select * from c\",\n})\n);\n</code></pre> <pre><code>var searchTemplateResponse = await trinsic.Template.SearchAsync(new() { Query = \"SELECT * FROM c\" });\n</code></pre> <pre><code>search_template_response = await trinsic_service.template.search(\n    request=SearchCredentialTemplatesRequest(query=\"SELECT * FROM c\")\n)\n</code></pre> <pre><code>searchResponse, err := trinsic.Template().Search(context.Background(), &amp;template.SearchCredentialTemplatesRequest{Query: \"SELECT * FROM c\"})\n</code></pre> <pre><code>var searchResponse =\ntrinsic\n.template()\n.search(\nSearchCredentialTemplatesRequest.newBuilder()\n.setQuery(\"SELECT * FROM c WHERE c.id = '\" + id + \"'\")\n.build())\n.get();\n</code></pre> <p>SearchCredentialTemplatesRequestRequest to search templates using a SQL queryquery stringSQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code>continuation_token optional stringToken provided by previous <code>SearchCredentialTemplatesResponse</code> if more data is available for query</p> <p>SearchCredentialTemplatesResponseResponse to <code>SearchCredentialTemplatesRequest</code>items_json stringRaw JSON data returned from queryhas_more boolWhether more results are available for this query via <code>continuation_token</code>continuation_token stringToken to fetch next set of results via <code>SearchCredentialTemplatesRequest</code></p>"},{"location":"reference/services/template-service/#advanced-search","title":"Advanced Search","text":"<p>The Search endpoint supports SQL queries through the <code>query</code> parameter.</p> <p>This allows for arbitrary query predicates, as well as more advanced functionality -- such as modifying the output format.</p>"},{"location":"reference/services/template-service/#schema","title":"Schema","text":"<p>Any table name may be used in your query (we use <code>c</code> here) -- it doesn't matter what it is.</p> Name Type Description id string Corresponds to the <code>id</code> returned when template was created type string Always <code>VerifiableCredential</code> ecosystemId string ID of ecosystem in which template resides createdBy string ID of account which defined the template name string Name provided during template creation schemaUri string HTTPS URL pointing to JSON Schema generated by Trinsic for this template contextUri string HTTPS URL pointing to JSON-LD Context generated by Trinsic for this template version int Version of template; increments whenever template is modified. fields object JSON Object representing the template's fields <p>Note that <code>fields</code> is an object, not a string; thus, any of its sub-fields may be queried against.</p> <p>More Info</p> <p>This endpoint works very similarly to querying Wallet items; please see Wallet Service &gt; Search for more information.</p>"},{"location":"reference/services/trust-registry-service/","title":"Trust Registry Service","text":"<p>The Trust Registry Service exposes functionality for managing Trust Registries -- lists of authorized issuers for the various credential types within an ecosystem.</p> <p>Under Construction</p> <p>This section -- and the underlying API -- is under active development.</p> <p>We are working to define exactly how Trust Registries will be implemented within our platform; this page and API may change as we do so.</p>"},{"location":"reference/services/trust-registry-service/#create-governance-framework","title":"Create Governance Framework","text":"<p>Creates a Governance Framework and attaches it to the current ecosystem.</p>  Sample Request Response Trinsic CLIC#PythonGoJava <pre><code>trinsic trust-registry register-efg\n</code></pre> <pre><code>var schemaUri = \"https://schema.org/Card\";\nvar frameworkUri = \"https://example.com\";\nvar registerFrameworkResponse = await trinsic.TrustRegistry.AddFrameworkAsync(new() {\nName = \"Demo framework\",\nDescription = \"My governance framework\",\nGovernanceFrameworkUri = frameworkUri\n});\n</code></pre> <pre><code>register_framework_response = await trinsic_service.trust_registry.add_framework(\n    request=AddFrameworkRequest(\n        governance_framework_uri=https_example_com,\n        description=\"Demo framework\",\n        name=framework_name,\n    )\n)\n</code></pre> <pre><code>newFramework, err := trinsic.TrustRegistry().AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\nGovernanceFrameworkUri: frameworkURI,\nName:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n})\n</code></pre> <pre><code>var frameworkResponse =\ntrinsic\n.trustRegistry()\n.addFramework(\nAddFrameworkRequest.newBuilder()\n.setGovernanceFrameworkUri(frameworkUri)\n.setName(\"Example Framework\" + UUID.randomUUID())\n.build())\n.get();\n</code></pre> <p>AddFrameworkRequestRequest to register a new ecosystem governance framework in the current ecosystemgovernance_framework_uri stringURI of governance framework organizationname stringName of governance framework organizationdescription stringDescription of governance framework</p> <p>AddFrameworkResponseResponse to <code>AddFrameworkRequest</code>id stringUnique framework identifiergoverning_authority stringDID URI of Trinsic account which created the governance frameworktrust_registry stringURN of trust registry for governance framework</p>"},{"location":"reference/services/trust-registry-service/#register-issuer","title":"Register Issuer","text":"<p>Registers an authorized issuer for a specific credential type (identified by its <code>schema_uri</code>).</p>  Sample Request Response Trinsic CLIC#PythonGoJava <pre><code>trinsic trust-registry register-issuer \\\n--egf http://hl7.org/fhir \\\n--credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n--did did:example:fabre\n</code></pre> <pre><code>var didUri = \"did:example:test\";\nvar registerMemberResponse = await trinsic.TrustRegistry.RegisterMemberAsync(new() {\nDidUri = didUri,\nFrameworkId = registerFrameworkResponse.Id,\nSchemaUri = schemaUri\n});\n</code></pre> <pre><code>await trinsic_service.trust_registry.register_member(\n    request=RegisterMemberRequest(\n        did_uri=did_example_test,\n        framework_id=register_framework_response.id,\n        schema_uri=https_schema_org,\n    )\n)\n</code></pre> <pre><code>registerMemberResponse, err := trinsic.TrustRegistry().RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\nFrameworkId: newFramework.Id,\nSchemaUri:   schemaURI,\nMember:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n})\n</code></pre> <pre><code>var memberResponse =\ntrinsic\n.trustRegistry()\n.registerMember(\nRegisterMemberRequest.newBuilder()\n.setDidUri(didUri)\n.setFrameworkId(frameworkResponse.getId())\n.setSchemaUri(typeUri)\n.build())\n.get();\n</code></pre> <p>RegisterMemberRequestRequest to register a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.did_uri stringDID URI of member to registerwallet_id stringTrinsic Wallet ID of member to registeremail stringEmail address of member to register. Must be associated with an existing Trinsic account.schema_uri stringURI of credential schema to register member as authorized issuer ofvalid_from_utc uint64Unix Timestamp member is valid from. Member will not be considered valid before this timestamp.valid_until_utc uint64Unix Timestamp member is valid until. Member will not be considered valid after this timestamp.framework_id stringID of the governance framework that member is being added to</p> <p>RegisterMemberResponseResponse to <code>RegisterMemberRequest</code>This message has no fields</p>"},{"location":"reference/services/trust-registry-service/#unregister-issuer","title":"Unregister Issuer","text":"<p>Unregisters an issuer for a specific credential type (identified by its <code>schema_uri</code>).</p>  Sample Request Response Trinsic CLIC#PythonGoJava <pre><code>trinsic trust-registry unregister-issuer \\\n--egf http://hl7.org/fhir \\\n--credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n--did did:example:fabre\n</code></pre> <pre><code>var unregisterResponse = await trinsic.TrustRegistry.UnregisterMemberAsync(new() {\nDidUri = didUri,\nFrameworkId = registerFrameworkResponse.Id,\nSchemaUri = schemaUri\n});\n</code></pre> <pre><code>unregister_issuer_response = await trinsic_service.trust_registry.unregister_member(\n    request=UnregisterMemberRequest(\n        framework_id=register_framework_response.id,\n        schema_uri=https_schema_org,\n        did_uri=did_example_test,\n    )\n)\n</code></pre> <pre><code>    unregisterMemberResponse, err := trinsic.TrustRegistry().UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\nSchemaUri:   schemaURI,\nFrameworkId: newFramework.Id,\n})\n\n\u22ef\n\n// Do absolutely nothing\n</code></pre> <pre><code>trinsic\n.trustRegistry()\n.unregisterMember(\nUnregisterMemberRequest.newBuilder()\n.setFrameworkId(frameworkResponse.getId())\n.setDidUri(didUri)\n.setSchemaUri(typeUri)\n.build());\n</code></pre> <p>UnregisterMemberRequestRequest to unregister a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.did_uri stringDID URI of member to unregisterwallet_id stringTrinsic Wallet ID of member to unregisteremail stringEmail address of member to unregister. Must be associated with an existing Trinsic account.schema_uri stringURI of credential schema to unregister member as authorized issuer offramework_id stringID of the governance framework that member is being removed from</p> <p>UnregisterMemberResponseResponse to <code>UnregisterMemberRequest</code>This message has no fields</p>"},{"location":"reference/services/trust-registry-service/#check-issuer-status","title":"Check Issuer Status","text":"<p>Check the status of an issuer for a specific credential type.</p>  Sample Request Response Trinsic CLIC#PythonGoJava <pre><code>trinsic trust-registry check-issuer \\\n--egf http://hl7.org/fhir \\\n--credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n--did did:example:fabre\n</code></pre> <pre><code>var issuerStatus = await trinsic.TrustRegistry.GetMembershipStatusAsync(new() {\nDidUri = didUri,\nGovernanceFrameworkUri = frameworkUri,\nSchemaUri = schemaUri\n});\n</code></pre> <pre><code>check_response = await trinsic_service.trust_registry.get_membership_status(\n    request=GetMembershipStatusRequest(\n        did_uri=did_example_test,\n        governance_framework_uri=https_example_com,\n        schema_uri=https_schema_org,\n    )\n)\n</code></pre> <pre><code>    getMembershipStatusResponse, err := trinsic.TrustRegistry().GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\nGovernanceFrameworkUri: frameworkURI,\nMember:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\nSchemaUri:              schemaURI,\n})\n\n\u22ef\n\n// Do absolutely nothing\n</code></pre> <pre><code>var issuerStatus =\ntrinsic\n.trustRegistry()\n.getMembershipStatus(\nGetMembershipStatusRequest.newBuilder()\n.setDidUri(didUri)\n.setGovernanceFrameworkUri(frameworkUri)\n.setSchemaUri(typeUri)\n.build())\n.get();\n</code></pre> <p>GetMembershipStatusRequestRequest to fetch membership status in governance framework for a specific credential schema. Only one of <code>did_uri</code>, <code>x509_cert</code> may be specified.governance_framework_uri stringURI of governance frameworkdid_uri stringDID URI of memberx509_cert stringX.509 certificate of memberschema_uri stringURI of credential schema associated with membership</p> <p>GetMembershipStatusResponseResponse to <code>GetMembershipStatusRequest</code>status RegistrationStatusStatus of member for given credential schemaShow enum valuesRegistrationStatus.CURRENT  = 0Member is currently authorized, as of the time of the queryRegistrationStatus.EXPIRED  = 1Member's authorization has expiredRegistrationStatus.TERMINATED  = 2Member has voluntarily ceased Issuer role under the specific EGFRegistrationStatus.REVOKED  = 3Member authority under specific EGF was terminated by the governing authorityRegistrationStatus.NOT_FOUND  = 10Member is not associated with given credential schema in the EGF</p>"},{"location":"reference/services/trust-registry-service/#search","title":"Search","text":"<p>Search the registry for registered issuers using a SQL query.</p>  Sample Request Response Trinsic CLIC#PythonGoJava <pre><code>trinsic trust-registry search --query &lt;SQL query&gt;\n</code></pre> <pre><code>var searchResult = await trinsic.TrustRegistry.SearchAsync(new());\n</code></pre> <pre><code>search_result = await trinsic_service.trust_registry.search()\n</code></pre> <pre><code>ecosystemList, err := trinsic.TrustRegistry().Search(context.Background(), nil)\n</code></pre> <pre><code>var searchResult = trinsic.trustRegistry().search().get();\n</code></pre> <p>SearchRegistryRequestRequest to search all governance frameworks within ecosystemquery stringSQL query to execute against frameworks. Example: <code>SELECT c from c where c.type == 'GovernanceFramework'</code>continuation_token optional stringToken to fetch next set of results, from previous <code>SearchRegistryResponse</code></p> <p>SearchRegistryResponseResponse to <code>SearchRegistryRequest</code>items_json stringJSON string containing array of resultant objectshas_more boolWhether more data is available to fetch for querycontinuation_token stringToken to fetch next set of results via <code>SearchRegistryRequest</code></p>"},{"location":"reference/services/trust-registry-service/#cache-offline-registry-file","title":"Cache Offline Registry File","text":"Trinsic CLI <pre><code>trinsic trust-registry download </code></pre>"},{"location":"reference/services/wallet-service/","title":"Wallet Service","text":"<p>The wallet service is the main interface for interacting with a cloud wallet. </p> <p>Wallets vs Accounts</p> <p>Wallets and accounts are related and often interchangeable -- each account has an associated wallet, and operations on a wallet are performed using an account's access token.</p> <p>Every account has exactly one wallet. </p> <p>Wallet Standard</p> <p>This service is designed to follow the recommendations of the Universal Wallet 2020  specification by the W3C Community Credentials Group.</p>"},{"location":"reference/services/wallet-service/#create-wallet","title":"Create Wallet","text":"<p>A wallet is created whenever an account is created.</p> <p>Therefore, to create a wallet, you'll need to create a new account.</p>"},{"location":"reference/services/wallet-service/#insert-item","title":"Insert Item","text":"<p>Stores a credential (or any other JSON object) in a wallet.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic wallet insert-item --item &lt;INPUT_JSON_FILE&gt;\n</code></pre> <pre><code>let insertItemResponse = await trinsic.wallet().insertItem(\nInsertItemRequest.fromPartial({\nitemJson: issueResponse.signedDocumentJson,\n})\n);\n</code></pre> <pre><code>var insertItemResponse = await trinsic.Wallet.InsertItemAsync(new() { ItemJson = credentialJson.DocumentJson });\n</code></pre> <pre><code>insert_response = await trinsic.wallet.insert_item(\n    request=InsertItemRequest(\n        item_json=credential, item_type=\"VerifiableCredential\"\n    )\n)\n</code></pre> <pre><code>insertResponse, err := trinsic.Wallet().InsertItem(context.Background(), &amp;wallet.InsertItemRequest{\nItemJson: credentialJson,\nItemType: \"VerifiableCredential\",\n})\n</code></pre> <pre><code>var insertResponse =\ntrinsic\n.wallet()\n.insertItem(\nInsertItemRequest.newBuilder()\n.setItemJson(credentialJson)\n.setItemType(\"VerifiableCredential\")\n.build())\n.get();\n</code></pre> <p>InsertItemRequestRequest to insert a JSON document into a walletitem_json stringDocument to insert; must be stringified JSONitem_type optional stringItem type (ex. \"VerifiableCredential\")</p> <p>InsertItemResponseResponse to <code>InsertItemRequest</code>item_id stringID of item inserted into wallet</p> <p>What can be stored in a wallet?</p> <p>Wallets are mainly intended to hold Verifiable Credentials, but can technically store any JSON blob.</p> <p>If you store a Verifiable Credential in a Wallet, ensure that its <code>item_type</code> is <code>VerifiableCredential</code>.</p> <p>Otherwise, ensure its <code>item_type</code> is not <code>VerifiableCredential</code>.</p>"},{"location":"reference/services/wallet-service/#search-wallet","title":"Search Wallet","text":"<p>Searches a wallet, returning all matching items, and a <code>continuation_token</code> to paginate large result sets.</p> <p>If no <code>query</code> is specified, this call by default returns the first 100 items in the wallet.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic wallet search\n</code></pre> <pre><code>let items = await trinsic.wallet().searchWallet();\n</code></pre> <pre><code>var walletItems = await trinsic.Wallet.SearchWalletAsync(new());\n</code></pre> <pre><code>wallet_items = await trinsic.wallet.search_wallet()\n</code></pre> <pre><code>searchResponse, err := trinsic.Wallet().SearchWallet(context.Background(), &amp;wallet.SearchRequest{})\n</code></pre> <pre><code>var walletItems = trinsic.wallet().searchWallet().get();\n</code></pre> <p>SearchRequestRequest to search items in walletquery stringSQL Query to execute against items in walletcontinuation_token optional stringToken provided by previous <code>SearchResponse</code> if more data is available for query</p> <p>SearchResponseResponse to <code>SearchRequest</code>items string[]Array of query results, as JSON stringshas_more boolWhether more results are available for this query via <code>continuation_token</code>continuation_token stringToken to fetch next set of results via <code>SearchRequest</code></p> <p>Verifiable Presentation Request Spec</p> <p>In the future, this endpoint will support the Verifiable Presentation Request Spec .</p>"},{"location":"reference/services/wallet-service/#advanced-search","title":"Advanced Search","text":"<p>The Search endpoint supports SQL queries through the <code>query</code> parameter.</p> <p>This allows for arbitrary query predicates, as well as more advanced functionality -- such as modifying the output format.</p>"},{"location":"reference/services/wallet-service/#schema","title":"Schema","text":"<p>Any table name may be used in your query (we use <code>c</code> here) -- it doesn't matter what it is.</p> Name Type Description id string Corresponds to the <code>item_id</code> returned when item was inserted into wallet type string Specified via <code>item_type</code> when item was inserted into wallet data object The JSON object passed via <code>item_json</code> when item was inserted into wallet <p>Note that <code>data</code> is an object, not a string; thus, any of its sub-fields may be queried against.</p> <p>For example, <code>SELECT * FROM c WHERE c.data.someField = 'Hello, World!'</code> would match against the following JSON object inserted via InsertItem:</p> <pre><code>{ \"someField\": \"Hello, World!\"\n}\n</code></pre>"},{"location":"reference/services/wallet-service/#common-sql-queries","title":"Common SQL Queries","text":""},{"location":"reference/services/wallet-service/#paging","title":"Paging","text":"<p>Paging uses the <code>OFFSET</code> clause that takes in a value indicating how many records should be skipped in the returned query. To specify the size of the result set (page size) use the <code>LIMIT</code> clause.</p> <pre><code>SELECT * FROM c OFFSET 10 LIMIT 5\n</code></pre>"},{"location":"reference/services/wallet-service/#sorting","title":"Sorting","text":"<p>The optional <code>ORDER BY</code> clause specifies the sorting order for results returned by the query. To control sorting order, specify <code>ASC</code> or <code>DESC</code> at the end; if not specified ascending order is used by default.</p> <pre><code>SELECT * FROM c ORDER BY c.credential.issued DESC\n</code></pre>"},{"location":"reference/services/wallet-service/#filtering","title":"Filtering","text":"<p>The optional WHERE clause (<code>WHERE &lt;filter_condition&gt;</code>) specifies condition(s) that the source JSON items must satisfy for the query to include them in results. A JSON item must evaluate the specified conditions to true to be considered for the result. The index layer uses the <code>WHERE</code> clause to determine the smallest subset of source items that can be part of the result.</p> <pre><code>SELECT * FROM c WHERE c.name = 'Trinsic' AND c.dateCreated &gt;= \"2020-09-30T23:14:25.7251173Z\"\n</code></pre>"},{"location":"reference/services/wallet-service/#grouping","title":"Grouping","text":"<p>The <code>GROUP BY</code> clause divides the query's results according to the values of one or more specified properties. Examples and detailed description on working with grouped results can be found here </p>"},{"location":"reference/services/wallet-service/#additional-resources","title":"Additional Resources","text":"<p>You can read the full documentation on working with SQL queries on the Azure Cosmos DB website .</p>"},{"location":"ruby/","title":"The Trinsic Ruby SDK","text":"<p>The Trinsic Ruby SDK makes it easy to interact with the Trinsic API from any Ruby application. The most recent version of the library can be found on RubyGems. You can find the SDKs source on Github.</p>"},{"location":"ruby/#installation-and-configuration","title":"Installation and Configuration","text":"<ul> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>RUBY_DLL_PATH</code> on windows. <code>LD_LIBRARY_PATH</code> for Ruby on Mac/Linux <pre><code>gem install trinsic-services\n</code></pre></li> <li>Test installation by running the following Ruby script: <pre><code>require 'trinsic_services'\n\naccount_service = Trinsic::AccountService.new(nil, Trinsic::trinsic_prod_server)\naccount_profile = account_service.sign_in(nil).profile\nputs account_profile\n</code></pre></li> <li>Output should look something like this: <pre><code>&lt;Services::Account::V1::AccountProfile: profile_type: \"https://trinsic.id/security/v1/oberon\", auth_data: \")urn:trinsic:wallets:bbBEp9EmV1NNWMadBhit2$19ac25ae-2fd0-44d1-9ef7-73cc668e8f7d\", auth_token: \"\u2592\", protection: &lt;Services::Account::V1::TokenProtection: enabled: false, method: :None&gt;&gt;\n</code></pre></li> </ul>"},{"location":"ruby/#next-steps","title":"Next Steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API </p>"},{"location":"walkthroughs/vaccination/","title":"Walkthrough: Build a Vaccine Card","text":"<p>This walkthrough demonstrates how a vaccination card can be issued, held, and shared using Verifiable Credentials with Trinsic.</p>"},{"location":"walkthroughs/vaccination/#meet-allison","title":"Meet Allison","text":"<p>We'll follow Allison as she obtains a vaccine certificate, stores it in her digital wallet, and presents it to board an airplane.</p> <p>In most credential exchange scenarios, there are three primary roles: Issuer, Holder, and Verifier.</p> <p>Holder: Stores credentials received from issuers, and presents them to verifiers. (Said credentials are often, but not always, attesting information about the holder)</p> <p>Issuer: Signs and issues credentials which attest information about a credential subject.</p> <p>Verifier: Verifies credentials presented by holders.</p> <p>In this case, Allison will be the holder, a vaccination clinic will be the issuer, and an airline will be the verifier. </p>"},{"location":"walkthroughs/vaccination/#our-sdks","title":"Our SDKs","text":"<p>You can follow along using one of our SDKs, or use the Trinsic CLI, which implements full platform functionality.</p> Trinsic CLITypescriptC#PythonJavaGoRuby <p>Click here for installation instructions for the Trinsic CLI.</p> <p>Click here for installation instructions for the Node/Browser SDK.</p> <p>Click here for installation instructions for the .NET SDK.</p> <p>Click here for installation instructions for the Python SDK.</p> <p>Click here for installation instructions for the Java SDK.</p> <p>Click here for installation instructions for the Go SDK.</p> <p>Click here for installation instructions for the Ruby SDK.</p>"},{"location":"walkthroughs/vaccination/#ecosystem-setup","title":"Ecosystem Setup","text":"<p>Before we begin, you'll need an ecosystem -- somewhere for the resources we're about to create (wallets, templates, credentials) to live.</p>"},{"location":"walkthroughs/vaccination/#use-existing-ecosystem","title":"Use Existing Ecosystem","text":"<p>If you've already signed up as a customer, you'll have received an email with an ecosystem ID and authentication token.</p> <p>Copy this ecosystem ID down, and skip to the next step.</p>"},{"location":"walkthroughs/vaccination/#create-new-ecosystem","title":"Create New Ecosystem","text":"<p>If you don't already have an ecosystem provisioned for you, you'll need to create one first. </p> <p>This will be a sandbox ecosystem; suitable for prototyping and testing, but not production purposes. To receive a production ecosystem, sign up.</p> Trinsic CLITypescriptC#PythonJavaGoRuby <pre><code>trinsic provider create-ecosystem\n</code></pre> <pre><code>const ecosystem = await trinsic\n.provider()\n.createEcosystem(CreateEcosystemRequest.fromPartial({}));\nconst ecosystemId = ecosystem.ecosystem!.id;\n</code></pre> <pre><code>var trinsic = new TrinsicService(_options);\n\nvar (ecosystem, authToken) = await trinsic.Provider.CreateEcosystemAsync(new());\nvar ecosystemId = ecosystem?.Id;\n</code></pre> <pre><code>ecosystem = await trinsic_service.provider.create_ecosystem()\necosystem_id = ecosystem.ecosystem.id\n</code></pre> <pre><code>var ecosystemResponse =\ntrinsic.provider().createEcosystem(CreateEcosystemRequest.getDefaultInstance()).get();\n\nvar ecosystemId = ecosystemResponse.getEcosystem().getId();\n</code></pre> <pre><code>ecosystem, _ := trinsic.Provider().CreateEcosystem(context.Background(), nil)\necosystemId := ecosystem.Ecosystem.Id\n</code></pre> <pre><code>ecosystem = trinsic.provider_service.create_ecosystem\necosystem_id = ecosystem.ecosystem.id\n</code></pre> <p>The response to this call contains the name and ID of your newly-created ecosystem; copy either of these down.</p> <p>Further Reading: Ecosystems</p> <ul> <li>Learn more about Ecosystems</li> <li>Browse the Provider API reference</li> </ul>"},{"location":"walkthroughs/vaccination/#create-accounts","title":"Create Accounts","text":"<p>We need to create Trinsic accounts for the participants in this credential exchange. Accounts and wallets can be considered interchangeably; all accounts have exactly one associated wallet.</p> <p>Accounts can be created with a single call; they're designed to minimize onboarding friction for your users.</p> <p>The clinic's account will issue the credential, Allison's account will hold it, and the airline's account will verify its contents.</p> Trinsic CLITypescriptC#PythonJavaGoRuby <p>The CLI makes it easy to create wallets. For demo purposes, we'll create all three on the same machine.</p> <p>When using the CLI, the authentication token of the most recently used account is saved in <code>~/.trinsic</code>. In a real-world scenario, you should back this token up securely.</p> <pre><code>trinsic account login --ecosystem {ECOSYSTEM_ID}\n# Save auth token in `allison.txt` before continuing\n\ntrinsic account login --ecosystem {ECOSYSTEM_ID}\n# Save auth token in `airline.txt` before continuing\n\ntrinsic account login --ecosystem {ECOSYSTEM_ID}\n# Save auth token in `clinic.txt` before continuing\n</code></pre> <pre><code>// Create 3 different profiles for each participant in the scenario\nconst allison = await trinsic.account().loginAnonymous(ecosystemId);\nconst clinic = await trinsic.account().loginAnonymous(ecosystemId);\nconst airline = await trinsic.account().loginAnonymous(ecosystemId);\n</code></pre> <p>If you would like to save the account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p> <pre><code>var allison = await trinsic.Account.LoginAnonymousAsync(ecosystemId!);\nvar clinic = await trinsic.Account.LoginAnonymousAsync(ecosystemId!);\nvar airline = await trinsic.Account.LoginAnonymousAsync(ecosystemId!);\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p> <pre><code># Create an account for each participant in the scenario\nallison = await trinsic_service.account.login_anonymous(ecosystem_id=ecosystem_id)\nairline = await trinsic_service.account.login_anonymous(ecosystem_id=ecosystem_id)\nclinic = await trinsic_service.account.login_anonymous(ecosystem_id=ecosystem_id)\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p> <pre><code>// Create an account for each participant in the scenario\nvar allison = trinsic.account().loginAnonymous(ecosystemId).get();\nvar clinic = trinsic.account().loginAnonymous(ecosystemId).get();\nvar airline = trinsic.account().loginAnonymous(ecosystemId).get();\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p> <pre><code>// Create an account for each participant in the scenario\nallison, _ := trinsic.Account().LoginAnonymous(context.Background(), ecosystemId)\nairline, _ := trinsic.Account().LoginAnonymous(context.Background(), ecosystemId)\nclinic, _ := trinsic.Account().LoginAnonymous(context.Background(), ecosystemId)\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p> <pre><code># Create an account for each participant in the scenario\nallison = trinsic.account_service.login_anonymous(ecosystem_id)\nclinic = trinsic.account_service.login_anonymous(ecosystem_id)\nairline = trinsic.account_service.login_anonymous(ecosystem_id)\n</code></pre> <p>Production Usage</p> <p>In this example, we've created anonymous accounts; the only way to access them is by saving the authentication token generated on account creation.</p> <p>In a production scenario, you may want to create accounts tied to a user's email address or phone number. This allows users to securely access their Trinsic cloud wallets at any time.</p> <p>Note that accounts are tied to their ecosystem. If you create an account tied to <code>bob@example.com</code> in the <code>example1</code> ecosystem, it will not be visible in any other ecosystem. The same email address can be used to create accounts in multiple ecosystems.</p> <p>Further Reading: Accounts and Wallets</p> <ul> <li>Learn more about Wallets</li> <li>Browse the Account API reference</li> <li>Read about authentication tokens and security</li> </ul>"},{"location":"walkthroughs/vaccination/#define-a-template","title":"Define a Template","text":"<p>Before we can issue a credential, we need to create a Template for it. </p> <p>Templates are simply a list of the fields that a credential can have.</p> Trinsic CLITypescriptC#PythonJavaGoRuby <p>First, prepare a JSON file which describes your template:</p> templateData.json <pre><code>{\n\"firstName\": {\n\"type\": \"string\",\n\"description\": \"First name of vaccine recipient\"\n},\n\"lastName\": {\n\"type\": \"string\",\n\"description\": \"Last name of vaccine recipient\"\n},\n\"batchNumber\":{\n\"type\": \"string\",\n\"description\": \"Batch number of vaccine\"\n},\n\"countryOfVaccination\":{\n\"type\": \"string\",\n\"description\": \"Country in which the subject was vaccinated\"\n}\n}\n</code></pre> <p>Then create the template:</p> <pre><code>trinsic template create -n \"VaccinationCertificate\" --fields-file templateData.json </code></pre> <p>The output of this command will include a template ID; copy this down for later use.</p> <pre><code>//Define all fields\nconst firstNameField = TemplateField.fromPartial({\ndescription: \"First name of vaccine recipient\",\ntype: FieldType.STRING,\n});\n\nconst lastNameField = TemplateField.fromPartial({\ntype: FieldType.STRING,\ndescription: \"Last name of vaccine recipient\",\n});\n\nconst batchNumberField = TemplateField.fromPartial({\ntype: FieldType.STRING,\ndescription: \"Batch number of vaccine\",\n});\n\nconst countryOfVaccinationField = TemplateField.fromPartial({\ntype: FieldType.STRING,\ndescription: \"Country in which the subject was vaccinated\",\n});\n\n//Create request\nlet request = CreateCredentialTemplateRequest.fromPartial({\nname: `VaccinationCertificate-${uuid()}`,\nfields: {\nfirstName: firstNameField,\nlastName: lastNameField,\nbatchNumber: batchNumberField,\ncountryOfVaccination: countryOfVaccinationField,\n},\n});\n\n//Create template\nconst response = await trinsicService.template().create(request);\nconst template = response.data;\n</code></pre> <pre><code>// Set active profile to `clinic` so we can create a template\ntrinsic.SetAuthToken(clinic!);\n\n// Prepare request to create template\nCreateCredentialTemplateRequest templateRequest = new() {\nName = \"VaccinationCertificate\",\nAllowAdditionalFields = false\n};\n\ntemplateRequest.Fields.Add(\"firstName\", new() { Description = \"First name of vaccine recipient\" });\ntemplateRequest.Fields.Add(\"lastName\", new() { Description = \"Last name of vaccine recipient\" });\ntemplateRequest.Fields.Add(\"batchNumber\", new() { Description = \"Batch number of vaccine\", Type = FieldType.String });\ntemplateRequest.Fields.Add(\"countryOfVaccination\", new() { Description = \"Country in which the subject was vaccinated\" });\n\n// Create template\nvar template = await trinsic.Template.CreateAsync(templateRequest);\nvar templateId = template?.Data?.Id;\n</code></pre> <pre><code>template = await trinsic_service.template.create(\n    request=CreateCredentialTemplateRequest(\n        name=f\"VaccinationCertificate-{uuid.uuid4()}\",\n        allow_additional_fields=False,\n        fields={\n            \"firstName\": TemplateField(\n                description=\"First name of vaccine recipient\"\n            ),\n            \"lastName\": TemplateField(description=\"Last name of vaccine recipient\"),\n            \"batchNumber\": TemplateField(\n                description=\"Batch number of vaccine\", type=FieldType.STRING\n            ),\n            \"countryOfVaccination\": TemplateField(\n                description=\"Country in which the subject was vaccinated\"\n            ),\n        },\n    )\n)\n\ntemplate_id = template.data.id\n</code></pre> <pre><code>// Set active profile to 'clinic'\ntemplateService.setAuthToken(clinic);\n\n// Define fields for template\nvar fields = new HashMap&lt;String, TemplateField&gt;();\nfields.put(\n\"firstName\",\nTemplateField.newBuilder().setDescription(\"First name of vaccine recipient\").build());\nfields.put(\n\"lastName\",\nTemplateField.newBuilder().setDescription(\"Last name of vaccine recipient\").build());\nfields.put(\n\"batchNumber\",\nTemplateField.newBuilder()\n.setType(FieldType.STRING)\n.setDescription(\"Batch number of vaccine\")\n.build());\nfields.put(\n\"countryOfVaccination\",\nTemplateField.newBuilder()\n.setDescription(\"Country in which the subject was vaccinated\")\n.build());\n\n// Create template request\nvar templateRequest =\nCreateCredentialTemplateRequest.newBuilder()\n.setName(\"VaccinationCertificate\")\n.setAllowAdditionalFields(false)\n.putAllFields(fields)\n.build();\n\n// Execute template creation\nvar template = templateService.create(templateRequest).get();\nvar templateId = template.getData().getId();\n</code></pre> <pre><code>templateRequest := &amp;template.CreateCredentialTemplateRequest{Name: \"VaccinationCertificate\", AllowAdditionalFields: false, Fields: make(map[string]*template.TemplateField)}\ntemplateRequest.Fields[\"firstName\"] = &amp;template.TemplateField{Description: \"First name of vaccine recipient\"}\ntemplateRequest.Fields[\"lastName\"] = &amp;template.TemplateField{Description: \"Last name of vaccine recipient\"}\ntemplateRequest.Fields[\"batchNumber\"] = &amp;template.TemplateField{Description: \"Batch number of vaccine\", Type: template.FieldType_STRING}\ntemplateRequest.Fields[\"countryOfVaccination\"] = &amp;template.TemplateField{Description: \"Country in which the subject was vaccinated\"}\n\ncreatedTemplate, _ := trinsic.Template().Create(context.Background(), templateRequest)\n\ntemplateId := createdTemplate.Data.Id\n</code></pre> <pre><code>request = Trinsic::Template::CreateCredentialTemplateRequest.new(name: \"VaccinationCertificate-#{SecureRandom.uuid}\",\nallow_additional_fields: false)\nrequest.fields['firstName'] = Trinsic::Template::TemplateField.new(description: 'First name of vaccine recipient')\nrequest.fields['lastName'] = Trinsic::Template::TemplateField.new(description: 'Last name of vaccine recipient')\nrequest.fields['batchNumber'] =\nTrinsic::Template::TemplateField.new(description: 'Batch number of vaccine',\ntype: Trinsic::Template::FieldType::STRING)\nrequest.fields['countryOfVaccination'] =\nTrinsic::Template::TemplateField.new(description: 'Country in which the subject was vaccinated')\n\ntemplate = trinsic.template_service.create(request)\ntemplate_id = template.data.id\n</code></pre> <p>Templates are Optional</p> <p>Templates are an optional helpful abstraction which removes the need to work directly with complex data formats such as JSON-LD.</p> <p>When a template is used to issue a credential, the result is a valid, interoperable JSON-LD Verifiable Credential.</p> <p>Trinsic's SDKs support issuing JSON-LD credentials that you create yourself, should you choose not to use templates.</p> <p>Further Reading: Templates</p> <ul> <li>Learn more about Templates</li> <li>Browse the Template API reference</li> </ul>"},{"location":"walkthroughs/vaccination/#issue-a-credential","title":"Issue a Credential","text":"<p>Upon receiving her vaccine, the clinic issues Allison a Verifiable Credential, which proves that she was given the vaccine by the clinic.</p> <p>A credential is a JSON document that has been cryptographically signed; this signature enables verifiers to trust that the data comes a trusted source, and has not been tampered with.</p> <p>To issue a vaccine certificate, we'll use the template we created in the last step.</p> Trinsic CLITypescriptC#PythonJavaGoRuby <p>First, prepare a file named <code>values.json</code> with the following content:</p> values.json <pre><code>{\n\"firstName\": \"Allison\",\n\"lastName\": \"Allisonne\",\n\"batchNumber\": \"123454321\",\n\"countryOfVaccination\": \"US\"\n}\n</code></pre> <p>Then issue the credential:</p> <pre><code>trinsic config --auth-token $(cat clinic.txt)\ntrinsic vc issue-from-template --template-id {TEMPLATE_ID} --values-file values.json --out credential.json\n</code></pre> <p>The output of this command will contain a signed JSON document, which has been saved to <code>credential.json</code>.</p> <p>Note that TEMPLATE_ID refers to the \"Schema\" URI of the template you created earlier called \"VaccinationCertificate\".  More specifically, it's the property 'schema_uri' in the JSON returned by the <code>trinsic template create...</code> command.</p> <pre><code>// Prepare the credential values JSON document\nconst credentialValues = JSON.stringify({\nfirstName: \"Allison\",\nlastName: \"Allisonne\",\nbatchNumber: \"123454321\",\ncountryOfVaccination: \"US\",\n});\n\n// Sign a credential as the clinic and send it to Allison\ntrinsic.options.authToken = clinic;\nconst issueResponse = await trinsic.credential().issueFromTemplate(\nIssueFromTemplateRequest.fromPartial({\ntemplateId: template.id,\nvaluesJson: credentialValues,\n})\n);\n</code></pre> <pre><code>// Prepare credential values\nvar credentialValues = new Dictionary&lt;string, string&gt;() {\n{ \"firstName\", \"Allison\" },\n{ \"lastName\", \"Allisonne\" },\n{ \"batchNumber\", \"123454321\" },\n{ \"countryOfVaccination\", \"US\" }\n};\n\n// Issue credential as clinic\nvar issueResponse = await trinsic.Credential.IssueFromTemplateAsync(new() {\nTemplateId = templateId,\nValuesJson = JsonSerializer.Serialize(credentialValues)\n});\n\nvar signedCredential = issueResponse?.DocumentJson;\n</code></pre> <pre><code># Prepare values for credential\nvalues = json.dumps(\n    {\n        \"firstName\": \"Allison\",\n        \"lastName\": \"Allisonne\",\n        \"batchNumber\": \"123454321\",\n        \"countryOfVaccination\": \"US\",\n    }\n)\n\n# Issue credential\nissue_response = await trinsic_service.credential.issue_from_template(\n    request=IssueFromTemplateRequest(template_id=template.id, values_json=values)\n)\n\ncredential = issue_response.document_json\n</code></pre> <pre><code>// Set active profile to 'clinic' so we can issue credential signed\n// with the clinic's signing keys\ntrinsicService.setAuthToken(clinic);\n\n// Prepare credential values\nvar valuesMap = new HashMap&lt;String, Object&gt;();\nvaluesMap.put(\"firstName\", \"Allison\");\nvaluesMap.put(\"lastName\", \"Allissonne\");\nvaluesMap.put(\"batchNumber\", \"123454321\");\nvaluesMap.put(\"countryOfVaccination\", \"US\");\n\n// Serialize values to JSON\nvar valuesJson = new Gson().toJson(valuesMap);\n\n// Issue credential\nvar issueResponse =\ntrinsicService\n.credential()\n.issueFromTemplate(\nIssueFromTemplateRequest.newBuilder()\n.setTemplateId(templateId)\n.setValuesJson(valuesJson)\n.build())\n.get();\n\nvar credential = issueResponse.getDocumentJson();\n</code></pre> <pre><code>// Prepare values for credential\nvaluesStruct := struct {\nFirstName            string\nLastName             string\nbatchNumber          string\ncountryOfVaccination string\n}{\nFirstName:            \"Allison\",\nLastName:             \"Allisonne\",\nbatchNumber:          \"123454321\",\ncountryOfVaccination: \"US\",\n}\nvalues, _ := json.Marshal(valuesStruct)\n\n// Issue credential\nissueResponse, _ := trinsic.Credential().IssueFromTemplate(context.Background(), &amp;credential.IssueFromTemplateRequest{\nTemplateId: createdTemplate.Id,\nValuesJson: string(values),\n})\n\nissuedCredential := issueResponse.DocumentJson\n</code></pre> <pre><code># Prepares values for credential\nvalues = JSON.generate({ firstName: 'Allison', lastName: 'Allisonne', batchNumber: '123454321',\ncountryOfVaccination: 'US' })\n\n# Issue credential\nissue_response = trinsic.credential_service.issue_from_template(Trinsic::Credentials::IssueFromTemplateRequest.new(\ntemplate_id: template.id, values_json: values\n))\ncredential = issue_response.document_json\n</code></pre> <p>Further Reading: Issuance and Credentials</p> <ul> <li>Learn more about Verifiable Credentials</li> <li>Browse the Credential API reference</li> </ul>"},{"location":"walkthroughs/vaccination/#send-credential-to-allison","title":"Send Credential to Allison","text":"<p>Now that the clinic has a signed credential, it must be securely transmitted to Allison, so she can store it in her wallet.</p> <p>Because it's just a JSON string, it could be delivered in many ways -- for example, in the response to an HTTPS request which triggered the issuance process.</p> <p>Send via Trinsic</p> <p>In the future, we will offer the ability to send a credential directly to a Trinsic user's wallet.</p> <p>Click here to learn more about this feature.</p>"},{"location":"walkthroughs/vaccination/#store-credential-in-wallet","title":"Store Credential in Wallet","text":"<p>Once Allison receives the credential, it must be stored in her wallet.</p> Trinsic CLITypescriptC#PythonJavaGoRuby <pre><code>trinsic config --auth-token $(cat allison.txt)\ntrinsic wallet insert-item --item credential.json\n</code></pre> <pre><code>// Alice stores the credential in her cloud wallet.\ntrinsic.options.authToken = allison;\nconst insertResponse = await trinsic.wallet().insertItem(\nInsertItemRequest.fromPartial({\nitemJson: issueResponse.documentJson,\n})\n);\n</code></pre> <pre><code>// Set active profile to 'allison' so we can manage her cloud wallet\ntrinsic.SetAuthToken(allison!);\n\n// Insert credential into Allison's wallet\nvar insertItemResponse = await trinsic.Wallet.InsertItemAsync(new() {\nItemJson = signedCredential\n});\n\nvar itemId = insertItemResponse?.ItemId;\n</code></pre> <pre><code># Allison stores the credential in her cloud wallet\ntrinsic_service.service_options.auth_token = allison\n\ninsert_response = await trinsic_service.wallet.insert_item(\n    request=InsertItemRequest(item_json=credential)\n)\n\nitem_id = insert_response.item_id\n</code></pre> <pre><code>// Set active profile to 'allison' so we can manage her cloud wallet\ntrinsic.setAuthToken(allison);\n\n// Allison stores the credential in her cloud wallet.\nvar insertItemResponse =\ntrinsic\n.wallet()\n.insertItem(InsertItemRequest.newBuilder().setItemJson(credential).build())\n.get();\n\nfinal var itemId = insertItemResponse.getItemId();\n</code></pre> <pre><code>// Allison stores the credential in her cloud wallet\ntrinsic.SetAuthToken(allison)\ninsertResponse, _ := trinsic.Wallet().InsertItem(context.Background(), &amp;wallet.InsertItemRequest{ItemJson: issuedCredential})\n\nitemId := insertResponse.ItemId\n</code></pre> <pre><code># Allison stores the credential in her cloud wallet\ntrinsic.auth_token = allison\ninsert_response = trinsic.wallet_service.insert_item(Trinsic::Wallet::InsertItemRequest.new(item_json: credential))\nitem_id = insert_response.item_id\n</code></pre> <p>The response to this call contains an Item ID; copy this down.</p> <p>Further Reading: Wallets</p> <ul> <li>Learn more about Wallets</li> <li>Browse the Wallet API reference</li> </ul>"},{"location":"walkthroughs/vaccination/#create-a-proof-of-vaccination","title":"Create a Proof of Vaccination","text":"<p>Before boarding, the airline requests proof of vaccination from Allison. Specifically, they want to see proof that she holds a <code>VaccinationCertificate</code> credential.</p> <p>Let's use the CreateProof call to build a proof for Allison's held credential.</p> Trinsic CLITypescriptC#PythonJavaGoRuby <pre><code>trinsic config --auth-token $(cat allison.txt)\ntrinsic vc create-proof --item-id \"{ITEM_ID}\" --out proof.json\n</code></pre> <pre><code>// Allison shares the credential with the venue.\ntrinsic.options.authToken = allison;\nconst proofResponse = await trinsic.credential().createProof(\nCreateProofRequest.fromPartial({\nitemId: insertResponse.itemId,\n})\n);\n</code></pre> <pre><code>// Build a proof for the signed credential as allison\nvar proofResponse = await trinsic.Credential.CreateProofAsync(new() {\nItemId = itemId\n});\n\nvar proofJSON = proofResponse?.ProofDocumentJson;\n</code></pre> <pre><code># Allison shares the credential with the airline\ntrinsic_service.service_options.auth_token = allison\n\nproof_response = await trinsic_service.credential.create_proof(\n    request=CreateProofRequest(item_id=item_id)\n)\n\ncredential_proof = proof_response.proof_document_json\n</code></pre> <pre><code>// Set active profile to 'allison' so we can create a proof using her key\ntrinsic.setAuthToken(allison);\n\n// Allison shares the credential with the venue\nvar createProofResponse =\ntrinsic\n.credential()\n.createProof(CreateProofRequest.newBuilder().setItemId(itemId).build())\n.get();\n\nvar credentialProof = createProofResponse.getProofDocumentJson();\n</code></pre> <pre><code>// Allison shares the credential with the airline\ntrinsic.SetAuthToken(allison)\nproofResponse, _ := trinsic.Credential().CreateProof(context.Background(), &amp;credential.CreateProofRequest{\nProof: &amp;credential.CreateProofRequest_ItemId{ItemId: itemId},\n})\n\ncredentialProof := proofResponse.ProofDocumentJson\n</code></pre> <pre><code># Allison shares the credential with the airline\ntrinsic.auth_token = allison\nproof_response = trinsic.credential_service.create_proof(Trinsic::Credentials::CreateProofRequest.new(item_id: item_id))\ncredential_proof = proof_response.proof_document_json\n</code></pre> <p>Allison sends this proof to the airline for them to verify.</p> <p>Partial Proofs</p> <p>In this example, the proof is being created over the entire credential; all of its fields are revealed to the verifier.</p> <p>It is possible for the airline to send Allison a frame which requests only certain fields of the credential. The airline would not be able to see other fields of the credential, but cryptographic guarantees would still hold over the revealed fields.</p> <p>See the CreateProof reference for more information.</p> <p>OpenID Connect for Presentation</p> <p>Trinsic offers an OpenID Connect service as an alternative flow for the exchange of a credential between a holder and a verifier.</p> <p>In this flow, a holder simply clicks a link (or scans a QR code), logs into their Trinsic cloud wallet, and selects a credential to share. </p>"},{"location":"walkthroughs/vaccination/#verify-proof","title":"Verify Proof","text":"<p>Once the airline receives the proof, they can use the VerifyProof call to ensure its authenticity.</p> Trinsic CLITypescriptC#PythonJavaGoRuby <pre><code>trinsic config --auth-token $(cat airline.txt)\ntrinsic vc verify-proof --proof-document proof.json\n</code></pre> <pre><code>// The airline verifies the credential\ntrinsic.options.authToken = airline;\nconst verifyResponse = await trinsic.credential().verifyProof(\nVerifyProofRequest.fromPartial({\nproofDocumentJson: proofResponse.proofDocumentJson,\n})\n);\n</code></pre> <pre><code>// Set active profile to `airline`\ntrinsic.SetAuthToken(airline!);\n\n// Verify that Allison has provided a valid proof\nvar verifyResponse = await trinsic.Credential.VerifyProofAsync(new() {\nProofDocumentJson = proofJSON\n});\n\nbool credentialValid = verifyResponse?.IsValid ?? false;\n</code></pre> <pre><code># The airline verifies the credential\ntrinsic_service.service_options.auth_token = airline\n\nverify_result = await trinsic_service.credential.verify_proof(\n    request=VerifyProofRequest(proof_document_json=credential_proof)\n)\n\nvalid = verify_result.is_valid\n</code></pre> <pre><code>trinsic.setAuthToken(airline);\n\n// Verify that Allison has provided a valid proof\nvar verifyProofResponse =\ntrinsic\n.credential()\n.verifyProof(\nVerifyProofRequest.newBuilder().setProofDocumentJson(credentialProof).build())\n.get();\n\nboolean isValid = verifyProofResponse.getIsValid();\n</code></pre> <pre><code>// The airline verifies the credential\ntrinsic.SetAuthToken(airline)\nverifyResult, _ := trinsic.Credential().VerifyProof(context.Background(), &amp;credential.VerifyProofRequest{ProofDocumentJson: credentialProof})\nvalid := verifyResult.IsValid\n</code></pre> <pre><code># The airline verifies the credential\ntrinsic.auth_token = airline\n\nverify_result = trinsic.credential_service.verify_proof(\nTrinsic::Credentials::VerifyProofRequest.new(proof_document_json: credential_proof)\n)\n\nvalid = verify_result.is_valid\n</code></pre> <p>Interoperability</p> <p>The Verifiable Credentials and Proofs that Trinsic's platform produces are based on open standards.</p> <p>Although we use the VerifyProof call in this example, the proof could be verified using any standards-compliant software.</p>"},{"location":"walkthroughs/vaccination/#full-source-code","title":"Full Source Code","text":"TypescriptC#PythonJavaGoRuby <p>This sample is available as <code>VaccineDemoShared.ts</code> in our SDK repository.</p> <p>This sample is available as <code>VaccineWalkthroughTests.cs</code> in our SDK repository.</p> <p>This sample is available as <code>vaccine_demo.py</code> in our SDK repository.</p> <p>This sample is available as <code>VaccineDemo.java</code> in our SDK repository.</p> <p>This sample is available as <code>vaccine_test.go</code> in our SDK repository.</p> <p>This sample is available as <code>vaccine_demo.rb</code> in our SDK repository.</p>"},{"location":"walkthroughs/vaccination/#next-steps","title":"Next Steps","text":"<p>Congratulations! If you've completed all the steps of this walkthrough, you've just created a mini ecosystem of issuers, verifiers, and holders all exchanging credentials. Depending on your goals, there are a couple of possible next steps to take. </p> <ul> <li>Try out a sample app</li> <li>Browse the Service Reference</li> <li>Learn more about the key concepts and technologies at play</li> </ul>"},{"location":"web/","title":"The Trinsic Javascript / Web SDK","text":"<p>The Trinsic Web SDK makes it easy to interact with the Trinsic API from any client-side web application. You can find the SDKs source on Github.</p>"},{"location":"web/#installation","title":"Installation","text":"<p>Install the package for Node or Browser from npmjs.com </p> Install <pre><code>npm install @trinsic/trinsic\n</code></pre>"},{"location":"web/#configuration","title":"Configuration","text":"Webpack 4Create React App 4Webpack 5Create React App 5 <p>You can find a basic Webpack 4 sample here.</p> <p>The library works without any further configuration in Webpack 4.</p> <p>Package import</p> <p>Import the library using <code>@trinsic/trinsic/lib/browser</code>.</p> <p>You can find a basic Create React App 4 sample here.</p> <p>You will have to extend the Create React App Webpack configuration to allow the included <code>wasm</code> bundle to be loaded.</p> <p>Package import</p> <p>Import the library using <code>@trinsic/trinsic/lib/browser</code>.</p> <ol> <li>Install the <code>@craco/craco</code> package in case you're not yet using <code>craco</code> <pre><code>npm install @craco/craco --save-exact --save-dev\n</code></pre></li> <li>Adjust your <code>package.json</code> scripts to the below:     <pre><code>\"scripts\": {\n\"start\": \"craco start\",\n\"build\": \"craco build\",\n\"test\": \"craco test\",\n\"eject\": \"react-scripts eject\"\n}\n</code></pre></li> <li>Add a <code>craco.config.js</code> file next to the <code>package.json</code> file with the following configuration:     <pre><code>const { addBeforeLoader, loaderByName } = require('@craco/craco');\nmodule.exports = {\nwebpack: {\nconfigure: (webpackConfig) =&gt; {\nconst wasmExtensionRegExp = /\\.wasm$/;\n\nwebpackConfig.module.rules.forEach((rule) =&gt; {\n(rule.oneOf || []).forEach((oneOf) =&gt; {\nif (oneOf.loader &amp;&amp; oneOf.loader.indexOf('file-loader') &gt;= 0) {\noneOf.exclude.push(wasmExtensionRegExp);\n}\n});\n});\n\nreturn webpackConfig;\n},\n},\n};\n</code></pre></li> </ol> <p>You can find a basic Webpack 5 sample here.</p> <p>Package import</p> <p>Import the library using <code>@trinsic/trinsic/browser</code>.</p> <p>You will have to enable the <code>asyncWebAssembly</code> experiment in Webpack 5.</p> <ol> <li>Adjust your <code>webpack.config.js</code>:     <pre><code>experiments: {\nasyncWebAssembly: true,\n},\n</code></pre></li> </ol> <p>You can find a basic Create React App 5 sample here.</p> <p>Package import</p> <p>Import the library using <code>@trinsic/trinsic/browser</code>.</p> <p>You will have to extend the Create React App Webpack configuration to allow the included <code>wasm</code> bundle to be loaded.</p> <ol> <li>Install the <code>@craco/craco</code> dependency in case you're not yet using <code>craco</code> <pre><code>npm install @craco/craco --save-exact --save-dev\n</code></pre></li> <li>Adjust your <code>package.json</code> scripts to the below:     <pre><code>\"scripts\": {\n\"start\": \"craco start\",\n\"build\": \"craco build\",\n\"test\": \"craco test\",\n\"eject\": \"react-scripts eject\"\n}\n</code></pre></li> <li>Add a <code>craco.config.js</code> file next to the <code>package.json</code> file with the following configuration:     <pre><code>module.exports = {\nwebpack: {\nconfigure: (webpackConfig) =&gt; {\nwebpackConfig.experiments = {\nasyncWebAssembly: true\n};\n\nconst wasmExtensionRegExp = /\\.wasm$/;\nwebpackConfig.module.rules.forEach((rule) =&gt; {\n(rule.oneOf || []).forEach((oneOf) =&gt; {\nif (oneOf.type === \"asset/resource\") {\noneOf.exclude.push(wasmExtensionRegExp);\n}\n});\n});\nreturn webpackConfig;\n},\n},\n};\n</code></pre></li> </ol>"},{"location":"web/#next-steps","title":"Next Steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API</p>"}]}