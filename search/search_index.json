{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Welcome to Trinsic's Docs \ud83d\udc4b Build the future of identity with Trinsic, infrastructure for building amazing identity products using identity wallets and verifiable credentials. CLI Tutorial <p>Dive into a sandbox CLI environment</p>        Get started        Dashboard <p>Create your ecosystem and API key</p>        Sign in        API reference <p>Explore our server- and client-side API libraries</p>        View reference        <p>Looking for our Legacy Platform's documentation?</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#sdks","title":"SDKs","text":""},{"location":"roadmap/#available-sdks","title":"Available SDKs","text":"<ul> <li> .NET</li> <li> Node</li> <li> Python</li> <li> Web</li> <li> Java</li> <li> Go</li> <li> Android</li> <li> iOS</li> </ul>"},{"location":"support/","title":"Have a Question?","text":"<p>Normally, the best way to ask quick questions is through the Trinsic Community slack channel.</p> <p>If you have a bug to report, please report it on the Github issues on our SDK. Contributions and additions to this docs site are always welcome.</p> <p>Finally, if you're interested in getting in touch with the team for any other reason, contact us at support@trinsic.id. We treat any feedback as gold.</p>"},{"location":"android/","title":"Android SDK","text":"<p>The SDK is available for all languages. See individual language for installation instructions.</p> <ul> <li>Native</li> <li>Flutter</li> <li>.NET MAUI</li> <li>React Native</li> </ul>"},{"location":"android/#android-sample-application","title":"Android Sample Application","text":"<p>The Trinsic Android sample application makes it easy to interact with the Trinsic API. The sample application is located here</p>"},{"location":"android/#installation","title":"Installation","text":"<ol> <li>Clone the <code>sdk-examples</code> repository</li> <li>Open the folder <code>sdk-examples/android</code> in Android Studio</li> <li>Run gradle build for the first time, it will take a while, but it should pull down all the required <code>.jar</code> files</li> <li>You should be able to build and run the android application.</li> <li>There is an <code>sdk-examples/android-controller</code> application written in Python which allows you to issue credentials/verify proofs outside of the android application for demonstration purposes.</li> </ol> <p>Note</p> <p>If you want to included the two required Trinsic <code>.jar</code> files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p> <pre><code>def urlFile = { url, name -&gt;\nFile file = new File(\"$buildDir/download/${name}\")\nfile.parentFile.mkdirs()\nif (!file.exists()) {\nnew URL(url).withInputStream { downloadStream -&gt;\nfile.withOutputStream { fileOut -&gt;\nfileOut &lt;&lt; downloadStream\n}\n}\n}\nfiles(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\n// other dependencies\nimplementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.10.0/trinsic-services-1.10.0.jar', 'trinsic-services-1.10.0')\n}\n</code></pre>"},{"location":"cli/","title":"Trinsic CLI","text":"<p>The Trinsic CLI makes it easy to interact with the Trinsic API from your terminal. It can be used for task automation without needing to setup a project.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>You can get the CLI on homebrew or build the CLI from source on Github. It contains all the commands of Trinsic's SDKs and makes them interactive.</p> MacOS and LinuxWindowsFrom source <p>We use homebrew to distribute the CLI packages for MacOS and Linux. Install Homebrew</p> <pre><code>brew install trinsic-id/tap/trinsic-cli\n</code></pre> <p>Download the latest CLI installer from our Releases .</p> <p>Select the latest <code>trinsic-cli-X.YY.Z-x86_64.msi</code> and install it.</p> <p>The CLI can also be built from source.</p> <p>This requires the Rustup toolchain  installed on your system.</p> <p>Once installed, run this command in terminal:</p> <pre><code>cargo +nightly install --git https://github.com/trinsic-id/sdk trinsic\n</code></pre> <p>To verify that the CLI has been installed successfully, try running:</p> <pre><code>trinsic --help\n</code></pre>"},{"location":"cli/#usage","title":"Usage","text":"<p>Get a full list of supported subcommands and arguments:</p> <pre><code>trinsic --help\n</code></pre>"},{"location":"cli/config/","title":"Configuration","text":"<p>The CLI stores its configuration in the user's home directory in <code>~/.trinsic/</code>. This directory contains the main configuration file <code>config.toml</code> and all the profile data.</p>"},{"location":"cli/config/#show-configuration","title":"Show Configuration","text":"<p>To print the current configuration file in the terminal use:</p> <pre><code>trinsic config --show\n</code></pre> <p>Typical configuration file may look like this:</p> <pre><code>[server]\naddress = \"https://prod.trinsic.cloud\"\n\n[profile]\ndefault = \"my_profile\"\n</code></pre>"},{"location":"cli/config/#update-configuration-entry","title":"Update Configuration Entry","text":"<p>To change the configuration values, use the <code>config</code> subcommand with the attribute and its value.</p> <pre><code>trinsic config &lt;attribute_name&gt; &lt;attribute_value&gt;\n</code></pre> <p>The following attributes are currently supported:</p> <code>server-address</code> <p>Updates the default server address the CLI communicates</p> <pre><code>trinsic config --server-address https://example.com/\n</code></pre> <code>profile-default</code> <p>Updates the default profile used with the CLI</p> <pre><code>trinsic config --profile-default alice\n</code></pre>"},{"location":"cli/demo/","title":"Trinsic CLI Demo","text":""},{"location":"cli/demo/#steps-to-run","title":"Steps to Run","text":"<ul> <li>Click the green Run button</li> <li>Follow walkthrough</li> <li>Note: If you resize this window, make sure to reload the page. If not, the CLI will have display problems.</li> </ul>"},{"location":"dart/","title":"The Trinsic Dart SDK","text":"<p>The Trinsic Dart SDK makes it easy to interact with the Trinsic API from your Dart/Flutter application. The most recent version of the library can be found on pub.dev. You can also find the SDKs source on Github.</p> <p>Supported runtimes</p> <p>Flutter targets (Windows, MacOS, iOS, Android, Web) are supported natively with the Dart SDK. A sample application is here</p>"},{"location":"dart/#installation-in-a-new-project","title":"Installation in a new project","text":"<p>Add the required dependency to your Dart/Flutter <code>pubspec.yaml</code></p> DartFlutter <pre><code>dart pub add trinsic_dart\n</code></pre> <pre><code>flutter pub add trinsic_dart\n</code></pre> <p>Alternatively, you can simply instantiate this service with or without parameters</p> <pre><code>import 'package:trinsic_dart/trinsic.dart';\n// ...\nvar trinsicService = TrinsicService(null);\n// Or, if you have an auth token\nvar trinsicService = TrinsicService(trinsicConfig(authToken: \"&lt;auth_token&gt;\"));\n</code></pre>"},{"location":"dotnet/","title":"The Trinsic C# / .NET SDK","text":"<p>The Trinsic C# / .NET SDK makes it easy to interact with the Trinsic API from your .NET application. The most recent version of the library can be found on NuGet. The Trinsic SDK supports .NET applications written in C#, VB.NET, and F# that utilize any supported version of .NET Core. You can also find the SDKs source on Github.</p> <p>Supported runtimes</p> <p>.NET targets for iOS, Android, and Blazor are fully supported using the same package dependencies via .NET 6.</p>"},{"location":"dotnet/#installation-in-a-new-project","title":"Installation in a new project","text":"<p>Add the required dependencies from Nuget.org </p> Package Manager.NET CLIPackageReference <pre><code>PM&gt; Install-Package Trinsic\n</code></pre> <pre><code>dotnet add package Trinsic\n</code></pre> <pre><code>&lt;PackageReference Include=\"Trinsic\" /&gt;\n</code></pre> <p>To register the services with dependency injection pipeline:</p> <pre><code>services.AddTrinsic();\n</code></pre> <p>To configure additional parameters:</p> <pre><code>services.AddTrinsic(options =&gt;\n{\n// to configure the service with your auth token\noptions.ServiceOptions.AuthToken = \"&lt;auth_token&gt;\";\n})\n</code></pre> <p>The service can then be injected in your controller as</p> <pre><code>public MyController(TrinsicService trinsicService)\n{\n// init\n}\n</code></pre> <p>Alternatively, you can simply instantiate this service with or without parameters</p> <pre><code>var trinsicService = new TrinsicService();\n\n// or\n\nvar trinsicService = new TrinsicService(new ServiceOptions\n{\nAuthToken = \"&lt;auth_token&gt;\"\n});\n</code></pre>"},{"location":"go/","title":"The Trinsic Go SDK","text":"<p>The Trinsic Go SDK makes it easy to interact with the Trinsic API from any Go application. The most recent version of the library can be found on Github. You can find the SDKs source on Github.</p>"},{"location":"go/#installation-and-configuration","title":"Installation and Configuration","text":"<ol> <li>Run the following command to install the go SDK package <pre><code>go install github.com/trinsic-id/sdk/go@latest\n</code></pre></li> <li> <p>Test the installation by running the following go code:</p> <pre><code>trinsicService, err := sdk.NewTrinsic()\nif err != nil {\npanic(\"Account service not created\")\n}\n\nprofile, err := trinsicService.Account().LoginAnonymous(context.Background())\nif err != nil {\npanic(\"Sign in failed!\")\n}\nfmt.Printf(\"%v\\n\", profile)\n</code></pre> </li> </ol>"},{"location":"ios/","title":"iOS SDK","text":"<p>Several languages can be used with iOS applications. See the individual language documentation for installation instructions</p> <ul> <li>Swift</li> <li>Flutter</li> <li>React Native</li> </ul>"},{"location":"ios/#swift-sdk","title":"Swift SDK","text":"<p>The latest package is available for Swift Package Manager and can be added in your dependency section in <code>Package.swift</code> as follows:</p> <pre><code>dependencies: [\n    .package(name: \"Trinsic\", url: \"https://github.com/trinsic-id/sdk-swift\", branch: \"main\")\n],\n</code></pre> <p>You can find more details, source code, and tests for the Swift SDK at trinsic-id/sdk-swift.</p>"},{"location":"java/","title":"The Trinsic Java / Kotlin SDK","text":"<p>The Trinsic Java / Kotlin SDK makes it easy to interact with the Trinsic API from any Java (or Kotlin) application. The most recent version of the package is found on the Github Release. You can find the SDKs source on Github.</p>"},{"location":"java/#installation","title":"Installation","text":"<ol> <li>Add the <code>urlFile</code> code shown below to your <code>build.gradle</code>.</li> <li>Add the implementations as shown below to your <code>build.gradle</code>.</li> <li>Run <code>gradle build</code> to download the required jar files. This can take some time.</li> </ol>"},{"location":"java/#configuration","title":"Configuration","text":"<p>Note</p> <p>If you want to include the required Trinsic <code>.jar</code> file in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p> <pre><code>def urlFile = { url, name -&gt;\nFile file = new File(\"$buildDir/download/${name}\")\nfile.parentFile.mkdirs()\nif (!file.exists()) {\nnew URL(url).withInputStream { downloadStream -&gt;\nfile.withOutputStream { fileOut -&gt;\nfileOut &lt;&lt; downloadStream\n}\n}\n}\nfiles(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\nimplementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.10.0/trinsic-services-1.10.0.jar', 'trinsic-services-1.10.0')\n}\n</code></pre>"},{"location":"learn/","title":"Introduction","text":""},{"location":"learn/#build-the-future-of-identity","title":"Build the future of identity","text":"<p>Trinsic is a cloud-native, web5-native infrastructure for building IDtech products across a variety of use cases, industries, and geographies. Products built on Trinsic inherit features such as user-centricity, interoperability, and decentralization out of the box. We strive to make these concepts easy to understand and use.   We\u2019re glad you\u2019re here. We\u2019ve been focused on providing an exceptional developer experience for decentralized identity since our beginnings in 2019. Today, we power many of the most successful decentralized identity products. As you explore our documentation, we\u2019d love your feedback through our Slack community, the chat bubble on the page, or email. And if you want to complain (or say nice things) to the CEO, feel free to email me (Riley at trinsic.id).</p>"},{"location":"learn/concepts/credentials/","title":"Credentials","text":"<p>Verifiable Credentials or VCs are digital certificates that are standardized and provide a secure and private way to share information online - as they can be verified without revealing any unnecessary details. A verifiable credential is a digital representation of a person's identity information that has been cryptographically signed by an issuer. They provide an interoperable way to attest and authenticate any kind of data in an IDtech application.</p> <p>When someone issues you a verifiable credential, it's stored in an SSI digital wallet, making it easy for you to securely and privately show them to others. A digital wallet is a software application and encrypted database that stores credentials, keys, and other secrets necessary for self-sovereign identity.</p> <p>Trinsic currently uses a verifiable credential format that complies with the W3C Verifiable Credential Data Model (and that's why they're \u201cstandardized\u201d), but we\u2019re watching competing standards as they evolve as well (e.g. IETF ACDCs, ISO 13018-5, Anoncreds, etc). For more details on the standards we use, see Standards.</p> <p>Verifiable credentials are unique from other kinds of digital documents because they enable you to verify the following things:</p> <ol> <li>The original issuing entity (the source of the data)</li> <li>It was issued to the entity presenting it (the subject of the data)</li> <li>It hasn't been tampered with (the veracity of the data)</li> <li>Whether the issuer revoked the credential as of a particular point in time (the status of the data)</li> </ol>"},{"location":"learn/concepts/credentials/#trust-triangle","title":"Trust Triangle","text":"<ul> <li>Issuer: The person/organization that creates the Verifiable Credential and gives it to another person/organization.</li> <li>Holder: The person/organization that holds the verifiable credential in their digital wallet.</li> <li>Verifier: The person/organization that receives and authenticates the information shared with them instantly.</li> </ul> <p>An example of an issuer is the government, of a holder is a person who receives a digital ID from the government and of a verifier is a security agent in the airport checking your ID.</p>"},{"location":"learn/concepts/credentials/#vcs-are","title":"VCs are","text":"<ul> <li>Portable: You can easily send a credential online to anyone you.</li> <li>Verifiable: You can verify who's the issuer of the credential, who the credential was issued to (holder), if the information within the credential has been tampered with and whether the credential has been revoked</li> <li>Private: Zero-knowledge proofs allow you to select which information you wish to share on a credential, providing greater control over your personal data.</li> <li>Tamperproof: VCs can\u2019t be altered/forged.</li> </ul>"},{"location":"learn/concepts/credentials/#components-of-a-credential","title":"Components of a credential","text":"<p>To break down the components of a credential, we'll use a digital driver's license as an example.</p>"},{"location":"learn/concepts/credentials/#attributes-or-data","title":"Attributes, or Data","text":"<p>The most important part of a credential is the data inside it. </p> <p>In its simplest form, attributes are key-value pairs in a JSON object. These attributes are populated at issuance on a per-credential basis, based on a template. </p> <p>Verifiers use attributes to request only the data from credentials that they need\u2014for example, an age-checking verifier may only request <code>date_of_birth</code> from a driver\u2019s license, instead of the entire credential.</p>"},{"location":"learn/concepts/credentials/#templates","title":"Templates","text":"<p>Credentials are issued from templates, an abstraction provided by Trinsic that makes getting started and ongoing management easy, and enables tighter integration with other features in the Trinsic platform such as governance. </p> <p>When you understand how templates work in Trinsic, you will get the benefits of semantic interoperability and governance without needing to understand the nuts and bolts of schemas, credential definitions, JSON-LD contexts, credential restrictions, and more. See our page on templates to learn more.</p>"},{"location":"learn/concepts/credentials/#issuer-id","title":"Issuer ID","text":"<p>Each verifiable credential is cryptographically signed by an issuer. The signature, along with the issuer\u2019s identifier, strongly identify the issuer, ensuring anyone can verify the source of the data in the credential. </p> <p>In order to be trustworthy, the issuer\u2019s identifier needs to be resolvable. We use decentralized identifiers (DIDs), a W3C standard, for this purpose. Trinsic offers providers a number of choices of DID methods for the issuers in their ecosystems. To learn more, read more about the standards we use and Decentralized Identifiers .</p>"},{"location":"learn/concepts/dids/","title":"Identifiers","text":"<p>Identifiers are necessary to assign to each member of an ecosystem. Identity wallets manage identifiers on behalf of the holder(s) that control(s) the wallet. At Trinsic we use Decentralized identifiers or DIDs, which are globally unique, cryptographically verifiable URIs that are not bound to a centralized registry. DIDs provide a way to separate a public identifier from public keys, which is an important requirement for resilient identity systems.</p> <p>Trinsic aims to abstract the complexities of interacting with DIDs. So while this section provides a brief explanation of DIDs, you do not need to fully grok them in order to build an identity product using Trinsic.</p>"},{"location":"learn/concepts/dids/#how-dids-work","title":"How DIDs work","text":"<p>Examples of centralized identifiers include Student ID, ID number, driver's license number, username, email address, and user ID. These are considered centralized because they are provided by an authority, provider, or organization that gets between us and our ability to access certain services. The concept of identity being decentralized means that we become the owners of our data and access without relying on any intermediary organization or central issuing agency.</p>"},{"location":"learn/concepts/dids/#dids-are","title":"DIDs are","text":"<ul> <li>Decentralized;</li> <li>Persistent: They don\u2019t require the continued operation of an underling organization, such as Gmail or the government;</li> <li>Cryptographically verifiable: You can prove control of the identifier cryptographically;</li> <li>Resolvable: You can discover metadata about the identifier.</li> </ul>"},{"location":"learn/concepts/dids/#structure","title":"Structure","text":"<p>An example of DID is <code>did:example:12345abcdefghijklm</code></p> <p><code>did</code> is the Scheme - all DIDs start with it</p> <p><code>example</code> is the Method - where the DID is stored (blockchain, digital wallet or anywhere else)</p> <p><code>12345abcdefghijklm</code> is the Identifier - the unique identifier of the DID</p> <p>Examples of DID methods: <code>key</code> (public key is stored directly in the URI, enabling local resolution), <code>ion</code> (DID stored in the Bitcoin blockchain), <code>web</code>, <code>indy</code>. The goal of DIDs is to provide a decentralized, method-agnostic way to bundle an Identifier together with information about how to communicate and interact securely with the subject attached to said identifier. When you resolve a DID using its DID Method and the Identifier, you retrieve a DID Document, which contains information about how to interact with the subject (chiefly, cryptographic keys associated with the subject which can be used for verifiable communication).</p>"},{"location":"learn/concepts/dids/#working-with-dids-on-trinsic","title":"Working with DIDs on Trinsic","text":"<p>Trinsic abstracts away the complexities of working with DIDs and cryptography, allowing you to focus on building a great identity product.</p> <p>In an IDtech product, issuers and holders will have its own DID, which will be specified in the credentials issued/held by it. It signs a cryptographic proof against the contents of the credential (using its own private key) and stores this in the\u00a0<code>proof</code> field of the credential. Critically, the public key associated with the signing private key is stored in the issuer's DID Document.</p> <p>When verifying a credential, the verifier looks at the DID in the\u00a0<code>issuer</code> field and resolves it to fetch its associated DID Document. Then, they verify that the\u00a0<code>proof</code> field is cryptographically valid and was generated using one of the keys in the DID Document. This process guarantees that the issuer\u00a0claimed by the credential is indeed the entity that signed the credential and that the credential has not been modified.</p> <p>At Trinsic, when a\u00a0wallet\u00a0is created, we generate a cryptographic keypair and securely stores it; this keypair is what will be used to sign credentials issued by the wallet. Additionally, Trinsic generates a\u00a0<code>did:key</code>\u00a0DID, which encodes the public information necessary to verify credentials issued by the wallet; this is the\u00a0<code>public_did</code>\u00a0field of the wallet object.</p> <p>When using this scheme, one must only maintain a list of issuer DIDs which are trusted to issue credentials of a certain type (this might be accomplished by a\u00a0Trust Registry); the cryptographic guarantees of DIDs and VCs take care of the rest.</p>"},{"location":"learn/concepts/dids/#supported-did-methods","title":"Supported DID methods","text":"<p>More to come</p> <p>We plan to grow the list of supported DID methods as we move towards general availability of this feature.</p> Method Type Notes did:key Static The default DID method for all wallets. Encodes key information directly in the DID; as a result, key rotation requires a new DID. did:ion Distributed Ledger ION\u00a0is a sidetree/Layer-2 protocol on top of the Bitcoin blockchain. Registering a DID will incur charges if on the\u00a0mainnet\u00a0network. IonOptions did:indy Distributed Ledger INDY\u00a0is a Hyperledger Indy based protocol. Registering a DID will incur charges if on the main (non test) networks IndyOptions did:sov Distributed Ledger SOV\u00a0is the Sovrin Foundation implementation of Hyperledger Indy. It is available via <code>did:indy:sov</code> prefix Under IndyOptions above. Registering a DID will incur charges if on the main (non test / non builder) networks"},{"location":"learn/concepts/dids/#upgrading-wallet-dids","title":"Upgrading wallet DIDs","text":"<p>Providers of an ecosystem may\u00a0upgrade\u00a0a wallet's DID from\u00a0<code>did:key</code>\u00a0to any of the supported methods via\u00a0a simple API call. Trinsic handles the complexities of this process for you.</p> <p>Many DID methods are based on distributed ledgers (commonly known as \"blockchains\"), so the following should be kept in mind when registering a DID which uses a ledger:</p> <p>Data Protection &amp; Compliance</p> <p>When writing an identifier to a public, permanent resource like a blockchain, it\u2019s important to be extremely sure that you want that data to remain there forever. Permanence is hard to reconcile with \u201cright to be forgotten\u201d, and the jury is out on whether a person\u2019s identifiers are considered personal data (literally).</p> <p>For these reasons, it is ***not advisable*** to upgrade DIDs controlled by wallets whose holders are natural persons (in other words, DIDs whose subjects are persons). If doing so is important for your use case, we strongly recommend you work with legal counsel to understand all of the implications before doing so.</p> <p>Fees</p> <p>Depending on the DID method chosen, registering a DID may incur a transaction fee, which is different for each ledger.\u00a0You are responsible for these fees. Documentation of these fees will be visible through our Dashboard and on our pricing page. You should keep this in mind before you programmatically upgrade DIDs through the API.</p> <p>Resolution</p> <p>Newly-registered DIDs may not be immediately resolvable, as distributed ledgers typically cannot provide instantaneous writes. Issuance and verification of credentials against these DIDs will still function during this time, but only within the Trinsic platform.</p>"},{"location":"learn/concepts/ecosystems/","title":"Ecosystems","text":"<p>Successful IDtech products can be broken down into two parts:</p> <ul> <li>An identity wallet: a representation of the user\u2019s identity</li> <li>An ecosystem: the set of entities that can interact with the user\u2019s identity</li> </ul> <p>We\u2019ve made it simple to create both wallets and ecosystems. In this section, we\u2019ll break down the concept of an ecosystem and how Trinsic can help your ecosystem thrive. </p>"},{"location":"learn/concepts/ecosystems/#example-ecosystems-from-the-real-world","title":"Example ecosystems from the real world","text":"<p>Trust ecosystems exist all around us, but most are analog and disaggregated and therefore filled with inefficiencies and fraud. </p> <p>Example 1: Payments</p> <p>The first trust ecosystems to go digital were payments networks. Visa, MasterCard, etc. introduced a standard mechanism to allow consumers to make purchases with any merchant using credit from any bank. Visa created an enduring business while simultaneously unlocking value for all participants involved.</p> <ul> <li>Wallet: users carry credit cards in their physical, leather wallets and in digital wallets held on their smart devices</li> <li>Ecosystem: the banks issuing cards and the merchants accepting cards comprise this ecosystem</li> </ul> <p>Example 2: Health pass</p> <p>As Covid-19 swept over the world, jurisdictions of various kinds sought to curb the spread of the virus by instituting restrictions on travel. Health passes of various kinds were instituted across the world, enabling people who could prove recent test results or vaccine status to travel again.</p> <ul> <li>Wallet: users obtained paper vaccine cards or digital health passes on their smart devices</li> <li>Ecosystem: the airlines, community centers, venues, cruise lines, customs departments, and other places where health passes were accepted comprise this ecosystem</li> </ul>"},{"location":"learn/concepts/ecosystems/#anatomy-of-a-trust-ecosystem","title":"Anatomy of a trust ecosystem","text":"<p>As you dive deeper into how ecosystems work, it\u2019s helpful to understand wallets, credentials, templates, and governance. We recommend referring back and forth between these pages to get a full picture. </p> <p>Provider</p> <p>At the helm of a trust ecosystem sits a provider. Providers develop IDtech products that solve problems for the other participants of an ecosystem. They develop the software, adoption tools (such as templates), business models &amp; incentives, and the governance that enables an ecosystem to be successful. </p> <p>Before Stripe, every growing internet platform had a payments team. Today, every growing internet platform has an Identity team. Identity verification is a core piece of economic infrastructure for online businesses. - Stripe </p> <p>Trinsic\u2019s product is built from the ground-up for providers. Successful providers usually target a niche or industry with the aim of creating a sustainable, growing business.</p> <p>Issuer</p> <p>Issuers are the source of data in an ecosystem. They transform their raw data into verifiable credentials that are usable more broadly via the user\u2019s wallet. Common examples of issuers include universities issuing diplomas, insurance companies issuing insurance cards, and libraries issuing library cards\u2014but with digitally-native identity, so many more possibilities open up. </p> <p>Every company in the world already has valuable data and functionality housed within its systems. Capitalizing on this value, however, means liberating it from silos and making it interoperable and reusable in different contexts - Google\u2019s \u201cState of API Economy 2021\u201d report </p> <p>The value for issuers often stems from extending their existing business into a new, digital format, which can either reduce costs or increase revenue. </p> <p>Proxy issuers can help bootstrap an ecosystem\u2014this is when a provider uses 3rd-party APIs to verify user attributes to seed their wallet (e.g. using Twilio to verify a phone number vs getting a verifiable credential issued by AT&amp;T).</p> <p>Holder or Subject</p> <p>Holder is the umbrella term for the person or organization who controls the identity in question. Whenever possible, you should build your product to put the holder in control of their own identity. The holder should always be able to give consent before their data is shared. </p> <p>Usually, the \u201csubject\u201d of the identity and the holder are the same. When Alice controls an identity wallet filled with Alice\u2019s credentials, the holder and subject are the same. However, if Alice is a 2-year-old child, it\u2019s likely that Alice\u2019s father, Bob, will control her wallet. In that case, Bob is the holder and Alice is the subject. The holder and subject can also differ for business wallets, refugee/homeless/incarcerated person wallets, or for inanimate objects. </p> <p>Verifier </p> <p>Verifiers are the big winners of the move toward digital identity. They\u2019re able to verify people with less friction and more trust, all with less expense than current systems.</p> <p>Providers serve two important roles relative to verifiers. First, providers can aggregate the trusted issuers inside &amp; outside the ecosystem to enable verifiers to trust a credential without maintaining their own infrastructure or registry. Second, providers can impose rules on verifiers to make sure they\u2019re following data minimization and data protection best practices and regulations.</p>"},{"location":"learn/concepts/json-ld/","title":"JSON-LD","text":"<p>JSON-LD stands for JavaScript Object Notation for Linked Data. It\u2019s a type of JSON format that is used to encode linked data using a set of standards based on the W3C's RDF (Resource Description Framework).</p> <p>Here\u2019s an example of a JSON-LD file:</p> <pre><code>{\n\"@context\": \"https://schema.org\",\n\"@type\": \"Person\",\n\"name\": \"Jane Doe\",\n\"jobTitle\": \"Developer\",\n\"telephone\": \"(425) 123-4567\",\n\"url\": \"&lt;http://www.janedoe.com&gt;\"\n}\n</code></pre> <p>In JSON-LD, a vocabulary is a set of terms that define the meaning of JSON-LD data. The vocabulary is defined in a JSON-LD context, which is a JSON object that maps terms to their corresponding IRIs (Internationalized Resource Identifiers).</p>"},{"location":"learn/concepts/json-ld/#the-context-element","title":"The <code>@context</code> element","text":"<p>A vocabulary is a URL where you can find schemas for structured data to be used online. Each vocabulary source (https://schema.org/, for example) defines entities, relationships between entities and actions. The <code>@context</code> element defines the vocabulary used in the file, making it more human-readable, easier to understand and helping the browser understand the context of the data and its relationships.</p> <p>By providing a link to the vocabulary, the <code>@context</code> element clarifies what the data represents and ensures that it\u2019s interpreted properly. This makes easier the translation between schemata or systems and the reconstruction of lost or foreign contexts in the case these are lost.</p> <p>In the previous example, the <code>@context</code> says \u201cHey browser, the vocabulary I\u2019m referencing is http://schema.org\".</p>"},{"location":"learn/concepts/json-ld/#the-type-element","title":"The <code>@type</code> element","text":"<p>This element specifies the type of the item being marked up. You can find a list of all the available item types here.</p> <p>In the previous example, the <code>@type</code> says \u201cHey browser, the item type I\u2019m using is Person\". You can find it here.</p>"},{"location":"learn/concepts/json-ld/#attribute-value-pairs","title":"Attribute-value pairs","text":"<p>After defining the vocabulary and the item type, you can define the item properties. Inside an item type's Schema.org page (for example http://schema.org/Person), you will find all available properties that an item Person can have. In the previous example, <code>name</code>, <code>jobTitle</code>, <code>telephone</code> and <code>url</code> are all its properties.</p>"},{"location":"learn/concepts/json-ld/#json-ld-and-verifiable-credentials","title":"JSON-LD and Verifiable Credentials","text":"<p>JSON-LD is a format that allows for easy integration of Verifiable Credentials into existing systems, and it provides a standardized way of representing identity-related information. JSON-LD is the perfect format to help ensure VCs interoperability, usability and easy manageablity.</p> <p>Here's an example of a verifiable credential in JSON-LD format:</p> <pre><code>{\n\"@context\": [\n\"https://www.w3.org/2018/credentials/v1\"\n],\n\"type\": [\"VerifiableCredential\", \"UniversityDegreeCredential\"],\n\"issuer\": \"https://example.edu/issuers/14\",\n\"issuanceDate\": \"2021-06-01T17:00:00Z\",\n\"credentialSubject\": {\n\"id\": \"did:example:ebfeb1f712ebc6f1c276e12ec21\",\n\"degree\": {\n\"type\": \"BachelorDegree\",\n\"name\": \"Bachelor of Science and Arts\",\n\"degreeType\": \"BachelorDegree\",\n\"college\": \"College of Engineering and Applied Science\",\n\"university\": \"Example University\"\n}\n},\n\"proof\": {\n\"type\": \"Ed25519Signature2018\",\n\"created\": \"2021-06-01T17:00:00Z\",\n\"proofPurpose\": \"assertionMethod\",\n\"verificationMethod\": \"did:example:ebfeb1f712ebc6f1c276e12ec21#keys-1\",\n\"jws\": \"eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkaWQ6ZXhhbXBsZTpiMzllZjJhZjM1NzY2ZGE2M2Q5MmUxMzAwMjQyMmVjMzIyNjVhYTE3IiwiaXNzdWVyIjoiaHR0cHM6Ly9leGFtcGxlLmVkdS9pc3N1ZXJzLzE0IiwiaWF0IjoxNjIyMjAzMTM4LCJleHAiOjE2MjIyMDMxNzgsImp3ayI6eyJrdHkiOiJFQyIsImNydiI6IlAtMjU2In19..5uMz5N5R5C5vK1V7Bp5G9fWbq3qkijxHx6GpUudKdJqAywq6HnGX6kGPEA9KjZlYi4f4sH4b4C8QsFyj-oCg\"\n}\n}\n</code></pre> <p>This Verifiable Credential is a University Degree Credential, issued by Example University to a specific individual identified by a DID. The credential contains information about the degree earned, including the degree type, name, college and university. The credential also includes a proof that it was issued by Example University and that the information it contains has not been tampered with.</p>"},{"location":"learn/concepts/templates/","title":"Templates","text":"<p>\u201cTemplates\u201d enable providers to define the formats and types of verifiable credentials that will be issued to holders inside and outside of their ecosystem. Templates are an abstraction provided by Trinsic that makes getting started easy, improves ongoing management of an ecosystem, and enables tighter integration with other features in the Trinsic platform such as governance. </p> <p>When you understand how templates work in Trinsic, you inherit the benefits of semantic interoperability and governance without needing to understand the nuts and bolts of schemas, credential definitions, JSON-LD contexts, credential restrictions, and more. </p> <p>Defining templates isn\u2019t just helpful for issuer and verifier adoption, but when done correctly also provides increased interoperability. </p>"},{"location":"learn/concepts/templates/#how-to-approach-templates-in-your-product","title":"How to approach templates in your product","text":"<p>Templates enable you to to remove friction for the participants of your ecosystem. Therefore first and foremost, you should ensure whatever templates you provide satisfy the needs of the issuers and verifiers you\u2019re working with. </p> <p>Before you create your own template, you should consider whether a schema for your desired credential already exists. Standards bodies or industry best-practice sometimes dictate the kind of data that should be issued. For example, you may use this document as a starting point for a Covid-19 vaccine credential or this document for a driver\u2019s license in the USA.</p> <p>Verifiable credentials enable the decoupling of datasets included in issuance and verification. That means you can provide a template for issuers to issue 10 attributes, even if the verifiers in your ecosystem only plan to verify 5 attributes. This allows you to be forward-looking as you\u2019re considering the use cases for a given credential. That said, for simplicity\u2019s sake, we tend to recommend limiting the attributes included in a template to those which you can reasonably foresee being useful in the near- to medium-term.</p> <p>Because attributes from different credentials can be combined together into a \u201ccompound proof\u201d, you do not need to worry about fitting all possible attributes into a single template.</p> <p>We do not yet allow you to edit a template after it\u2019s been created, nor do we pre-populate or recommend templates for you to use. If you\u2019re interested in either of these features, please contact us.</p>"},{"location":"learn/concepts/templates/#anatomy-of-a-template","title":"Anatomy of a template","text":"<p>When you create a template, you do the following:</p> <ol> <li>Decide which attributes are included</li> <li>Determine the type of data (string, integer, etc.)</li> <li>Optionally, you may<ol> <li>Assign optional or required value to each attribute</li> <li>Provide a description of the attribute</li> </ol> </li> </ol> <p>Trinsic then translates that input into a JSON schema and JSON-LD context, generates a unique identifier for the template, creates a resource with the details needed to maintain public resolution of these artifacts, and hosts it on your behalf.</p> <p>For example, you may create a template with the following:</p> <pre><code>{\n    \"name\": {\n        \"type\": \"string\",\n        \"description\": \"Name of the business\",\n    },\n    \"website\": {\n        \"type\": \"string\",\n        \"description\": \"More information about the business\"\n    },\n    \"rating\":{\n        \"type\": \"number\",\n        \"description\": \"rating on scale of 1-10\",\n        \"optional\": false\n    },\n    \"details\":{\n        \"type\": \"string\",\n        \"description\": \"An individual's last name\",\n        \"optional\": false\n    }\n}\n</code></pre> <p>This will create a Template that has the following structure:</p> <pre><code>TemplateData {\n    id: \"urn:template:alices-local-guides:review\",\n    name: \"Review\",\n    version: 1,\n    fields: {\n        \"name\": TemplateField {\n            description: \"Name of the business\",\n            optional: false,\n            r#type: String,\n        },\n        \"rating\": TemplateField {\n            description: \"rating on scale of 1-10\",\n            optional: false,\n            r#type: Number,\n        },\n        \"details\": TemplateField {\n            description: \"An individual's last name\",\n            optional: false,\n            r#type: String,\n        },\n        \"website\": TemplateField {\n            description: \"More information about the business\",\n            optional: false,\n            r#type: String,\n        },\n    },\n    allow_additional_fields: true,\n    schema_uri: \"https://staging-schema.trinsic.cloud/__default/review\",\n    context_uri: \"https://staging-schema.trinsic.cloud/__default/review/context\",\n    ecosystem_id: \"__default\",\n    r#type: \"VerifiableCredential\",\n}\n</code></pre> <p>At any point you can view the <code>schema_uri</code> and the <code>context_uri</code> in the browser as raw JSON.</p>"},{"location":"learn/concepts/trust-registries/","title":"Governance","text":"<p>Governance refers to the ability of a provider to add business and legal policies into an ecosystem that improve adoption, safety, and compliance, while enabling some providers to monetize their ecosystem in a sustainable way. While governance is a massive topic, Trinsic\u2019s implementation is lightweight and is designed to enable the minimum amount of overhead needed to effectively bootstrap an ecosystem.</p>"},{"location":"learn/concepts/trust-registries/#the-case-for-governance","title":"The case for governance","text":"<p>Adding the right amount of governance to your product can enable both faster growth and lower risk. </p> <p>For example, you can grow faster when you remove the need for verifiers to maintain their own list of trustworthy issuers\u2014especially in an ecosystem with dozens of issuers that may come and go. This is an important way some successful providers have monetized their ecosystem. </p> <p>Risk in your ecosystem can be reduced by imposing rules that must be met before credentials can be issued or verified inside or outside of your ecosystem. For example, you can improve safety for the users of your wallet by restricting their ability to share sensitive data with unverified 3rd-parties (or warning them beforehand).</p>"},{"location":"learn/concepts/trust-registries/#anatomy-of-governance","title":"Anatomy of governance","text":"<p>One of the core building blocks of our governance implementation is the interoperable Trust Registry specified at the Trust Over IP Foundation. We contributed to the original\u00a0specification and later open-sourced our implementation so the broader community can benefit from these features.</p>"},{"location":"learn/concepts/verifications/","title":"Verifications","text":"<p>Creating Verifiable Credentials involves generating cryptographic proofs that can be used to verify the authenticity of the VC. Digital signatures are generated using the issuer\u2019s private key and these are used to create the proofs. When a verifier receives a VC, they can use the issuer\u2019s public key to verify the credential\u2019s signature and ensure that it hasn\u2019t been tampered with. This allows information to be shared in a secure and trustworthy way between parties.</p> <p>Designing the way verifications will be done in your ecosystem is arguably the most important step in creating a successful IDtech product. Verifications are privacy-preserving proofs of data inside a VC. </p> <p>A verification is an abstraction provided by Trinsic that makes it easy to utilize W3C-conformant Verifiable Presentations, OpenID Connect, zero-knowledge proofs, and other identity specifications without having to spend months becoming an expert or writing your own implementation. For more on the standards we use, see our Standards page.</p>"},{"location":"learn/concepts/verifications/#zero-knowledge-proofs","title":"Zero-knowledge proofs","text":"<p>A zero-knowledge proof (ZKP) allows a user to prove some information is true without revealing the information itself. The classic example is proving you\u2019re over 18 without revealing your birthdate. </p> <p>The most important application of zero-knowledge proofs today is the ability to perform selective disclosure on the contents of a verifiable credential. This is important for the obvious privacy reasons related to data minimization, but it\u2019s also important for the less-obvious privacy reasons of obfuscating correlatable identifiers from verifiable presentations. Over time we will add the capability for providers to offer verifiers ZKP capabilities that allow computation on values, such as \u2018is <code>GPA</code> &gt; 3.0\u2019 or \u2018does <code>home_address</code> contain \u201cNew York\u201d\u2019.</p> <p>Trinsic\u2019s ZKP implementation is based on an extremely performant algorithm called BBS+ which is currently being standardized. To learn more, see here.</p>"},{"location":"learn/concepts/verifications/#using-verifications-in-your-app","title":"Using verifications in your app","text":"<p>Instantly verifying data to access a product, service, or resource is the bread and butter of an IDtech product. It is the point value is realized. So designing a user-friendly method for verification is critical.</p> <p>Verification policies</p> <p>The first step is to understand the requirements for verification, according to your use case\u2014verifying medical information will have much different constraints than verifying a library card. And authenticating medical information online differs from sharing that information in-person.</p> <p>As a provider, you should design verification templates that enable verifiers to collect the data they need from a holder, but no more. This is an important part of the data minimization principles underpinning Trinsic\u2019s infrastructure.</p> <p>Most successful providers do significant product work to understand how users and verifiers want to interact to optimize their desired outcomes. Trinsic\u2019s infrastructure is designed to enable this verification flexibility across various use cases.</p>"},{"location":"learn/concepts/verifications/#adoption-tools","title":"Adoption tools","text":"<p>The first adoption tool Trinsic provides for easy verifications is an OpenID Connect (OIDC) service to fit into the legacy systems and mental models that verifiers and consumers are already familiar with. To learn more about setting up your OIDC app, please see the following documentation.</p>"},{"location":"learn/concepts/wallets/","title":"Wallets","text":"<p>In Trinsic\u2019s platform, identity wallets are secure, partitioned data stores scoped to a single holder, capable of storing and sharing credentials and proofs. Endless configurations of wallets exist (custodial, non-custodial, etc.) each with different trade-offs; Trinsic has designed a hybrid-cloud wallet system intended to strike the ideal balance between security and usability:</p> <ul> <li>Cloud-based data store</li> <li>Edge-based authentication keys</li> </ul> <p>For a deeper-dive into how hybrid-cloud wallets work, see our security overview.</p>"},{"location":"learn/concepts/wallets/#how-to-use-wallets-in-your-app","title":"How to use wallets in your app","text":"<p>When a user creates an account in your product, you will create a wallet for them. This wallet is tied to the user\u2019s identity using either their email or phone number (for now) - after the user enters the code to prove control of their identifier and claim their wallet, you\u2019ll be off to the races.</p> <p>The user will interact with and control their wallet through your application. From your application\u2019s perspective, wallet storage should be treated in parallel with the database you use to manage user data. When users obtain credentials from inside or outside your ecosystem, those credentials will be inserted in the wallet. When users want to share credentials with verifiers, your product will need to obtain user consent before the data is shared.</p> <p>All the participants in an ecosystem, not just holders, will technically have wallets behind them. Therefore, any participant can issue from a template, verify, and hold credentials to establish trust.</p>"},{"location":"learn/platform/security/","title":"Security Infrastructure","text":""},{"location":"learn/platform/security/#overview","title":"Overview","text":"<p>Our cloud services are secured using a novel method of authentication based on zero-knowledge proofs . This approach allows us to introduce passwordless client authentication with improved security and user experience.</p> <p>Compared to traditional security methods that store users' credentials on the server, our approach relies on a one-time client/server negotiation without storing any user secrets on our servers. All secrets are stored with the user client and are entirely in their control. During authentication, users present proof of knowledge of these secret tokens, instead of the actual tokens. This proof is generated with each request and is unique for that request only.</p>"},{"location":"learn/platform/security/#oberon-auth-scheme","title":"Oberon Auth Scheme","text":"<p>A succinct ZKP protocol for authentication. It works by using techniques similar to Identity-Based/Attribute-Based signatures.</p> <p>Oberon allows endpoints to issue multi-factor capable tokens to consumers who can prove their validity without disclosing the tokens themselves and without requiring email, SMS, or authenticator apps. Endpoints only need to store a single public key and not any tokens. An attacker that breaks into the server doesn't have any password/token files to steal and only would see a public key. The proof of token validity is only 256 bytes while the token itself is only 48 bytes. The issuing party and verifying servers can be separate entities.</p> <p>Crypto details for Oberon </p>"},{"location":"learn/platform/security/#account-registration","title":"Account Registration","text":"<p>The below diagram illustrates how client and server interact during the registration process and negotiate the data for authentication:</p> <pre><code>sequenceDiagram\n  actor Client\n  Client-&gt;&gt;Server: Register new account or ecosystem\n  Server--&gt;&gt;Client: Generated token\n  Note right of Server: Does not store token\n  opt\n    Note over Client: Apply multi-factor security&lt;br /&gt;using PIN, word phrase, HSM, etc.&lt;br /&gt;by cryptographically blinding&lt;br/&gt;the secret token\n    Client-&gt;&gt;Client: Token protection\n  end\n  Client-&gt;&gt;Client: Save token on client device</code></pre>"},{"location":"learn/platform/security/#api-requests","title":"API Requests","text":"<p>The process of making authenticated API requests against the server involves generating a proof of knowledge and appending it to the request headers. This proof is:</p> <ul> <li>valid for a limited time only (order of milliseconds)</li> <li>unique and cannot be used twice (replay protection)</li> <li>bound to the current request payload (mitm protection)</li> </ul> <p>The diagram below illustrates the steps involved in generating proof and interacting with the server.</p> <pre><code>sequenceDiagram\n    actor U as Client\n    participant A as Server\n\n    U-&gt;&gt;U: Read Token\n    U-&gt;&gt;U: Generate proof of token\n    U-&gt;&gt;A: Make API Request\n    note right of U: Proof is added in 'Authorization' header\n\n    A-&gt;&gt;A: Check authorization\n\n    alt sucesss\n        A-&gt;&gt;A: Process request\n        A--&gt;&gt;U: Send response\n    else invalid proof\n        A--&gt;&gt;U: 401 Unauthorized\n    end</code></pre>"},{"location":"learn/platform/standards/","title":"Technology Standards","text":"<p>Our mission is to make the world more accessible. Standards are an important part of the Trinsic product stack because they help us do that. On this page we\u2019ll break down the standards we use and why.</p>"},{"location":"learn/platform/standards/#standards-make-the-world-go-round","title":"Standards make the world go round","text":""},{"location":"learn/platform/standards/#interoperability","title":"Interoperability","text":"<p>There are two kinds of interoperability:</p> <ol> <li>Everyone use the same code, so everyone is interoperable</li> <li>Everyone implements against a common, agreed-upon standard</li> </ol> <p>Realistically any interoperability will exist on a spectrum between these two points. For example, NFTs on Ethereum will be interoperable within that community if they adhere to the EIP-721, and seed phrase recovery for Bitcoin wallets will be interoperable within that community if they adhere to the BIP39 standard. While these examples sound like the second kind of interoperability, those NFTs won\u2019t work outside the Ethereum ecosystem, nor will Bitcoin wallets be recoverable into wallets that don\u2019t support Bitcoin. Thus we see, interoperability is not a black &amp; white issue.</p> <p>Various levels of interoperability have been achieved in subsets of the decentralized identity community in the past as well. We believe interoperability is good for business. One of Trinsic\u2019s key values is to achieve and maintain interoperability in areas that are important for our customers, so they can spend their time building a valuable business. Doing so will drive adoption of their products and help us achieve our mission.</p>"},{"location":"learn/platform/standards/#avoid-vendor-lock-in","title":"Avoid vendor lock-in","text":"<p>Standards also enable us to avoid vendor lock-in\u2014that is, avoid locking our customers in to Trinsic. We want to be chosen by our customers because we make them more successful by providing a valuable service, not because they\u2019re stuck. In addition, trapping users in a silo we control is antithetical to our values. And finally, we\u2019ve seen that \u201cno vendor lock-in\u201d is also a valuable benefit for our customers as they take their solutions to market. </p>"},{"location":"learn/platform/standards/#standards-we-use","title":"Standards we use","text":"<p>Standards are such a core part of how we all do business that it wouldn\u2019t make sense to add each one here. Instead, we\u2019ll surface standards that are important for interoperability, security, privacy, or other feature that you probably care about.</p>"},{"location":"learn/platform/standards/#verifiable-credentials","title":"Verifiable Credentials","text":"<p>Verifiable credentials provide an interoperable way to attest and authenticate any kind of data. For an introductory post to verifiable credentials, see our blog post on the subject.</p> <p>A verifiable credential is a set of tamper-evident claims and metadata that cryptographically prove who issued it.</p> <p>From the W3C VC Data Model</p> <p>Trinsic currently uses a verifiable credential format that complies with the W3C Verifiable Credential Data Model, but we\u2019re watching competing standards as they evolve as well (e.g. IETF ACDCs, ISO 13018-5, Anoncreds, etc).</p>"},{"location":"learn/platform/standards/#openid-connect","title":"OpenID Connect","text":"<p>OpenID Connect (OIDC) is a widely-adopted standard for enabling federated identity online. Because consumers are so used to it, and verifiers have adopted it so widely, it is an ideal way to verify credentials. The only difference is that instead of redirecting users to an external Idp such as Facebook or Google, users are redirected to their own wallet to provide a verification.</p>"},{"location":"learn/platform/standards/#decentralized-identifiers","title":"Decentralized Identifiers","text":"<p>Decentralized identifiers (DIDs) are globally unique, cryptographically verifiable URIs that are not bound to a centralized registry. They\u2019re like URLs without ICANN and domain registrars. In identity, DIDs provide an abstraction between a public identifier and public keys. For more information on DIDs, see our section on DIDs.</p>"},{"location":"learn/platform/standards/#linked-data","title":"Linked Data","text":"<p>When ecosystem participants begin to share credentials outside of your immediate ecosystem, a problem starts to occur. Suppose a credential has an attribute \u201cclass\u201d. How can a verifier know whether that word means 1. class, as in school; 2. class, as in category; or 3. class, as in sophistication? Although this might be a silly example, semantic interoperability is one of the most challenging problems to widespread data usefulness. Linked Data helps solve this by providing a format for representing structured data with self-contained descriptors of that data.</p> <p>Linked data is to spreadsheets and databases what the web of hypertext documents is to word processor files.                                                                                                            -\u00a0W3C Wiki on Linked Data</p>"},{"location":"learn/platform/standards/#additional-standards","title":"Additional standards","text":"<p>Revocation List 2020 - This approach allows us to add a simple, interoperable revocation mechanism for credentials. A revocation approach based on cryptographic accumulators is on our roadmap.</p> <p>BBS+ Signatures - A cryptographic signature algorithm based on BLS keys that leads to very small, performant ZKP-enabled credentials. Is on standards stack but is not a standard.</p>"},{"location":"learn/platform/standards/#linked-data_1","title":"Linked Data","text":"<p>When we consider credentials getting exchanged online far and wide, a problem starts to occur - how does everyone know what everyone else means when they show a credential? To the rescue comes Linked Data, a format for representing structured data with self-contained descriptors of that data.</p> <p>\"Linked data is to spreadsheets and databases what the web of hypertext documents is to word processor files\" - W3C Wiki on Linked Data</p>"},{"location":"learn/resources/interactive-api/","title":"Interactive API Experience","text":"<p>In this session, we\u2019ll walk through how to have an interactive experience with the Trinsic API. By following the steps below, you\u2019ll be able to experiment quicker, experience our API\u2019s functionality, and understand how Trinsic Ecosystem works without having to setup any project environment. We\u2019ll teach you how to use two different tools \u2014 Postman and Buf Studio \u2014 which both have an interactive UI for calling the API.</p> <p>But before we make any API calls, the tools mentioned above require you to have an authorization token. You cannot use your authorization token from the Dashboard directly in the API as it is not meant to be transmitted directly with each call. Instead, you should use the token through the SDK, and it will calculate a derivation of your token that you can use. (We use zero-knowledge proofs (ZKPs) to do so\u2014you can learn more in our documentation).</p> <p>Let\u2019s get started with our step-by-step tutorial below.</p>"},{"location":"learn/resources/interactive-api/#how-to-get-the-token-for-authentication","title":"How to get the token for authentication","text":"<p>To get the token for authentication, you\u2019ll need to make API calls. Follow these steps:</p> <ol> <li>Get the Trinsic CLI and ensure it\u2019s properly installed by running <code>trinsic</code> from the command line.</li> <li>Go to your Trinsic Ecosystem Dashboard.</li> <li>Click View API Token and copy your token.</li> </ol> <p></p> <ol> <li>Run <code>trinsic config -a &lt;token&gt;</code>. This will set your token in the config file.</li> </ol> <p></p> <ol> <li>Run <code>trinsic config</code> and make sure your token is set correctly and your server endpoint is set to <code>prod.trinsic.cloud</code>.</li> <li>Run <code>trinsic account info</code> and see if the information matches the ones from your account.</li> <li>Run <code>trinsic \u2014-debug account info</code> and copy the pink text after DEBUG: Authorization. This is the ZKP token for authentication you will use with your calls.</li> </ol> <p>Please note this is a lot longer than in the below screenshot.</p> <p></p>"},{"location":"learn/resources/interactive-api/#postman","title":"Postman","text":""},{"location":"learn/resources/interactive-api/#configuring-postman","title":"Configuring Postman","text":"<p>To configure Postman, follow these steps:</p> <ol> <li>Download Postman and create an account/log in.</li> <li>Click New &gt; gRPC Request.</li> </ol> <p></p> <ol> <li>In the field Enter server URL, add prod.trinsic.cloud:443 and click the padlock to enable TLS.</li> <li>In the tab Metadata, add Authorization in the Key field and your token (the one you generated above) in the Value field.</li> <li>Your page should look like this:</li> </ol> <p></p> <ol> <li>In Postman, you can save these configurations by clicking on the dropdown next to Save and saving the request inside a Collection.</li> </ol>"},{"location":"learn/resources/interactive-api/#making-api-calls","title":"Making API Calls","text":"<p>With your Postman configured, you can now test all API calls from Trinsic\u2019s API.</p> <p>If you click Select a method, you\u2019ll see all available methods.</p> <p></p> <p>Try selecting the option Info and click Invoke. You should see something like this:</p> <p></p> <p>If you run the CredentialTemplates/List method, you should see all your Credential Templates listed in the Response:</p> <p></p> <p>Whenever you call any method, if you have any doubts regarding the fields that appear in the body of the call when you click Generate Example Message (what they should be and if they\u2019re required or not), just consult the Reference tab of our documentation.</p>"},{"location":"learn/resources/interactive-api/#issuing-a-credential","title":"Issuing a Credential","text":"<p>Copy the id value from one of your Credential Templates, and issue a credential from it following the next steps:</p> <ol> <li>Select the method VerifiableCredential/IssueFromTemplate.</li> <li>Click on Generate Example Message.</li> <li>Clear/delete the field <code>framework_id</code>.</li> <li>Paste the template id in the <code>template_id</code> field.</li> <li>Populate the field <code>values_json</code> with the information required by your credential template. Remember to use the character <code>\\</code> before all double quotes.</li> <li>Click on Invoke.</li> </ol> <p></p> <p>You just issued a credential from your credential template! \ud83d\ude04</p>"},{"location":"learn/resources/interactive-api/#using-queries","title":"Using Queries","text":"<p>You can use queries to make searches or get, insert, and update wallets. See the example below:</p> <p></p> <p>Make sure to explore all the methods provided by the Trinsic API! \ud83e\udd29</p>"},{"location":"learn/resources/interactive-api/#buf-studio","title":"Buf Studio","text":""},{"location":"learn/resources/interactive-api/#configuring-buf-studio","title":"Configuring Buf Studio","text":"<p>To configure your Buf Studio, follow these steps:</p> <ol> <li>Access Trinsic Services inside Buf Studio.</li> <li>In the Target field, paste the following URL: https://prod.trinsic.cloud:443</li> <li>In the tab Headers, add Authorization in the Key field and your token (the one you generated above) in the Value field.</li> <li>Click gRPC-web at the end of the page.</li> <li>Your page should look like this:</li> </ol> <p></p>"},{"location":"learn/resources/interactive-api/#making-api-calls_1","title":"Making API Calls","text":"<p>With your Buf Studio configured, you can now test all API calls from Trinsic\u2019s API.</p> <p>If you click Select method, you\u2019ll see all available methods.</p> <p></p> <p>Try selecting the option Info and click Send. You should see something like this:</p> <p></p> <p>If you run the CredentialTemplates/List method, you should see all your Credential Templates listed in the Response:</p> <p></p> <p>Whenever you call any method, if you have any doubts regarding the fields that appear in the body of the call (what they should be and if they\u2019re required or not), just consult the Reference tab of our documentation.</p>"},{"location":"learn/resources/interactive-api/#issuing-a-credential_1","title":"Issuing a Credential","text":"<p>Copy the id value from one of your Credential Templates and issue a credential from it following the next steps:</p> <ol> <li>Select the method VerifiableCredential/IssueFromTemplate.</li> <li>Paste the template id in the <code>templateId</code> field.</li> <li>Populate the field <code>valuesJson</code> with the information required by your credential template. Remember to use the character <code>\\</code> before all double quotes.</li> <li>Click on Send.</li> </ol> <p></p> <p>You just issued a credential from your credential template! \ud83d\ude04</p>"},{"location":"learn/resources/interactive-api/#using-queries_1","title":"Using Queries","text":"<p>You can use queries to make searches or get, insert, and update wallets. See the example below:</p> <p></p> <p>Make sure to explore all the methods provided by the Trinsic API! \ud83e\udd29</p>"},{"location":"learn/resources/migrate-account/","title":"Migration from Account API to Wallet API","text":"<p>This document outlines the code updates you will need to do to migrate from the deprecated Account API to the Wallet API methods. We decided to deprecate the Account API as we felt it didn't warrant it's own API category and mostly created confusion. All methods available in the Account API are also available in the Wallet API, though some naming and parameters have changed.</p>"},{"location":"learn/resources/migrate-account/#accountloginanonymous-moved-to-walletcreatewallet","title":"<code>Account.LoginAnonymous</code> moved to <code>Wallet.CreateWallet</code>","text":"<p>This method is responsble for creating a wallet and returning an auth token that can be used to access this wallet. The updated method also returns all wallet information, such as <code>wallet_id</code>, <code>public_did</code>, etc.</p> <p>API Reference: Wallet API / Create Wallet</p>"},{"location":"learn/resources/migrate-account/#accountlogin-and-accountloginconfirm-core-design-changes","title":"<code>Account.Login</code> and <code>Account.LoginConfirm</code> core design changes","text":"<p>The purpose of the old <code>Login/LoginConfirm</code> methods was to obtain an auth token for an existing wallet using an email as external identity method. If a wallet was not found for this email, one would be automatically created. This design introduced some confusion on when clients should use this method. We decided that it's better to be explicit about the wallet creation process and separate associating it with an external identity, as opposed to having an API that silently creates a wallet.</p> <p>Under the new API, there is an explicit process for each step</p> <ul> <li>Wallet creation using <code>CreateWallet</code></li> <li>Adding external identity using <code>AddExternalIdentity</code> (2-step process with <code>Init</code> and <code>Confirm</code> of OTP token)</li> <li>Authentication to existing wallet using <code>Authenticate</code> (2-step process with <code>Init</code> and <code>Confirm</code> of OTP token)</li> </ul> <p>API References:</p> <ul> <li>Wallet API / Add External Identity</li> <li>Wallet API / Authenticate</li> </ul>"},{"location":"learn/resources/migrate-account/#create-wallet","title":"Create Wallet","text":"<p>This endpoint will create new wallet and return an auth token for accessing the wallet. This endpoint can be called from the client side and the token will be in control of the user. If your integration operates with custodial wallets on behalf of users, you can call this endpoint from your server side. You should ensure that tokens are stored securely.</p> <pre><code>sequenceDiagram\n  autonumber\n  Client-&gt;&gt;API: Request: CreateWallet { Ecosystem=\"example\" }\n  API-&gt;&gt;Client: Response: { AuthToken, WalletID, PublicDID }\n  Client-&gt;&gt;Client: Save [AuthToken] securely\n  Note over Client: [AuthToken] should be stored in a&lt;br/&gt;secure enclave, such as keychain, &lt;br/&gt;secure browser storage, cloud vaults, etc.</code></pre>"},{"location":"learn/resources/migrate-account/#add-external-identity","title":"Add External Identity","text":"<p>This endpoint will associate external identity, such as email or phone number, to an existing wallet and allow the user to obtain an auth token to the wallet they control. If your integration operates with custodial wallets on behalf of users, you will likely not need to use this endpoint.</p> <pre><code>sequenceDiagram\n  autonumber\n  Client-&gt;&gt;Client: Load [AuthToken]\n  Client-&gt;&gt;API: Request: AddExternalIdentityInit { Identity=\"user@example.com\" }\n  API-&gt;&gt;Client: Response: { Challenge }\n  Note over Client: Client checks email or phone number&lt;br/&gt;for OTP confirmation code\n  Client-&gt;&gt;API: Request: AddExternalIdentityConfirm { Challenge, Response(OTP) }\n  API-&gt;&gt;Client: Response: OK</code></pre>"},{"location":"learn/resources/migrate-account/#authenticate","title":"Authenticate","text":"<p>Authenticate and return an auth token for an existing wallet using one of the associated external identities. This endpoint requires that the wallet user has previously added at least one external identity using the above endpoints.</p> <pre><code>sequenceDiagram\n  autonumber\n  Client-&gt;&gt;API: Request: AuthenticateInit { Identity=\"user@example.com\" }\n  API-&gt;&gt;Client: Response: { Challenge }\n  Note over Client: Client checks email or phone number&lt;br/&gt;for OTP confirmation code\n  Client-&gt;&gt;API: Request: AuthenticateConfirm { Challenge, Response(OTP) }\n  API-&gt;&gt;Client: Response: { AuthToken, WalletID, PublicDID }\n  Client-&gt;&gt;Client: Save [AuthToken] securely\n  Note over Client: [AuthToken] should be stored in a&lt;br/&gt;secure enclave, such as keychain, &lt;br/&gt;secure browser storage, cloud vaults, etc.</code></pre>"},{"location":"learn/resources/migrate-account/#accountinfo-moved-to-walletgetmyinfo-and-walletgetwalletinfo","title":"<code>Account.Info</code> moved to <code>Wallet.GetMyInfo</code> and <code>Wallet.GetWalletInfo</code>","text":"<p>The new API contains two methods for getting the wallet information</p> <ul> <li><code>Wallet.GetMyInfo</code> \u2014 takes no parameters; this endpoint can be called by the wallet owner to get the information about their wallet (such as walletId, public DID, etc)</li> <li><code>Wallet.GetWalletInfo</code> \u2014 takes <code>walletId</code> parameter; this endpoint can be called by the provider to get wallet information for the specified walletId. This endpoint requires auth token with provider level privileges. You can obtain this token from the Trinsic Dashboard </li> </ul>"},{"location":"learn/resources/migrate-account/#need-help","title":"Need help?","text":"<p>Please reach out if you have any questions regarding the migration to the new endpoint; we're happy to help make your transition easy.</p>"},{"location":"learn/resources/migrate/","title":"Migration Guidelines","text":"<p>This document outlines the differences between our existing platform based on Hyperledger Aries and our next-gen identity infrastructure known as Ecosystems. The intended audience of this document is technical business decision makers or solution architects who are looking to migrate their existing integration. For everyone else, this can also be a good source of information with comparsion between the two platforms. Please feel free to reach out to us or ask any questions in our Slack Community channels.</p>"},{"location":"learn/resources/migrate/#motivations-to-build-the-new-platform","title":"Motivations to build the new platform","text":"<p>Open standards and protocols \u2014 One of the critical decisions to create our new platform was the ability to use standardized data models. The Verifiable Credentials Data Model was an important milestone that standardized the data exchange format. The use of Decentralized Identifiers was another important step in building solutions that will work with community supported specifications. The tight coupling of Anoncreds with the wallet, communication, and ledger layers proved to be very challenging to iterate on. While projects like Anoncreds and DIDComm that started in Indy are now on a standards track, the success of our customers in production required prioritizing existing W3C, OIDC, and other standards first.</p> <p>Cryptographic suites performance and extensibility \u2014 To provide developers the best experience possible, we needed to be able to introduce different cryptographic schemes with a standardized model in order to support different data workflows. The Data Integrity and JOSE proof formats work well with the VC model and allow extensibility and use of different cryptographic suites.</p> <p>Scalability concerns and technology lock-in \u2014 Through rigorous testing, including with customers in production, we encountered concerning scalability issues with ledger throughput for Indy Node and the indy-sdk. The complexity introduced by requiring certain artifacts to be written to a specific ledger exasperated the problem. In addition, the inflexibility of the architecture of the open source implementations made it difficult to extend our platform or build customized experiences, and we found the efforts by the open source community to address these problems lacking.</p> <p>Ledger costs and transaction fees \u2014 The high costs to write data to production Indy ledgers, and the difficulty in forecasting those costs, was a significant barrier for many developers going to production. In addition, we found the centralized governance of existing production Indy ledgers to result in \"rug-pulls\", \"single points of failure\", and sustainability concerns that introduced additional risks for developers in building a business on those networks.</p> <p>Customized wallet experience \u2014 The developers in our community consistently wanted something the Aries-based platform couldn't provide--a platform for building a customized wallet experience for their end-users, whether in a standalone wallet product or embedded into an existing product. Strong wallet products need features like cross-device synchronization, multi-language SDK support, small SDK size, offline support, all while keeping the highest security standards. See our documentation on Wallets for more.</p>"},{"location":"learn/resources/migrate/#who-should-consider-migration","title":"Who should consider migration?","text":"<ul> <li>Teams looking to manage their own identity data in the ecosystem</li> <li>Your solution requires support for ecosystem governance</li> <li>You are looking to use open standard and need interoperability with VC, JWT, or OIDC</li> <li>Teams looking to reduce transaction costs of writing to decentralized ledgers</li> <li>Developers looking to provide custom wallet experience or customized integration</li> </ul>"},{"location":"learn/resources/migrate/#concepts-comparison","title":"Concepts Comparison","text":"<p>Direct comparsions of technical details between the two platforms may be enclosed in colored blocks as shown below:</p> <p>Description of concepts as found in our existing platform</p> <p>Description of concepts as found in our new platform</p> <p>Let's take a deeper look of how different problems and concepts map between the existing and new platform.</p> <ul> <li>Migration Guidelines</li> <li>Motivations to build the new platform</li> <li>Who should consider migration?</li> <li>Concepts Comparison<ul> <li>Organizations and Tenants</li> <li>Identity Wallets</li> <li>Ledgers and Decentralized Infrastructure</li> <li>Credential Formats</li> <li>Anoncreds vs BBS</li> <li>Revocation Registries</li> <li>Verification Workflows</li> <li>What's next?</li> </ul> </li> </ul>"},{"location":"learn/resources/migrate/#organizations-and-tenants","title":"Organizations and Tenants","text":"<p>The concept of an organization (or tenant) as a top level scope of identity network is now represented as a more expanded concept of an ecosystem. Ecosystems represent your enterprise network as an established model of relationships between different entities. Providers define the contracts of how verifiable data can be exchanged and governed in an ecosystem. Individual holders of credentials will be assigned a wallet within the scope of an ecosystem.</p> <p>Managed through Provider API endpoints</p> <p>Managed through Provider Service SDK</p>"},{"location":"learn/resources/migrate/#identity-wallets","title":"Identity Wallets","text":"<p>In our existing platform, our customers needed to choose between requiring end-users to download a standalone wallet to self-manage their credentials and keys on their mobile device, or use our Wallet API to create a purely custodial service. The former had the security advantage of all private material being stored on the user's device, but comes with the cost of backup &amp; recovery questions, inability to access data from secondary devices/browers, and difficulty embedding into existing applications. The latter afforded a fantastic developer experience (indeed, 95% of developers chose this option to ship products quickly) but introduced a less-than-ideal security profile, and was inaccessible in an offline setting.</p> <p>Our new platform uses hyrbid wallets with cloud-hosted credential storage and edge-managed access security through our SDK. Wallet data is accessed through our new API which allows developers to take advantage of a great experience building their own wallet-enabled products as a web app, mobile app, etc.  without compromising on security or offline usage. Custodial wallets also allow us to support more standards and interoperability profiles, leading to better products for our customers.</p> <p>Future considerations</p> <p>We are actively working to improve the features of our hybrid wallet experience with things like encrypted query/search and the ability to export wallet data to remove lock-in for users.</p>"},{"location":"learn/resources/migrate/#ledgers-and-decentralized-infrastructure","title":"Ledgers and Decentralized Infrastructure","text":"<p>Our existing platform uses decentralized ledgers based on Indy Node to store credential artifacts in a public network. These artifacts include DIDs, Schemas, Credential Definitions and Revocation Registries. The instances of Indy networks we supported includes Sovrin, Indicio and BCovrin, for production and test workloads.</p> <p>The new platform uses decentralized ledgers or blockchains for DIDs only. Schemas and revocation registries use web infrastructure and are published at a well known URL address. The need for credential definitions is removed thanks to improved credential signature schemes. The new platform is built independent of a single network, thus being truly ledger agnostic. Currently supported networks for DIDs are Bitcoin (using layer 2 protocol Sidetree), Indy, EBSI, with more to come.</p> <ul> <li>Indy Node based</li> <li>Supported networks: Sovrin, Indicio, BCovrin</li> </ul> <ul> <li>Self-asserting identifiers</li> <li>Bitcoin layer 2 using Sidetree</li> <li>Indy Node based</li> <li>EBSI</li> </ul>"},{"location":"learn/resources/migrate/#credential-formats","title":"Credential Formats","text":"<p>Credential formats were generally represented as a collection of attributes defined with a schema and version. The schemas were represented with a schema ID like <code>Gs6cQcvrtWoZKsbBhD3dQJ:2:Certificate of Attendance:2.0</code>. This schema contains attributes and is associated with a transaction on the ledger. The flat schemas do not support any heirarchy, severely limiting the use cases they are suited for.</p> <p>Under the new model, schemas are part of a credential template and are represented as a standard JSON schema where each attribute can be defined with a specific data type and extended properties. Additionally, templates reference a JSON-LD vocabulary which adds semantic definition of each attribute under the Linked Data guidelines. This vocabulary is used during the process of issuance and verification of credentials, technically known as data canonicalization. The schemas are not written on a ledger, they are instead published as a web resource with a static URL.</p> <ul> <li>Schemas are represented as JSON array of attribute names</li> </ul> <pre><code>{\n\"name\": \"Identity Card\",\n\"version\": \"1.0\",\n\"attr_names\": [\n\"firstName\",\n\"lastName\",\n\"dateOfBirth\"\n]\n}\n</code></pre> <ul> <li>Credential definitions are required and their value must be written on the ledger</li> <li>Data structure supports flat hierarchy</li> <li>Schema ID is identifier <code>Gs6cQcvrtWoZKsbBhD3dQJ:2:Certificate of Attendance:2.0</code></li> </ul> <ul> <li>Schemas are JSON objects</li> </ul> <pre><code>{\n\"id\": \"https://schema.trinsic.cloud/default/identity-card\",\n\"properties\": {\n\"firstName\": { \"type\": \"string\", \"description\": \"First or given name\" },\n\"lastName\": { \"type\": \"string\", \"description\": \"Last or family name\" },\n\"dateOfBirth\": { \"type\": \"datetime\", \"description\": \"Date of birth\" },\n}\n}\n</code></pre> <ul> <li>No credential definition required</li> <li>Data structure can be any complex JSON graph</li> <li>Schema ID is URL <code>https://schema.trinsic.cloud/default/identity-card</code></li> </ul>"},{"location":"learn/resources/migrate/#anoncreds-vs-bbs","title":"Anoncreds vs BBS","text":"<p>Our existing platform uses the cryptographic suite Anoncreds to provide different credential exchange solutions. In our new platform, we introduced BBS signatures, as a replacement for Anoncreds. The main motivating factors for this are:</p> <ul> <li>Standardized data models for the signature suites using JSON Schema and Verifiable Credentials</li> <li>Fast and small signature size (cryptographic signatures based on pairing-friendly curves)</li> <li>No setup required (Anoncreds require creating credential definition which is very slow and requires ledger write)</li> <li>Flexible proof format (Data Integrity, JOSE)</li> </ul>"},{"location":"learn/resources/migrate/#revocation-registries","title":"Revocation Registries","text":"<p>Revocation in our existing platform uses Anoncreds with RSA accumulator. This is a powerful, privacy preserving solution, but cumbersome when it comes to maintaining accumulator states. It requires publishing revocation registry state on the ledger, writing to the ledger whenever credentials are revoked, publishing a tails file on a web resource, and layering workarounds on top to make it all scalable. Even after all of this, the performance of holders creating non-revocation proofs was below an acceptable level for production use.</p> <p>Our new platform uses a more flexible solution based on Status List. This approach is based on a W3C community published specification with a much simpler and flexible approach to revocation, albeit without the same privacy guarantees.</p> <p>Future considerations</p> <p>At the time of writing this article, we are actively looking to add support for additional revocation solutions, such as one based on accumulators for pairing-friendly curves. These are significant improvements over RSA accumulators with an improvement in data privacy, performance and scalability.</p>"},{"location":"learn/resources/migrate/#verification-workflows","title":"Verification Workflows","text":"<p>In our existing platform we use Aries protocols to exchange data between two parties. To verify a credential, the verifier must prepare a verification request and communicate this to the user via URL (or QR code). The holder then resolves the URL (or scans the code) to respond to the request, most often through use of a mobile app.</p> <p>Our new platform is intended to support a broader set of verification options for developers, including widely-adopted protocols such as OpenID Connect. Today we support an interactive protocol based on OpenID for Verifiable Presentations (OIDC4VP). During verification, the holder is redirected to Trinsic's OIDC provider (which can be customized on a per-ecosystem basis) which allows the user access to their identity wallet to respond to the verification request. We'll continue to support additional verification protocols as they're needed by our customers to succeed in production.</p> <p>An example verification request payload</p> <pre><code>{\n\"name\": \"verification-request\",\n\"version\": \"1.0\",\n\"attributes\": [{\n\"policyName\": \"verify-name\",\n\"attributeNames\": [ \"firstName\" ],\n\"restrictions\": [{\n\"issuerID\": \"string\"\n}]\n}],\n\"predicates\": [],\n\"revocationRequirement\": {\n\"validNow\": true\n}\n}\n</code></pre> <p>Example OIDC request for verifiable presentation</p> <pre><code>GET https://connect.trinsic.cloud/authorize?\n    &amp;response_type=code\n    &amp;scope=openid\n    &amp;client_id=client01\n    &amp;trinsic%3Aecosystem=example\n    &amp;redirect_uri=https://example.com/callback\n    &amp;nonce=n-0S6_WzA2Mj HTTP/1.1\n</code></pre>"},{"location":"learn/resources/migrate/#whats-next","title":"What's next?","text":"<p>If you're looking to do a migration and need help, please drop us a line on Slack or Intercom. Otherwise, feel free to explore our documentation, try the Getting Started guide or watch an introductory video.</p>"},{"location":"node/","title":"The Trinsic Javascript / Typescript Node SDK","text":"<p>The Trinsic Node/Web SDK makes it easy to interact with the Trinsic API from any backend javascript application. The most recent version of the library can be found on npm. You can find the SDKs source on Github. The @trinsic/trinsic package comes with Typescript bindings.</p>"},{"location":"node/#installation","title":"Installation","text":"<p>Install the package for Node from npmjs.com </p> Install <pre><code>npm i @trinsic/trinsic\n</code></pre>"},{"location":"node/#javascript","title":"Javascript","text":"<p>To import the Trinsic SDK: <pre><code>import { TrinsicService } from \"@trinsic/trinsic\";\n</code></pre></p> <p>For CommonJS: <pre><code>let { TrinsicService } = require(\"@trinsic/trinsic\");\n</code></pre></p> <p>You must instantiate the trinsic service first: <pre><code>const trinsicService = new TrinsicService({\n/** Trinsic API endpoint. Defaults to `prod.trinsic.cloud` */\nserverEndpoint: \"prod.trinsic.cloud\",\n/** Trinsic API port; defaults to `443` */\nserverPort: 443,\n/** Whether TLS is enabled between SDK and Trinsic API; defaults to `true` */\nserverUseTls: true,\n/** Authentication token for SDK calls; defaults to empty string (unauthenticated) */\nauthToken: \"&lt;Your auth token&gt;\"\n});\n</code></pre></p> <p>Now you can use the SDK: <pre><code>const newWallet = await trinsicService.wallet().createWallet();\nconsole.log(JSON.stringify(newWallet, null, 4));\n</code></pre></p> <p>You can find all the SDK methods documented here</p>"},{"location":"python/","title":"The Trinsic Python SDK","text":"<p>The Trinsic Python SDK makes it easy to interact with the Trinsic API from any Python application. The most recent version of the library can be found on PyPi. You can find the SDKs source on Github. Sample applications are located on Github</p>"},{"location":"python/#installation-and-configuration","title":"Installation and Configuration","text":"<ul> <li>Recommended: Create a virtual environment</li> <li>Install the trinsic package <pre><code>pip install trinsic-sdk\n</code></pre></li> <li> <p>Test installation by running the following shell command: <pre><code># May be \"python\" or \"python3\" depending on your install\npython -m trinsic\n</code></pre></p> </li> <li> <p>The output should look something like this: <pre><code>Package successfully installed. Sample profile below\n</code></pre></p> </li> </ul>"},{"location":"reference/","title":"Overview","text":"<p>This section serves as the reference for the Trinsic API, which can be accessed using any of our SDKs.</p>"},{"location":"reference/#authentication","title":"Authentication","text":"<p>Authentication with the Trinsic platform uses auth tokens, which are strings that operate similarly to API keys. You can get an auth token from the Dashboard.</p>"},{"location":"reference/#using-auth-tokens-in-the-sdk","title":"Using Auth Tokens in the SDK","text":"<p>Tokens are passed to the SDK during service instantiation as part of the <code>TrinsicOptions</code>.</p>"},{"location":"reference/#services","title":"Services","text":"<p>Our SDK is broken down into the following logical APIs, each of which is accessible through a single <code>TrinsicService</code> instance:</p> <ul> <li>Credential API</li> <li>Provider API</li> <li>Template API</li> <li>Trust Registry API</li> <li>Wallet API</li> </ul>"},{"location":"reference/#using-an-sdk-service","title":"Using an SDK Service","text":"<p>If you are using one of the Trinsic SDKs, you will need to create an instance of a <code>TrinsicService</code> in order to use it.</p> TypeScriptC#PythonGoJava <pre><code>using Trinsic;\n\nvar trinsic = new TrinsicService();\n// or instantiate with auth token\n// var trinsic = new TrinsicService(new TrinsicOptions { AuthToken = \"&lt;auth token&gt;\" });\n</code></pre> <pre><code>trinsic_service = TrinsicService(server_config=trinsic_config())\n</code></pre> <pre><code>trinsic, err := NewTrinsic(WithTestEnv())\nassert2.Nil(err)\n</code></pre> <pre><code>var serverConfig = TrinsicUtilities.getTrinsicTrinsicOptions();\nvar trinsic = new TrinsicService(serverConfig);\n</code></pre> <p>The constructor accepts a ServiceOptions object as an argument, allowing you to specify a default ecosystem and other configuration properties:</p> <p>Cannot print proto message: Cannot find protobuf object with name sdk.options.v1.ServiceOptions</p> <p>The exact structure of this object will depend on the language you are working with. You can always rely on your editor's intellisense when in doubt.</p>"},{"location":"reference/other/openid/","title":"OpenID Credential Exchange Service","text":""},{"location":"reference/other/openid/#overview","title":"Overview","text":"<p>Trinsic provides an OpenID Connect  (\"OIDC\") service which enables verifiers to request credentials from a user's cloud wallet in a simple and secure way.</p> <p>This service does not require the use of Trinsic's SDKs in the user's browser, and is therefore lightweight and easy to integrate.</p> <p>Credential Issuance</p> <p>Currently, Trinsic's OpenID Connect service only enables the sharing of a credential between holder and verifier. We plan to support issuance through this service at a later date.</p> <p>In the meantime, use the InsertItem or Send methods to store credentials in a holder's wallet.</p>"},{"location":"reference/other/openid/#integration","title":"Integration","text":""},{"location":"reference/other/openid/#openid-connect-protocol","title":"OpenID Connect Protocol","text":"<p>Because this is an OpenID Connect service, any compliant library may be used -- as long as it enables you to specify additional custom query parameters on the initial outbound URL.</p> <p>OIDC Flow Implementation</p> <p>The specifics of the OpenID Connect protocol -- and how to implement it -- are out of scope for this documentation.</p> <p>If you would like to see an example implementation of a verification flow against this service, see the sample below.</p>"},{"location":"reference/other/openid/#configuration","title":"Configuration","text":"<p>Configure your OIDC library with the following parameters:</p> Parameter Description General Parameters <code>authority</code> <code>https://connect.trinsic.cloud</code> <code>response_type</code> <code>code</code> <code>scope</code> <code>openid</code> <code>client_id</code> Any string which uniquely represents your client application <code>redirect_uri</code> The URI your user should be redirected to once they have completed (or canceled) the flow <code>nonce</code> (Optional) Random nonce value that will be used to bind the generated presentation to the issued token. If not specified, one will be randomly generated. Use this to prevent presentation replays. Trinsic-Specific Parameters <code>trinsic:ecosystem</code> ID of ecosystem user wallet resides in <code>trinsic:schema</code> (Optional) Comma-separated listed of Schema URLs. Only credentials which match one of these schemas will be returned. <code>trinsic:issuer</code> (Optional) Comma-separated list of Issuer DIDs. Only credentials issued by one of these issuers will be returned. <code>trinsic:egf</code> (Optional) Comma-separated list of Entity Governance Framework IDs. Only credentials bound to one of these EGF IDs will be returned. <code>trinsic:mode</code> (Optional) Can be <code>redirect</code> (default), <code>popup</code>, or <code>silent</code>."},{"location":"reference/other/openid/#presentation-replays-and-id-tokens","title":"Presentation Replays and ID Tokens","text":"<p>In order to prevent verifiable presentation replays, always specify the <code>nonce</code> parameter in the initial call to the authorization endpoint. This will ensure that the generated presentation and the ID token match the current request.</p>"},{"location":"reference/other/openid/#response-data","title":"Response Data","text":"<p>Once the user has returned to your redirect URL, exchange the authorization code (added to your redirect URI as a query parameter named <code>code</code>) for an identity token using your OIDC library.</p> <p>You will receive a JSON object of the following form:</p> Response JSON<pre><code>{\n\"id_token\": \"{JWT containing same data as vp_token}\",\n\"access_token\":\"invalid\",\n\"token_type\":\"Bearer\",\n\"vp_token\":{\n\"@context\":[\n\"https://www.w3.org/2018/credentials/v1\",\n\"https://w3id.org/bbs/v1\",\n...\n],\n\"id\":\"{UUID of Holder Wallet}\",\n\"type\":[\n...,\n\"VerifiableCredential\"\n],\n\"credentialSchema\":{\n...\n},\n\"credentialStatus\":{\n...\n},\n\"credentialSubject\":{\n...\n},\n\"issuanceDate\":\"{Issue date of credential}\",\n\"issuer\":\"{DID of Issuer}\",\n\"proof\":{\n...\n}\n}\n}\n</code></pre> <p>Credential Format</p> <p>Note that the above data has been modified for brevity.</p> <p>The <code>@context</code> and <code>type</code> arrays will contain additional entries which are specific to the credential.</p>"},{"location":"reference/other/openid/#verify-the-received-proof","title":"Verify the Received Proof","text":"<p><code>vp_token</code> is a Verifiable Proof; before making use of its data, you must verify it.</p> <p>This proof can be verified with any library that supports VC verifications for BBS+ signatures. It can also be verified using Trinsic's SDK; this is as simple as passing the proof to the VerifyProof call.</p> <p>If you specified a <code>nonce</code> in the authorization request, always verify that the <code>nonce</code> claim in the JWT ID token matches the similarly named value in the <code>_vp_token</code> document. You may find the nonce in the <code>_vp_token.proof.nonce</code> path in the JSON structure. Note that the value in this proof may be specified in base64 format, so you may need to reformat your nonce before comparing. If you specified the nonce as base64 in the request, the two values should match with direct string comparison.</p> <p>Always Verify</p> <p>It may be tempting to simply take the data in <code>vp_token</code> and act upon it without first verifying the proof.</p> <p>Always verify the proof before making use of its data.</p> <p>Without verification, the received proof is of no more value than an unsubstantiated claim made by your user.</p>"},{"location":"reference/other/openid/#displaying-linked-data-in-credentials","title":"Displaying Linked Data in Credentials","text":"<p>SDK Only</p> <p>The following section presently only applies when using our SDK to create a Template; our Dashboard does not yet support the ability to specify field annotations.</p> <p>Some credential template fields may be intended for URLs which resolve to images or any other data which cannot be directly embedded in a credential. For example, you may wish to include a URL to an image of a physical credential in its digital representation.</p> <p>By default, these will display to the holders in the OIDC flow as simple text fields containing the raw URL. However, the template can be configured to display these URLs as either inline embedded images, or convenient links to download the linked data.</p> <p>When creating or updating a Template:</p> <ul> <li>Choose the <code>URI</code> type for any Fields which are intended to contain URIs.</li> <li>Configure the <code>UriData</code> object on the Field</li> <li>Set the <code>RenderMethod</code> property<ul> <li>If the field is intended to contain an image, use the value <code>INLINE_IMAGE</code>.</li> <li>Otherwise, use <code>LINK</code> for a clickable link, or <code>TEXT</code> to display the URI in raw form.</li> </ul> </li> <li>Set the <code>MimeType</code> property<ul> <li>Use the value <code>image</code> if the field is intended to contain a link to an image</li> <li>Otherwise, the value should be the expected MIME Type of the data<ul> <li>If you are unsure, use <code>application/octet-stream</code> as a catch-all</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/other/openid/#sample","title":"Sample","text":"<p>We've prepared a sample demonstrating client-side OIDC Verification.</p> <ul> <li> <p> Sample Source</p> <p>The source for this sample is available on GitHub</p> </li> </ul>"},{"location":"reference/other/openid/#oidc-libraries","title":"OIDC Libraries","text":"<p>Libraries exist enabling OIDC functionality for all major languages.</p> <p>The OpenID Connect website lists a number of certified libraries; we've included links to some of these below.</p> <ul> <li> TypeScript/JavaScript</li> <li> Python</li> <li> C#</li> <li> Go</li> <li> Java</li> <li> Ruby</li> </ul>"},{"location":"reference/proto/","title":"Protocol Documentation","text":"<p>This page documents the Protobuf Services and Messages which compose the Trinsic API.</p> <p></p> <p>Top</p>"},{"location":"reference/proto/#sdkoptionsv1optionsproto","title":"sdk/options/v1/options.proto","text":""},{"location":"reference/proto/#trinsicoptions","title":"TrinsicOptions","text":"<p>Configuration for Trinsic SDK Services</p> Field Type Description server_endpoint string Trinsic API endpoint. Defaults to <code>prod.trinsic.cloud</code> server_port int32 Trinsic API port; defaults to <code>443</code> server_use_tls bool Whether TLS is enabled between SDK and Trinsic API; defaults to <code>true</code> auth_token string Authentication token for SDK calls; defaults to empty string (unauthenticated) <p>Default ecosystem ID to use for various SDK calls; defaults to <code>default</code> string default_ecosystem = 5; |</p> <p></p> <p>Top</p>"},{"location":"reference/proto/#servicesfile-managementv1file-managementproto","title":"services/file-management/v1/file-management.proto","text":""},{"location":"reference/proto/#service-filemanagement","title":"Service - FileManagement","text":"Method Name Request Type Response Type Description UploadFile UploadFileRequest UploadFileResponse Upload a file to Trinsic's CDN GetFile GetFileRequest GetFileResponse Fetch information about a file by its ID DeleteFile DeleteFileRequest DeleteFileResponse Delete a file by its ID ListFiles ListFilesRequest ListFilesResponse List files the calling account has uploaded GetStorageStats GetStorageStatsRequest GetStorageStatsResponse Get statistics about files uploaded by the calling account"},{"location":"reference/proto/#deletefilerequest","title":"DeleteFileRequest","text":"<p>Request to delete a file from Trinsic's CDN by ID</p> Field Type Description id string ID of file to delete <p></p>"},{"location":"reference/proto/#deletefileresponse","title":"DeleteFileResponse","text":"<p>Response to <code>DeleteFileRequest</code>. Empty payload.</p> <p></p>"},{"location":"reference/proto/#file","title":"File","text":"<p>Contains information about a file stored in Trinsic's CDN</p> Field Type Description id string ID of file, generated randomly by Trinsic on upload uploader_id string Wallet ID of uploader size uint32 Size, in bytes, of file mime_type string Uploader-provided MIME type of file uploaded string ISO 8601 timestamp of when file was uploaded to Trinsic url string CDN URL of file <p></p>"},{"location":"reference/proto/#getfilerequest","title":"GetFileRequest","text":"<p>Request to fetch information about a stored file</p> Field Type Description id string ID of file to fetch <p></p>"},{"location":"reference/proto/#getfileresponse","title":"GetFileResponse","text":"<p>Response to <code>GetFileRequest</code></p> Field Type Description file File File specified by <code>id</code> parameter of <code>GetFileRequest</code>. <p></p>"},{"location":"reference/proto/#getstoragestatsrequest","title":"GetStorageStatsRequest","text":"<p>Request to get statistics about files uploaded by this account</p> <p></p>"},{"location":"reference/proto/#getstoragestatsresponse","title":"GetStorageStatsResponse","text":"<p>Response to <code>GetStorageStatsRequest</code></p> Field Type Description stats StorageStats Statistics about files uploaded by the calling account <p></p>"},{"location":"reference/proto/#listfilesrequest","title":"ListFilesRequest","text":"<p>Request to list files</p> Field Type Description query string Query to search with. If not specified, will return the most recent 100 files. continuation_token string Token provided by previous <code>ListFilesRequest</code> if more data is available for query <p></p>"},{"location":"reference/proto/#listfilesresponse","title":"ListFilesResponse","text":"<p>Response to <code>ListFilesRequest</code></p> Field Type Description files File[] Files found by query has_more_results bool Whether more results are available for this query via <code>continuation_token</code> continuation_token string Token to fetch next set of results via <code>ListFilesRequest</code> <p></p>"},{"location":"reference/proto/#storagestats","title":"StorageStats","text":"<p>Represents aggregate statistics of all files uploaded by a single issuer</p> Field Type Description num_files uint32 Number of files uploaded by this account total_size uint64 Sum total size of all files, in bytes <p></p>"},{"location":"reference/proto/#uploadfilerequest","title":"UploadFileRequest","text":"<p>Request to upload a file to Trinsic's CDN</p> Field Type Description contents bytes Raw content of file mime_type string MIME type describing file contents <p></p>"},{"location":"reference/proto/#uploadfileresponse","title":"UploadFileResponse","text":"<p>Response to <code>UploadFileRequest</code></p> Field Type Description uploaded_file File Information about newly-uploaded file <p></p> <p>Top</p>"},{"location":"reference/proto/#servicesaccountv1accountproto","title":"services/account/v1/account.proto","text":""},{"location":"reference/proto/#service-account","title":"Service - Account","text":"Method Name Request Type Response Type Description SignIn SignInRequest SignInResponse Sign in to an already existing account Login LoginRequest LoginResponse Begin login flow for specified account, creating one if it does not already exist LoginConfirm LoginConfirmRequest LoginConfirmResponse Finalize login flow with two-factor confirmation code Info AccountInfoRequest AccountInfoResponse Get account information"},{"location":"reference/proto/#accountdetails","title":"AccountDetails","text":"<p>Account registration details</p> Field Type Description name string Account name email string Deprecated. Email address of account. sms string Deprecated. SMS number including country code <p></p>"},{"location":"reference/proto/#accountinforequest","title":"AccountInfoRequest","text":"<p>Request for information about the account used to make the request</p> <p></p>"},{"location":"reference/proto/#accountinforesponse","title":"AccountInfoResponse","text":"<p>Information about the account used to make the request</p> Field Type Description details AccountDetails The account details associated with the calling request context wallet_id string The wallet ID associated with this account device_id string The device ID associated with this account session ecosystem_id string The ecosystem ID within which this account resides public_did string The public DID associated with this account. This DID is used as the <code>issuer</code> when signing verifiable credentials auth_tokens WalletAuthToken[] List of active authentication tokens for this wallet. This list does not contain the issued token, only metadata such as ID, description, and creation date. <p></p>"},{"location":"reference/proto/#accountprofile","title":"AccountProfile","text":"<p>Device profile containing sensitive authentication data. This information should be stored securely</p> Field Type Description profile_type string The type of profile, used to differentiate between protocol schemes or versions auth_data bytes Auth data containg information about the current device access auth_token bytes Secure token issued by server used to generate zero-knowledge proofs protection TokenProtection Token security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication. <p></p>"},{"location":"reference/proto/#loginconfirmrequest","title":"LoginConfirmRequest","text":"<p>Request to finalize login flow</p> Field Type Description challenge bytes Challenge received from <code>Login</code> confirmation_code_hashed bytes Two-factor confirmation code sent to account email or phone, hashed using Blake3. Our SDKs will handle this hashing process for you. <p></p>"},{"location":"reference/proto/#loginconfirmresponse","title":"LoginConfirmResponse","text":"<p>Response to <code>LoginConfirmRequest</code></p> Field Type Description profile AccountProfile Profile response; must be unprotected using unhashed confirmation code. Our SDKs will handle this process for you, and return to you an authentication token string. <p></p>"},{"location":"reference/proto/#loginrequest","title":"LoginRequest","text":"<p>Request to begin login flow</p> Field Type Description email string Email address of account. If unspecified, an anonymous account will be created. ecosystem_id string ID of Ecosystem to sign into. <p></p>"},{"location":"reference/proto/#loginresponse","title":"LoginResponse","text":"<p>Response to <code>LoginRequest</code></p> Field Type Description challenge bytes Random byte sequence unique to this login request. If present, two-factor confirmation of login is required. Must be sent back, unaltered, in <code>LoginConfirm</code>. profile AccountProfile Account profile response. If present, no confirmation of login is required. <p></p>"},{"location":"reference/proto/#signinrequest","title":"SignInRequest","text":"<p>Request for creating or signing into an account</p> Field Type Description details AccountDetails Account registration details ecosystem_id string ID of Ecosystem to use Ignored if <code>invitation_code</code> is passed <p></p>"},{"location":"reference/proto/#signinresponse","title":"SignInResponse","text":"<p>Response for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc.</p> Field Type Description confirmation_method ConfirmationMethod Indicates if confirmation of account is required. profile AccountProfile Contains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data. <p></p>"},{"location":"reference/proto/#tokenprotection","title":"TokenProtection","text":"<p>Token protection info</p> Field Type Description enabled bool Indicates if token is protected using a PIN, security code, HSM secret, etc. method ConfirmationMethod The method used to protect the token <p></p>"},{"location":"reference/proto/#walletauthtoken","title":"WalletAuthToken","text":"<p>Information about authentication tokens for a wallet</p> Field Type Description id string Unique identifier for the token. This field will match the <code>DeviceId</code> in the WalletAuthData description string Device name/description date_created string Date when the token was created in ISO 8601 format <p></p>"},{"location":"reference/proto/#confirmationmethod","title":"ConfirmationMethod","text":"<p>Confirmation method type for two-factor workflows</p> Name Number Description None 0 No confirmation required Email 1 Email confirmation required Sms 2 SMS confirmation required ConnectedDevice 3 Confirmation from a connected device is required Other 10 Third-party method of confirmation is required <p></p> <p>Top</p>"},{"location":"reference/proto/#servicesoptionsfield-optionsproto","title":"services/options/field-options.proto","text":""},{"location":"reference/proto/#annotationoption","title":"AnnotationOption","text":"Field Type Description active bool Is this annotation active message string Custom annotation message to provide"},{"location":"reference/proto/#sdktemplateoption","title":"SdkTemplateOption","text":"Field Type Description anonymous bool Whether the service endpoint allows anonymous (no auth token necessary) authentication This is used by the <code>protoc-gen-trinsic-sdk</code> plugin for metadata. ignore bool Whether the SDK template generator should ignore this method. This method will be wrapped manually. no_arguments bool Whether the SDK template generator should generate this method without arguments, eg ProviderService.GetEcosystemInfo() where the request object is empty experimental AnnotationOption This endpoint is experimental. Consider it in beta, so documentation may be incomplete or incorrect. deprecated AnnotationOption This endpoint is deprecated. It will be removed in the future."},{"location":"reference/proto/#file-level-extensions","title":"File-level Extensions","text":"Extension Type Base Number Description optional bool .google.protobuf.FieldOptions 60000 Whether field is optional in Trinsic's backend. This is not the same as an <code>optional</code> protobuf label; it only impacts documentation generation for the field. sdk_template_option SdkTemplateOption .google.protobuf.MethodOptions 60001 <p>Top</p>"},{"location":"reference/proto/#servicesverifiable-credentialsv1verifiable-credentialsproto","title":"services/verifiable-credentials/v1/verifiable-credentials.proto","text":""},{"location":"reference/proto/#service-verifiablecredential","title":"Service - VerifiableCredential","text":"Method Name Request Type Response Type Description IssueFromTemplate IssueFromTemplateRequest IssueFromTemplateResponse Sign and issue a verifiable credential from a pre-defined template. This process will also add schema validation and revocation registry values to the credential. CheckStatus CheckStatusRequest CheckStatusResponse Check credential status in the revocation registry UpdateStatus UpdateStatusRequest UpdateStatusResponse Update credential status by setting the revocation value CreateProof CreateProofRequest CreateProofResponse Create a proof from a signed document that is a valid verifiable credential and contains a signature from which a proof can be derived. VerifyProof VerifyProofRequest VerifyProofResponse Verifies a proof by checking the signature value, and if possible schema validation, revocation status, and issuer status against a trust registry Send SendRequest SendResponse Sends a document directly to a user's email within the given ecosystem CreateCredentialOffer CreateCredentialOfferRequest CreateCredentialOfferResponse Create credential offer AcceptCredential AcceptCredentialRequest AcceptCredentialResponse Accept an offer to exchange a credential RejectCredential RejectCredentialRequest RejectCredentialResponse Reject an offer to exchange a credential"},{"location":"reference/proto/#acceptcredentialrequest","title":"AcceptCredentialRequest","text":"Field Type Description document_json string The JSON document that contains the credential offer item_id string The ID of the item in the wallet that contains the credential offer"},{"location":"reference/proto/#acceptcredentialresponse","title":"AcceptCredentialResponse","text":"Field Type Description item_id string The ID of the item in the wallet that contains the issued credential document_json string The JSON document that contains the issued credential. This item is already stored in the wallet."},{"location":"reference/proto/#checkstatusrequest","title":"CheckStatusRequest","text":"<p>Request to check a credential's revocation status</p> Field Type Description credential_status_id string Credential Status ID to check. This is not the same as the credential's ID. <p></p>"},{"location":"reference/proto/#checkstatusresponse","title":"CheckStatusResponse","text":"<p>Response to <code>CheckStatusRequest</code></p> Field Type Description revoked bool The credential's revocation status <p></p>"},{"location":"reference/proto/#createcredentialofferrequest","title":"CreateCredentialOfferRequest","text":"Field Type Description template_id string ID of template to use values_json string JSON document string with keys corresponding to the fields of the template referenced by <code>template_id</code> holder_binding bool If true, the credential will be issued with holder binding by specifying the holder DID in the credential subject include_governance bool If true, the issued credential will contain an attestation of the issuer's membership in the ecosystem's governance framework. generate_share_url bool If true, a short URL link will be generated that can be used to share the credential offer with the holder. This link will point to the credential offer in the wallet app."},{"location":"reference/proto/#createcredentialofferresponse","title":"CreateCredentialOfferResponse","text":"Field Type Description document_json string The JSON document that contains the credential offer share_url string If requested, a URL that can be used to share the credential offer with the holder. This is a short URL that can be used in a QR code and will redirect the holder to the credential offer using the wallet app."},{"location":"reference/proto/#createproofrequest","title":"CreateProofRequest","text":"<p>Request to create a proof for a Verifiable Credential using public key tied to caller. Either <code>item_id</code> or <code>document_json</code> may be provided, not both.</p> Field Type Description reveal_document_json string A valid JSON-LD frame describing which fields should be revealed in the generated proof. If unspecified, all fields in the document will be revealed reveal_template RevealTemplateAttributes Information about what sections of the document to reveal item_id string ID of wallet item stored in a Trinsic cloud wallet document_json string A valid JSON-LD Verifiable Credential document string with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet. use_verifiable_presentation bool Wrap the output in a verifiable presentation. If the credential used in the proof is bound to the holder DID, the output will always use a verifiable presentation and this field will be ignored. nonce bytes Nonce value used to derive the proof. If not specified, a random nonce will be generated. This value may be represented in base64 format in the proof model. <p></p>"},{"location":"reference/proto/#createproofresponse","title":"CreateProofResponse","text":"<p>Response to <code>CreateProofRequest</code></p> Field Type Description proof_document_json string Valid JSON-LD proof for the specified credential <p></p>"},{"location":"reference/proto/#issuefromtemplaterequest","title":"IssueFromTemplateRequest","text":"<p>Request to create and sign a JSON-LD Verifiable Credential from a template using public key tied to caller</p> Field Type Description template_id string ID of template to use values_json string JSON document string with keys corresponding to the fields of the template referenced by <code>template_id</code> save_copy bool Save a copy of the issued credential to this user's wallet. This copy will only contain the credential data, but not the secret proof value. Issuers may use this data to keep track of the details for revocation status. expiration_date string The ISO8601 expiration UTC date of the credential. This is a reserved field in the VC specification. If specified, the issued credential will contain an expiration date. https://www.w3.org/TR/vc-data-model/#expiration include_governance bool If true, the issued credential will contain an attestation of the issuer's membership in the ecosystem's governance framework. <p></p>"},{"location":"reference/proto/#issuefromtemplateresponse","title":"IssueFromTemplateResponse","text":"<p>Response to <code>IssueFromTemplateRequest</code></p> Field Type Description document_json string Verifiable Credential document, in JSON-LD form, constructed from the specified template and values; signed with public key tied to caller of <code>IssueFromTemplateRequest</code> <p></p>"},{"location":"reference/proto/#rejectcredentialrequest","title":"RejectCredentialRequest","text":"Field Type Description document_json string The JSON document that contains the credential offer item_id string The ID of the item in the wallet that contains the credential offer"},{"location":"reference/proto/#rejectcredentialresponse","title":"RejectCredentialResponse","text":""},{"location":"reference/proto/#revealtemplateattributes","title":"RevealTemplateAttributes","text":"Field Type Description template_attributes string[] A list of document attributes to reveal. If unset, all attributes will be returned."},{"location":"reference/proto/#sendrequest","title":"SendRequest","text":"<p>Request to send a document to another user's wallet</p> Field Type Description email string Email address of user to whom you'll send the item wallet_id string Wallet ID of the recipient within the ecosystem did_uri string DID URI of the recipient phone_number string SMS of user to whom you'll send the item send_notification bool Send email notification that credential has been sent to a wallet document_json string JSON document to send to recipient <p></p>"},{"location":"reference/proto/#sendresponse","title":"SendResponse","text":"<p>Response to <code>SendRequest</code></p> <p></p>"},{"location":"reference/proto/#updatestatusrequest","title":"UpdateStatusRequest","text":"<p>Request to update a credential's revocation status</p> Field Type Description credential_status_id string Credential Status ID to update. This is not the same as the credential's ID. revoked bool New revocation status of credential <p></p>"},{"location":"reference/proto/#updatestatusresponse","title":"UpdateStatusResponse","text":"<p>Response to <code>UpdateStatusRequest</code></p> <p></p>"},{"location":"reference/proto/#validationmessage","title":"ValidationMessage","text":"<p>Result of a validation check on a proof</p> Field Type Description is_valid bool Whether this validation check passed messages string[] If validation failed, contains messages explaining why <p></p>"},{"location":"reference/proto/#verifyproofrequest","title":"VerifyProofRequest","text":"<p>Request to verify a proof</p> Field Type Description proof_document_json string JSON-LD proof document string to verify <p></p>"},{"location":"reference/proto/#verifyproofresponse","title":"VerifyProofResponse","text":"<p>Response to <code>VerifyProofRequest</code></p> Field Type Description is_valid bool Whether all validations in <code>validation_results</code> passed validation_results VerifyProofResponse.ValidationResultsEntry[] Results of each validation check performed, such as schema conformance, revocation status, signature, etc. Detailed results are provided for failed validations. <p></p>"},{"location":"reference/proto/#verifyproofresponsevalidationresultsentry","title":"VerifyProofResponse.ValidationResultsEntry","text":"Field Type Description key string value ValidationMessage <p>Top</p>"},{"location":"reference/proto/#servicesverifiable-credentialstemplatesv1templatesproto","title":"services/verifiable-credentials/templates/v1/templates.proto","text":""},{"location":"reference/proto/#service-credentialtemplates","title":"Service - CredentialTemplates","text":"Method Name Request Type Response Type Description Create CreateCredentialTemplateRequest CreateCredentialTemplateResponse Create a credential template in the current ecosystem Get GetCredentialTemplateRequest GetCredentialTemplateResponse Fetch a credential template by ID Update UpdateCredentialTemplateRequest UpdateCredentialTemplateResponse Update metadata of a template List ListCredentialTemplatesRequest ListCredentialTemplatesResponse Search credential templates using SQL, returning strongly-typed template data Search SearchCredentialTemplatesRequest SearchCredentialTemplatesResponse Search credential templates using SQL, returning raw JSON data Delete DeleteCredentialTemplateRequest DeleteCredentialTemplateResponse Delete a credential template from the current ecosystem by ID"},{"location":"reference/proto/#applewalletoptions","title":"AppleWalletOptions","text":"<p>Configuration options for Apple Wallet when</p> Field Type Description background_color string Background color, in hex format, of credential when stored in an Apple Wallet. foreground_color string Foreground color, in hex format, of credential when stored in an Apple Wallet. label_color string Label color, in hex format, of credential when stored in an Apple Wallet. primary_field string The ID of the template field which should be used as the primary field of a credential. secondary_fields string[] The secondary fields of the credential. This is a mapping between the order of a secondary field (0 or 1) and the field name. auxiliary_fields string[] The auxiliary fields of the credential. This is a mapping between the order of an auxiliary field (0 or 1) and the field name. <p></p>"},{"location":"reference/proto/#createcredentialtemplaterequest","title":"CreateCredentialTemplateRequest","text":"<p>Request to create a new template</p> Field Type Description name string Name of new template. Must be a unique identifier within its ecosystem. fields CreateCredentialTemplateRequest.FieldsEntry[] Fields which compose the template allow_additional_fields bool Whether credentials may be issued against this template which have fields not specified in <code>fields</code> title string Human-readable name of template description string Human-readable description of template field_ordering CreateCredentialTemplateRequest.FieldOrderingEntry[] Optional map describing how to order and categorize the fields within the template. The key of this map is the field <code>name</code>. If not provided, this will be auto-generated. apple_wallet_options AppleWalletOptions Options for rendering the template in Apple Wallet <p></p>"},{"location":"reference/proto/#createcredentialtemplaterequestfieldorderingentry","title":"CreateCredentialTemplateRequest.FieldOrderingEntry","text":"Field Type Description key string value FieldOrdering"},{"location":"reference/proto/#createcredentialtemplaterequestfieldsentry","title":"CreateCredentialTemplateRequest.FieldsEntry","text":"Field Type Description key string value TemplateField"},{"location":"reference/proto/#createcredentialtemplateresponse","title":"CreateCredentialTemplateResponse","text":"<p>Response to <code>CreateCredentialTemplateRequest</code></p> Field Type Description data TemplateData Created template <p></p>"},{"location":"reference/proto/#deletecredentialtemplaterequest","title":"DeleteCredentialTemplateRequest","text":"<p>Request to delete a template by ID</p> Field Type Description id string ID of template to delete <p></p>"},{"location":"reference/proto/#deletecredentialtemplateresponse","title":"DeleteCredentialTemplateResponse","text":"<p>Response to <code>DeleteCredentialTemplateRequest</code></p> <p></p>"},{"location":"reference/proto/#fieldordering","title":"FieldOrdering","text":"<p>Ordering information for a template field</p> Field Type Description order int32 The order of the field; must be unique within the Template. Fields are sorted by order ascending when displaying a credential. Field orders must be contiguous from <code>0</code> to the number of fields minus 1. section string The human-readable name of the section this field appears in; used to group together fields when displaying a credential. Sections must be contiguous with respect to <code>order</code>. <p></p>"},{"location":"reference/proto/#getcredentialtemplaterequest","title":"GetCredentialTemplateRequest","text":"<p>Request to fetch a template by ID</p> Field Type Description id string ID of template to fetch <p></p>"},{"location":"reference/proto/#getcredentialtemplateresponse","title":"GetCredentialTemplateResponse","text":"<p>Response to <code>GetCredentialTemplateRequest</code></p> Field Type Description template TemplateData Template fetched by ID <p></p>"},{"location":"reference/proto/#listcredentialtemplatesrequest","title":"ListCredentialTemplatesRequest","text":"<p>Request to list templates using a SQL query</p> Field Type Description query string SQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code> continuation_token string Token provided by previous <code>ListCredentialTemplatesResponse</code> if more data is available for query <p></p>"},{"location":"reference/proto/#listcredentialtemplatesresponse","title":"ListCredentialTemplatesResponse","text":"<p>Response to <code>ListCredentialTemplatesRequest</code></p> Field Type Description templates TemplateData[] Templates found by query has_more_results bool Whether more results are available for this query via <code>continuation_token</code> continuation_token string Token to fetch next set of resuts via <code>ListCredentialTemplatesRequest</code> <p></p>"},{"location":"reference/proto/#searchcredentialtemplatesrequest","title":"SearchCredentialTemplatesRequest","text":"<p>Request to search templates using a SQL query</p> Field Type Description query string SQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code> continuation_token string Token provided by previous <code>SearchCredentialTemplatesResponse</code> if more data is available for query <p></p>"},{"location":"reference/proto/#searchcredentialtemplatesresponse","title":"SearchCredentialTemplatesResponse","text":"<p>Response to <code>SearchCredentialTemplatesRequest</code></p> Field Type Description items_json string Raw JSON data returned from query has_more_results bool Whether more results are available for this query via <code>continuation_token</code> continuation_token string Token to fetch next set of results via <code>SearchCredentialTemplatesRequest</code> <p></p>"},{"location":"reference/proto/#templatedata","title":"TemplateData","text":"<p>Credential Template</p> Field Type Description id string Template ID name string Template name version int32 Template version number fields TemplateData.FieldsEntry[] Fields defined for the template allow_additional_fields bool Whether credentials issued against this template may contain fields not defined by template schema_uri string URI pointing to template JSON schema document ecosystem_id string ID of ecosystem in which template resides type string Template type (<code>VerifiableCredential</code>) created_by string ID of template creator date_created string Date when template was created as ISO 8601 utc string title string Human-readable template title description string Human-readable template description field_ordering TemplateData.FieldOrderingEntry[] Map describing how to order and categorize the fields within the template. The key of this map is the field <code>name</code>. apple_wallet_options AppleWalletOptions Options for rendering the template in Apple Wallet <p></p>"},{"location":"reference/proto/#templatedatafieldorderingentry","title":"TemplateData.FieldOrderingEntry","text":"Field Type Description key string value FieldOrdering"},{"location":"reference/proto/#templatedatafieldsentry","title":"TemplateData.FieldsEntry","text":"Field Type Description key string value TemplateField"},{"location":"reference/proto/#templatefield","title":"TemplateField","text":"<p>A field defined in a template</p> Field Type Description title string Human-readable name of the field description string Human-readable description of the field optional bool Whether this field may be omitted when a credential is issued against the template type FieldType The type of the field uri_data UriFieldData How to deal with this URI field when rendering credential. Only use if <code>type</code> is <code>URI</code>. <p></p>"},{"location":"reference/proto/#templatefieldpatch","title":"TemplateFieldPatch","text":"<p>A patch to apply to an existing template field</p> Field Type Description title string Human-readable name of the field description string Human-readable description of the field uri_data UriFieldData How to deal with this URI field when rendering credential. Only use if <code>type</code> is <code>URI</code>. <p></p>"},{"location":"reference/proto/#updatecredentialtemplaterequest","title":"UpdateCredentialTemplateRequest","text":"<p>Request to update display information for a template</p> Field Type Description id string ID of Template to update title string New human-readable title of Template description string New human-readable description of Template fields UpdateCredentialTemplateRequest.FieldsEntry[] Fields to update within the Template field_ordering UpdateCredentialTemplateRequest.FieldOrderingEntry[] New field ordering options. See documentation for template creation for usage information. apple_wallet_options AppleWalletOptions New Apple Wallet configuration <p></p>"},{"location":"reference/proto/#updatecredentialtemplaterequestfieldorderingentry","title":"UpdateCredentialTemplateRequest.FieldOrderingEntry","text":"Field Type Description key string value FieldOrdering"},{"location":"reference/proto/#updatecredentialtemplaterequestfieldsentry","title":"UpdateCredentialTemplateRequest.FieldsEntry","text":"Field Type Description key string value TemplateFieldPatch"},{"location":"reference/proto/#updatecredentialtemplateresponse","title":"UpdateCredentialTemplateResponse","text":"<p>Response to <code>UpdateCredentialTemplateRequest</code></p> Field Type Description updated_template TemplateData The Template after the update has been applied <p></p>"},{"location":"reference/proto/#urifielddata","title":"UriFieldData","text":"<p>Data pertaining to a URI Field</p> Field Type Description mime_type string Expected MIME Type of content pointed to by URI. Can be generic (eg, \"image/\") or specific (\"image/png\"). Defaults to \"application/octet-stream\". render_method UriRenderMethod How to display the URI value when rendering a credential. <p></p>"},{"location":"reference/proto/#fieldtype","title":"FieldType","text":"<p>Valid types for credential fields</p> Name Number Description STRING 0 NUMBER 1 BOOL 2 DATETIME 4 URI 5 <p></p>"},{"location":"reference/proto/#urirendermethod","title":"UriRenderMethod","text":"<p>How to display a URI value when rendering a credential.</p> Name Number Description TEXT 0 Display URI as text LINK 1 Display URI as a clickable link INLINE_IMAGE 2 Display URI as an inline image. Only takes effect if the template field's MIME Type is an image type. <p></p> <p>Top</p>"},{"location":"reference/proto/#servicesproviderv1providerproto","title":"services/provider/v1/provider.proto","text":""},{"location":"reference/proto/#service-provider","title":"Service - Provider","text":"Method Name Request Type Response Type Description CreateEcosystem CreateEcosystemRequest CreateEcosystemResponse Create new ecosystem and assign the authenticated user as owner GetOberonKey GetOberonKeyRequest GetOberonKeyResponse Returns the public key being used to create/verify oberon tokens UpgradeDID UpgradeDidRequest UpgradeDidResponse Upgrade a wallet's DID from <code>did:key</code> to another method SearchWalletConfigurations SearchWalletConfigurationsRequest SearchWalletConfigurationResponse Search for issuers/providers/verifiers in the current ecosystem"},{"location":"reference/proto/#createecosystemrequest","title":"CreateEcosystemRequest","text":"<p>Request to create an ecosystem</p> Field Type Description name string Globally unique name for the Ecosystem. This name will be part of the ecosystem-specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen. If not passed, ecosystem name will be auto-generated. description string Ecosystem description details services.account.v1.AccountDetails The account details of the owner of the ecosystem domain string New domain URL <p></p>"},{"location":"reference/proto/#createecosystemresponse","title":"CreateEcosystemResponse","text":"<p>Response to <code>CreateEcosystemRequest</code></p> Field Type Description ecosystem Ecosystem Details of the created ecosystem profile services.account.v1.AccountProfile Account profile for auth of the owner of the ecosystem confirmation_method services.account.v1.ConfirmationMethod Indicates if confirmation of account is required. <p></p>"},{"location":"reference/proto/#ecosystem","title":"Ecosystem","text":"<p>Details of an ecosystem</p> Field Type Description id string URN of the ecosystem name string Globally unique name for the ecosystem description string Ecosystem description <p></p>"},{"location":"reference/proto/#ecosysteminforequest","title":"EcosystemInfoRequest","text":"<p>Request to fetch information about an ecosystem</p> <p></p>"},{"location":"reference/proto/#ecosysteminforesponse","title":"EcosystemInfoResponse","text":"<p>Response to <code>InfoRequest</code></p> Field Type Description ecosystem Ecosystem Ecosystem corresponding to current ecosystem in the account token <p></p>"},{"location":"reference/proto/#getoberonkeyrequest","title":"GetOberonKeyRequest","text":"<p>Request to fetch the Trinsic public key used to verify authentication token validity</p> <p></p>"},{"location":"reference/proto/#getoberonkeyresponse","title":"GetOberonKeyResponse","text":"<p>Response to <code>GetOberonKeyRequest</code></p> Field Type Description key string Oberon Public Key as RAW base64-url encoded string <p></p>"},{"location":"reference/proto/#indyoptions","title":"IndyOptions","text":"<p>Options for creation of DID on the SOV network</p> Field Type Description network IndyOptions.IndyNetwork SOV network on which DID should be published <p></p>"},{"location":"reference/proto/#ionoptions","title":"IonOptions","text":"<p>Options for creation of DID on the ION network</p> Field Type Description network IonOptions.IonNetwork ION network on which DID should be published <p></p>"},{"location":"reference/proto/#refreshdomainverificationstatusrequest","title":"RefreshDomainVerificationStatusRequest","text":"<p>The below display can be removed only once the Dashboard is updating this itself - currently it uses this request DEPRECATED, will be removed June 1st 2023</p> <p></p>"},{"location":"reference/proto/#refreshdomainverificationstatusresponse","title":"RefreshDomainVerificationStatusResponse","text":"<p>The below display can be removed only once the Dashboard is updating this itself - currently it uses this request DEPRECATED, will be removed June 1st 2023</p> Field Type Description domain string Domain URL verified domain_verified bool Specifies if the above <code>domain</code> was successfully verified <p></p>"},{"location":"reference/proto/#retrievedomainverificationrecordrequest","title":"RetrieveDomainVerificationRecordRequest","text":"<p>The below display can be removed only once the Dashboard is updating this itself - currently it uses this request DEPRECATED, will be removed June 1st 2023</p> <p></p>"},{"location":"reference/proto/#retrievedomainverificationrecordresponse","title":"RetrieveDomainVerificationRecordResponse","text":"<p>The below display can be removed only once the Dashboard is updating this itself - currently it uses this request DEPRECATED, will be removed June 1st 2023</p> Field Type Description verification_record_name string TXT record name to use for domain verification verification_record_value string TXT code for domain verification <p></p>"},{"location":"reference/proto/#searchwalletconfigurationresponse","title":"SearchWalletConfigurationResponse","text":"Field Type Description results WalletConfiguration[] Results matching the search query has_more_results bool Whether more results are available for this query via <code>continuation_token</code> continuation_token string Token to fetch next set of results via <code>SearchRequest</code>"},{"location":"reference/proto/#searchwalletconfigurationsrequest","title":"SearchWalletConfigurationsRequest","text":"<p>Search for issuers/holders/verifiers</p> Field Type Description query_filter string SQL filter to execute. <code>SELECT * FROM c WHERE [**queryFilter**]</code> continuation_token string Token provided by previous <code>SearchResponse</code> if more data is available for query <p></p>"},{"location":"reference/proto/#upgradedidrequest","title":"UpgradeDidRequest","text":"<p>Request to upgrade a wallet</p> Field Type Description email string Email address of account to upgrade. Mutually exclusive with <code>walletId</code> and <code>didUri</code>. wallet_id string Wallet ID of account to upgrade. Mutually exclusive with <code>email</code> and <code>didUri</code>. did_uri string DID URI of the account to upgrade. Mutually exclusive with <code>email</code> and <code>walletId</code>. method services.common.v1.SupportedDidMethod DID Method to which wallet should be upgraded ion_options IonOptions Configuration for creation of DID on ION network indy_options IndyOptions Configuration for creation of DID on INDY network <p></p>"},{"location":"reference/proto/#upgradedidresponse","title":"UpgradeDidResponse","text":"<p>Response to <code>UpgradeDIDRequest</code></p> Field Type Description did string New DID of wallet <p></p>"},{"location":"reference/proto/#walletconfiguration","title":"WalletConfiguration","text":"<p>Strongly typed information about wallet configurations</p> Field Type Description name string Name/description of the wallet email string Deprecated. Deprecated and will be removed on August 1, 2023 -- use external_identities. This field is set to the first email address present in <code>external_identities</code>, if any. sms string Deprecated. Deprecated -- use external_identities wallet_id string public_did string The DID of the wallet config_type string auth_tokens services.account.v1.WalletAuthToken[] List of active authentication tokens for this wallet. This list does not contain the issued token, only metadata such as ID, description, and creation date. external_identity_ids string[] Deprecated. List of external identity IDs (email addresses, phone numbers, etc.) associated with this wallet. This is deprecated; use <code>external_identities</code> instead. ecosystem_id string Ecosystem in which this wallet is contained. description string external_identities WalletExternalIdentity[] List of external identities associated with this wallet. <p></p>"},{"location":"reference/proto/#walletexternalidentity","title":"WalletExternalIdentity","text":"<p>An external identity (email address, phone number, etc.) associated with a wallet for authentication purposes.</p> Field Type Description provider IdentityProvider The type of this identity (whether this identity is an email address, phone number, etc.) id string The actual email address/phone number/etc. for this identity <p></p>"},{"location":"reference/proto/#identityprovider","title":"IdentityProvider","text":"Name Number Description Unknown 0 Identity provider is unknown Email 1 Identity provider is email Phone 2 Identity provider is phone"},{"location":"reference/proto/#indyoptionsindynetwork","title":"IndyOptions.IndyNetwork","text":"Name Number Description Danube 0 SovrinBuilder 1 SovrinStaging 2 Sovrin 3 IdUnionTest 4 IdUnion 5 IndicioTest 6 IndicioDemo 7 Indicio 8"},{"location":"reference/proto/#ionoptionsionnetwork","title":"IonOptions.IonNetwork","text":"Name Number Description TestNet 0 MainNet 1 <p>Top</p>"},{"location":"reference/proto/#servicesproviderv1access-managementproto","title":"services/provider/v1/access-management.proto","text":""},{"location":"reference/proto/#service-accessmanagement","title":"Service - AccessManagement","text":"<p>Access Management service provides methods to manage access to ecosystem resources such by assigning roles and permissions to wallet accounts</p> Method Name Request Type Response Type Description AddRoleAssignment AddRoleAssignmentRequest AddRoleAssignmentResponse Adds a role assignment to an account RemoveRoleAssignment RemoveRoleAssignmentRequest RemoveRoleAssignmentResponse Removes a role assignment from the account ListRoleAssignments ListRoleAssignmentsRequest ListRoleAssignmentsResponse List the role assignments for the given account ListAvailableRoles ListAvailableRolesRequest ListAvailableRolesResponse List the roles available in the ecosystem <p></p>"},{"location":"reference/proto/#addroleassignmentrequest","title":"AddRoleAssignmentRequest","text":"<p>Role management</p> Field Type Description role string Role to assign email string Email address of account to assign role. Mutually exclusive with <code>walletId</code> and <code>didUri</code>. wallet_id string Wallet ID of account to assign role to. Mutually exclusive with <code>email</code> and <code>didUri</code>. did_uri string DID URI of the account to assign role. Mutually exclusive with <code>email</code> and <code>walletId</code>. <p></p>"},{"location":"reference/proto/#addroleassignmentresponse","title":"AddRoleAssignmentResponse","text":""},{"location":"reference/proto/#listavailablerolesrequest","title":"ListAvailableRolesRequest","text":"<p>Request to fetch the available roles in the current ecosystem</p> <p></p>"},{"location":"reference/proto/#listavailablerolesresponse","title":"ListAvailableRolesResponse","text":"Field Type Description roles string[] List of roles"},{"location":"reference/proto/#listroleassignmentsrequest","title":"ListRoleAssignmentsRequest","text":"<p>Request to fetch the list of roles assigned to the current account</p> Field Type Description email string Email address of account to list roles. Mutually exclusive with <code>walletId</code> and <code>didUri</code>. wallet_id string Wallet ID of account to list roles. Mutually exclusive with <code>email</code> and <code>didUri</code>. did_uri string DID URI of the account to list roles. Mutually exclusive with <code>email</code> and <code>walletId</code>. <p></p>"},{"location":"reference/proto/#listroleassignmentsresponse","title":"ListRoleAssignmentsResponse","text":"Field Type Description roles string[] List of roles"},{"location":"reference/proto/#removeroleassignmentrequest","title":"RemoveRoleAssignmentRequest","text":"Field Type Description role string Role to unassign email string Email address of account to unassign role. Mutually exclusive with <code>walletId</code> and <code>didUri</code>. wallet_id string Wallet ID of account to unassign role. Mutually exclusive with <code>email</code> and <code>didUri</code>. did_uri string DID URI of the account to unassign role. Mutually exclusive with <code>email</code> and <code>walletId</code>."},{"location":"reference/proto/#removeroleassignmentresponse","title":"RemoveRoleAssignmentResponse","text":"<p>Top</p>"},{"location":"reference/proto/#servicesuniversal-walletv1universal-walletproto","title":"services/universal-wallet/v1/universal-wallet.proto","text":""},{"location":"reference/proto/#service-universalwallet","title":"Service - UniversalWallet","text":"<p>Service for managing wallets</p> Method Name Request Type Response Type Description GetItem GetItemRequest GetItemResponse Retrieve an item from the wallet with a given item identifier Search SearchRequest SearchResponse Search the wallet using a SQL syntax InsertItem InsertItemRequest InsertItemResponse Insert an item into the wallet UpdateItem UpdateItemRequest UpdateItemResponse Update an item in the wallet DeleteItem DeleteItemRequest DeleteItemResponse Delete an item from the wallet permanently DeleteWallet DeleteWalletRequest DeleteWalletResponse Delete a wallet and its credentials CreateWallet CreateWalletRequest CreateWalletResponse Create a new wallet and generate an auth token for access GetWalletInfo GetWalletInfoRequest GetWalletInfoResponse Retrieve wallet details and configuration GetMyInfo GetMyInfoRequest GetMyInfoResponse Retrieve wallet details and configuration about the currently authenticated wallet GenerateAuthToken GenerateAuthTokenRequest GenerateAuthTokenResponse Generate new token for a given wallet and add it to the collection of known auth tokens. This endpoint requires authentication and will return a new token ID and auth token. Use this endpoint if you want to authorize another device, without having to share your existing auth token. RevokeAuthToken RevokeAuthTokenRequest RevokeAuthTokenResponse Revokes a previously issued auth token and updates the collection of known auth tokens. This endpoint requires authentication. AddExternalIdentityInit AddExternalIdentityInitRequest AddExternalIdentityInitResponse Add new external identity to the current wallet, such as email, sms, ethereum address, etc. This identity ownership must be confirmed using <code>AddIdentityConfirm</code> via OTP, signature, etc. AddExternalIdentityConfirm AddExternalIdentityConfirmRequest AddExternalIdentityConfirmResponse Confirm identity added to the current wallet using <code>AddExternalIdentityInit</code> RemoveExternalIdentity RemoveExternalIdentityRequest RemoveExternalIdentityResponse Remove an external identity from the current wallet AuthenticateInit AuthenticateInitRequest AuthenticateInitResponse Sign-in to an already existing wallet, using an identity added that was previously registered This endpoint does not require authentication, and will return a challenge to be signed or verified AuthenticateConfirm AuthenticateConfirmRequest AuthenticateConfirmResponse Confirm sign-in to an already existing wallet and return authentication token AuthenticateResendCode AuthenticateResendCodeRequest AuthenticateResendCodeResponse Resend previous authentication code ListWallets ListWalletsRequest ListWalletsResponse List all wallets in the ecosystem <p></p>"},{"location":"reference/proto/#addexternalidentityconfirmrequest","title":"AddExternalIdentityConfirmRequest","text":"Field Type Description challenge string The challenge received from the <code>AddExternalIdentityInit</code> endpoint response string The response to the challenge. If using Email or Phone, this is the OTP code sent to the user's email or phone"},{"location":"reference/proto/#addexternalidentityconfirmresponse","title":"AddExternalIdentityConfirmResponse","text":""},{"location":"reference/proto/#addexternalidentityinitrequest","title":"AddExternalIdentityInitRequest","text":"Field Type Description identity string The user identity to add to the wallet This can be an email address or phone number (formatted as +[country code][phone number]) provider services.provider.v1.IdentityProvider The type of identity provider, like EMAIL or PHONE"},{"location":"reference/proto/#addexternalidentityinitresponse","title":"AddExternalIdentityInitResponse","text":"Field Type Description challenge string Challenge or reference to the challenge to be used in the <code>AddExternalIdentityConfirm</code> endpoint"},{"location":"reference/proto/#authenticateconfirmrequest","title":"AuthenticateConfirmRequest","text":"Field Type Description challenge string The challenge received from the <code>AcquireAuthTokenInit</code> endpoint response string The response to the challenge. If using Email or Phone, this is the OTP code sent to the user's email or phone"},{"location":"reference/proto/#authenticateconfirmresponse","title":"AuthenticateConfirmResponse","text":"Field Type Description auth_token string Auth token for the wallet"},{"location":"reference/proto/#authenticateinitrequest","title":"AuthenticateInitRequest","text":"Field Type Description identity string Identity to add to the wallet provider services.provider.v1.IdentityProvider Identity provider ecosystem_id string Ecosystem ID to which the wallet belongs"},{"location":"reference/proto/#authenticateinitresponse","title":"AuthenticateInitResponse","text":"Field Type Description challenge string The challenge received from the <code>AcquireAuthTokenInit</code> endpoint Pass this challenge back to the <code>AcquireAuthTokenConfirm</code> endpoint"},{"location":"reference/proto/#authenticateresendcoderequest","title":"AuthenticateResendCodeRequest","text":"Field Type Description challenge string Challenge for the code you want resent."},{"location":"reference/proto/#authenticateresendcoderesponse","title":"AuthenticateResendCodeResponse","text":""},{"location":"reference/proto/#createwalletrequest","title":"CreateWalletRequest","text":"Field Type Description ecosystem_id string Ecosystem ID of the wallet to create description string Wallet name or description. Use this field to add vendor specific information about this wallet, such as email, phone, internal ID, or anything you'd like to associate with this wallet. This field is searchable. identity CreateWalletRequest.ExternalIdentity Optional identity to add to the wallet (email or sms). Use this field when inviting participants into an ecosystem. If this field is set, an auth token will not be sent in the response."},{"location":"reference/proto/#createwalletrequestexternalidentity","title":"CreateWalletRequest.ExternalIdentity","text":"Field Type Description identity string The user identity to add to the wallet This can be an email address or phone number (formatted as +[country code][phone number]) provider services.provider.v1.IdentityProvider The type of identity provider, like EMAIL or PHONE"},{"location":"reference/proto/#createwalletresponse","title":"CreateWalletResponse","text":"Field Type Description auth_token string Auth token for the newly created wallet token_id string Token ID of the newly generated token wallet services.provider.v1.WalletConfiguration Wallet configuration"},{"location":"reference/proto/#deleteitemrequest","title":"DeleteItemRequest","text":"<p>Request to delete an item in a wallet</p> Field Type Description item_id string ID of item to delete <p></p>"},{"location":"reference/proto/#deleteitemresponse","title":"DeleteItemResponse","text":"<p>Response to <code>DeleteItemRequest</code></p> <p></p>"},{"location":"reference/proto/#deletewalletrequest","title":"DeleteWalletRequest","text":"<p>Request to delete a wallet</p> Field Type Description email string Email address of account to delete. Mutually exclusive with <code>walletId</code> and <code>didUri</code>. wallet_id string Wallet ID of account to delete. Mutually exclusive with <code>email</code> and <code>didUri</code>. did_uri string DID URI of the account to delete. Mutually exclusive with <code>email</code> and <code>walletId</code>. <p></p>"},{"location":"reference/proto/#deletewalletresponse","title":"DeleteWalletResponse","text":"<p>Response to <code>DeleteWalletRequest</code>. Empty payload.</p> <p></p>"},{"location":"reference/proto/#generateauthtokenrequest","title":"GenerateAuthTokenRequest","text":"Field Type Description wallet_id string token_description string"},{"location":"reference/proto/#generateauthtokenresponse","title":"GenerateAuthTokenResponse","text":"Field Type Description token_id string auth_token string"},{"location":"reference/proto/#getitemrequest","title":"GetItemRequest","text":"<p>Request to fetch an item from wallet</p> Field Type Description item_id string ID of item in wallet <p></p>"},{"location":"reference/proto/#getitemresponse","title":"GetItemResponse","text":"<p>Response to <code>GetItemRequest</code></p> Field Type Description item_json string Item data as a JSON string item_type string Type of item specified when item was inserted into wallet <p></p>"},{"location":"reference/proto/#getmyinforequest","title":"GetMyInfoRequest","text":"<p>Request to retrieve wallet information about the currently authenticated wallet</p> <p></p>"},{"location":"reference/proto/#getmyinforesponse","title":"GetMyInfoResponse","text":"<p>Response to <code>GetMyInfoRequest</code></p> Field Type Description wallet services.provider.v1.WalletConfiguration Wallet configuration <p></p>"},{"location":"reference/proto/#getwalletinforequest","title":"GetWalletInfoRequest","text":"<p>Request to retrieve wallet information about a given wallet identified by its wallet ID</p> Field Type Description wallet_id string Wallet ID of the wallet to retrieve <p></p>"},{"location":"reference/proto/#getwalletinforesponse","title":"GetWalletInfoResponse","text":"<p>Response to <code>GetWalletInfoRequest</code></p> Field Type Description wallet services.provider.v1.WalletConfiguration Wallet configuration <p></p>"},{"location":"reference/proto/#insertitemrequest","title":"InsertItemRequest","text":"<p>Request to insert a JSON document into a wallet</p> Field Type Description item_json string Document to insert; must be stringified JSON item_type string Item type (ex. \"VerifiableCredential\") <p></p>"},{"location":"reference/proto/#insertitemresponse","title":"InsertItemResponse","text":"<p>Response to <code>InsertItemRequest</code></p> Field Type Description item_id string ID of item inserted into wallet <p></p>"},{"location":"reference/proto/#listwalletsrequest","title":"ListWalletsRequest","text":"Field Type Description filter string"},{"location":"reference/proto/#listwalletsresponse","title":"ListWalletsResponse","text":"Field Type Description wallets services.provider.v1.WalletConfiguration[]"},{"location":"reference/proto/#removeexternalidentityrequest","title":"RemoveExternalIdentityRequest","text":"Field Type Description identity string The user identity to remove from the wallet This can be an email address or phone number (formatted as +[country code][phone number])"},{"location":"reference/proto/#removeexternalidentityresponse","title":"RemoveExternalIdentityResponse","text":""},{"location":"reference/proto/#revokeauthtokenrequest","title":"RevokeAuthTokenRequest","text":"<p>Request to revoke a previously issued auth token</p> Field Type Description wallet_id string Wallet ID of the wallet to from which to revoke the token token_id string Token ID of the token to revoke <p></p>"},{"location":"reference/proto/#revokeauthtokenresponse","title":"RevokeAuthTokenResponse","text":""},{"location":"reference/proto/#searchrequest","title":"SearchRequest","text":"<p>Request to search items in wallet</p> Field Type Description query string SQL Query to execute against items in wallet continuation_token string Token provided by previous <code>SearchResponse</code> if more data is available for query <p></p>"},{"location":"reference/proto/#searchresponse","title":"SearchResponse","text":"<p>Response to <code>SearchRequest</code></p> Field Type Description items string[] Array of query results, as JSON strings has_more_results bool Whether more results are available for this query via <code>continuation_token</code> continuation_token string Token to fetch next set of results via <code>SearchRequest</code> <p></p>"},{"location":"reference/proto/#updateitemrequest","title":"UpdateItemRequest","text":"<p>Request to update item in wallet</p> Field Type Description item_id string ID of item in wallet item_type string Item type (ex. \"VerifiableCredential\") <p></p>"},{"location":"reference/proto/#updateitemresponse","title":"UpdateItemResponse","text":"<p>Response to <code>UpdateItemRequest</code></p> <p></p> <p>Top</p>"},{"location":"reference/proto/#servicestrust-registryv1trust-registryproto","title":"services/trust-registry/v1/trust-registry.proto","text":""},{"location":"reference/proto/#service-trustregistry","title":"Service - TrustRegistry","text":"Method Name Request Type Response Type Description RegisterMember RegisterMemberRequest RegisterMemberResponse Register an authoritative issuer for a credential schema UnregisterMember UnregisterMemberRequest UnregisterMemberResponse Removes an authoritative issuer for a credential schema from the trust registry GetMemberAuthorizationStatus GetMemberAuthorizationStatusRequest GetMemberAuthorizationStatusResponse Fetch the status of a member for a given credential schema in a trust registry ListAuthorizedMembers ListAuthorizedMembersRequest ListAuthorizedMembersResponse Fetch the ecosystem's authorized issuers and the respective templates against which it can issue GetMember GetMemberRequest GetMemberResponse Get member for a given did in a trust registry"},{"location":"reference/proto/#authorizedmember","title":"AuthorizedMember","text":"Field Type Description did string authorized_member_schemas AuthorizedMemberSchema[]"},{"location":"reference/proto/#authorizedmemberschema","title":"AuthorizedMemberSchema","text":"Field Type Description schema_uri string status string status_details string valid_from uint64 valid_until uint64"},{"location":"reference/proto/#getmemberauthorizationstatusrequest","title":"GetMemberAuthorizationStatusRequest","text":"<p>Request to fetch member status in governance framework for a specific credential schema.</p> Field Type Description did_uri string DID URI of member schema_uri string URI of credential schema associated with member <p></p>"},{"location":"reference/proto/#getmemberauthorizationstatusresponse","title":"GetMemberAuthorizationStatusResponse","text":"<p>Response to <code>GetMemberAuthorizationStatusRequest</code></p> Field Type Description status RegistrationStatus Status of member for given credential schema <p></p>"},{"location":"reference/proto/#getmemberrequest","title":"GetMemberRequest","text":"<p>Request to get a member of the governance framework</p> Field Type Description did_uri string DID URI of member to get wallet_id string Trinsic Wallet ID of member to get email string Email address of member to get. Must be associated with an existing Trinsic account. <p></p>"},{"location":"reference/proto/#getmemberresponse","title":"GetMemberResponse","text":"<p>Response to <code>GetMemberAuthorizationStatusRequest</code></p> Field Type Description authorized_member AuthorizedMember Member for given did in given framework <p></p>"},{"location":"reference/proto/#listauthorizedmembersrequest","title":"ListAuthorizedMembersRequest","text":"Field Type Description schema_uri string id of schema that needs to be checked continuation_token string Token to fetch next set of results, from previous <code>ListAuthorizedMembersResponse</code>"},{"location":"reference/proto/#listauthorizedmembersresponse","title":"ListAuthorizedMembersResponse","text":"<p>Response to <code>ListAuthorizedMembersRequest</code></p> Field Type Description authorized_members AuthorizedMember[] JSON string containing array of resultant objects has_more_results bool Whether more data is available to fetch for query continuation_token string Token to fetch next set of results via <code>ListAuthorizedMembersRequest</code> <p></p>"},{"location":"reference/proto/#registermemberrequest","title":"RegisterMemberRequest","text":"<p>Request to register a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.</p> Field Type Description did_uri string DID URI of member to register wallet_id string Trinsic Wallet ID of member to register email string Email address of member to register. Must be associated with an existing Trinsic account. schema_uri string URI of credential schema to register member as authorized issuer of valid_from_utc uint64 Unix Timestamp member is valid from. Member will not be considered valid before this timestamp. valid_until_utc uint64 Unix Timestamp member is valid until. Member will not be considered valid after this timestamp. <p></p>"},{"location":"reference/proto/#registermemberresponse","title":"RegisterMemberResponse","text":"<p>Response to <code>RegisterMemberRequest</code></p> <p></p>"},{"location":"reference/proto/#unregistermemberrequest","title":"UnregisterMemberRequest","text":"<p>Request to unregister a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.</p> Field Type Description did_uri string DID URI of member to unregister wallet_id string Trinsic Wallet ID of member to unregister email string Email address of member to unregister. Must be associated with an existing Trinsic account. schema_uri string URI of credential schema to unregister member as authorized issuer of <p></p>"},{"location":"reference/proto/#unregistermemberresponse","title":"UnregisterMemberResponse","text":"<p>Response to <code>UnregisterMemberRequest</code></p> <p></p>"},{"location":"reference/proto/#registrationstatus","title":"RegistrationStatus","text":"Name Number Description CURRENT 0 Member is currently authorized, as of the time of the query EXPIRED 1 Member's authorization has expired TERMINATED 2 Member has voluntarily ceased Issuer role under the specific EGF REVOKED 3 Member authority under specific EGF was terminated by the governing authority NOT_FOUND 10 Member is not associated with given credential schema in the EGF <p>Top</p>"},{"location":"reference/proto/#servicescommonv1commonproto","title":"services/common/v1/common.proto","text":""},{"location":"reference/proto/#nonce","title":"Nonce","text":"<p>Nonce used to generate an oberon proof</p> Field Type Description timestamp int64 UTC unix millisecond timestamp the request was made request_hash bytes blake3256 hash of the request body <p></p>"},{"location":"reference/proto/#responsestatus","title":"ResponseStatus","text":"Name Number Description SUCCESS 0 WALLET_ACCESS_DENIED 10 WALLET_EXISTS 11 ITEM_NOT_FOUND 20 SERIALIZATION_ERROR 200 UNKNOWN_ERROR 100"},{"location":"reference/proto/#supporteddidmethod","title":"SupportedDidMethod","text":"<p>Enum of all supported DID Methods https://docs.godiddy.com/en/supported-methods</p> Name Number Description KEY 0 The did:key method -- all wallets use this by default ION 1 The did:ion method -- Sidetree implementation on top of Bitcoin by Microsoft INDY 2 The did:sov method -- Hyperledger Indy based by Sovrin Foundation"},{"location":"reference/proto/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP  double double double float float64 double float  float float float float float32 float float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string  sfixed32 Always four bytes. int32 int int int32 int integer  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string  bool bool boolean boolean bool bool boolean  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string"},{"location":"reference/services/account-service/","title":"Account Service","text":"<p>The Account Service allows you to create and sign in to accounts.</p> <p>Deprecated</p> <p>This API has been deprecated; use the Wallet API instead.</p>"},{"location":"reference/services/account-service/#login","title":"Login","text":"<p>Deprecated</p> <p>This endpoint has been deprecated; use the Wallet API instead:</p> <ul> <li>For wallet creation, use CreateWallet</li> <li>To login to an existing wallet, use Authenticate</li> <li>This requires that an external identity (such as an email or phone number) has been added to the wallet via AddExternalIdentity, or (if the wallet was created using the deprecated <code>Login</code> API) during wallet creation.</li> </ul> <p>Attempts the first step of the login process for the specified account, creating it if it does not already exist.</p> <p>Trinsic will response with a <code>challenge</code>, and send an authentication code to the account's email address.</p> <p>The authentication code must be passed along with <code>challenge</code> to LoginConfirm to finalize the login.</p>  Sample Request Response Trinsic CLI <pre><code>trinsic account login --email \"bob@example.com\" --ecosystem \"&lt;ecosystem id or name&gt;\"\n</code></pre> <p>LoginRequestRequest to begin login flowemail optional stringEmail address of account. If unspecified, an anonymous account will be created.ecosystem_id optional stringID of Ecosystem to sign into.</p> <p>LoginResponseResponse to <code>LoginRequest</code>challenge bytesRandom byte sequence unique to this login request. If present, two-factor confirmation of login is required. Must be sent back, unaltered, in <code>LoginConfirm</code>.profile AccountProfileAccount profile response. If present, no confirmation of login is required.Show child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is required</p>"},{"location":"reference/services/account-service/#login-confirm","title":"Login Confirm","text":"<p>Deprecated</p> <p>This endpoint has been deprecated; use the Wallet API instead</p> <p>Finalizes the login process.</p> <p>You must pass <code>challenge</code> as it was received in response to Login, along with the confirmation code that was sent in an email.</p> <p>Our SDK will take care of hashing the confirmation code for you.</p>  Sample Request Response Trinsic CLI <pre><code>trinsic account login --email \"bob@example.com\"\n</code></pre> <p>LoginConfirmRequestRequest to finalize login flowchallenge bytesChallenge received from <code>Login</code>confirmation_code_hashed bytesTwo-factor confirmation code sent to account email or phone, hashed using Blake3. Our SDKs will handle this hashing process for you.</p> <p>LoginConfirmResponseResponse to <code>LoginConfirmRequest</code>profile AccountProfileProfile response; must be unprotected using unhashed confirmation code. Our SDKs will handle this process for you, and return to you an authentication token string.Show child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is required</p>"},{"location":"reference/services/account-service/#get-account-info","title":"Get Account Info","text":"<p>Returns the account information (name, email address, phone number, etc.) used to create the currently-active account profile.</p>  Sample Request Response Trinsic CLITypeScriptC#Python <pre><code>trinsic account info\n</code></pre> <pre><code>const info = await accountService.info();\n</code></pre> <pre><code>using System;\nusing System.Diagnostics.CodeAnalysis;\nusing System.IO;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing FluentAssertions;\nusing Grpc.Core;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing Trinsic;\nusing Trinsic.Sdk.Options.V1;\nusing Trinsic.Services.Common.V1;\nusing Trinsic.Services.Provider.V1;\nusing Trinsic.Services.TrustRegistry.V1;\nusing Trinsic.Services.UniversalWallet.V1;\nusing Trinsic.Services.VerifiableCredentials.Templates.V1;\nusing Xunit;\nusing Xunit.Abstractions;\nusing JsonSerializer = System.Text.Json.JsonSerializer;\n\n#pragma warning disable CS0618\n\nnamespace Tests;\n\n[SuppressMessage(\"ReSharper\", \"MethodHasAsyncOverload\")]\n[SuppressMessage(\"ReSharper\", \"InconsistentNaming\")]\npublic class Tests\n{\n// This breaks the CI pipeline, removing DEBUG option.\n// #if DEBUG\n// private const string DefaultEndpoint = \"localhost\";\n// private const int DefaultPort = 5000;\n// private const bool DefaultUseTls = false;\n// #else\nprivate const string DefaultEndpoint = \"staging-internal.trinsic.cloud\";\nprivate const int DefaultPort = 443;\n\n// #endif\n\nprivate readonly ITestOutputHelper _testOutputHelper;\nprivate readonly TrinsicOptions _options;\n\npublic Tests(ITestOutputHelper testOutputHelper)\n{\n_testOutputHelper = testOutputHelper;\n_options = GetTestServiceOptions();\n\n_testOutputHelper.WriteLine($\"Testing endpoint: {_options.FormatUrl()}\");\n}\n\npublic static TrinsicOptions GetTestServiceOptions()\n{\nreturn new()\n{\nServerEndpoint = Environment.GetEnvironmentVariable(\"TEST_SERVER_ENDPOINT\") ?? DefaultEndpoint,\nServerPort = int.TryParse(Environment.GetEnvironmentVariable(\"TEST_SERVER_PORT\"), out var port)\n? port\n: DefaultPort,\nServerUseTls = !bool.TryParse(Environment.GetEnvironmentVariable(\"TEST_SERVER_USE_TLS\"), out var tls) || tls\n};\n}\n\n[Fact(DisplayName = \"SDK Version has 3 decimal places\")]\npublic void TestGetVersion()\n{\nAssert.Equal(\"1.0.0\", TrinsicService.GetSdkVersion());\n}\n\nprivate const string VaccinationCertificateUnsigned = \"TestData/vaccination-certificate-unsigned.jsonld\";\nprivate const string VaccinationCertificateFrame = \"TestData/vaccination-certificate-frame.jsonld\";\n\n[Fact(DisplayName = \"Demo: wallet and credential sample\")]\npublic async Task TestWalletService()\n{\nvar trinsic = new TrinsicService(_options.Clone());\nvar (ecosystem, _) = trinsic.Provider.CreateEcosystem(new());\nvar ecosystemId = ecosystem.Id;\n\n// SETUP ACTORS\n// Create 3 different profiles for each participant in the scenario\nvar allison = await trinsic.Wallet.CreateWalletAsync(new() { EcosystemId = ecosystemId });\nvar clinic = await trinsic.Wallet.CreateWalletAsync(new() { EcosystemId = ecosystemId });\nvar airline = await trinsic.Wallet.CreateWalletAsync(new() { EcosystemId = ecosystemId });\n\nallison.AuthToken.Should().NotBeNullOrWhiteSpace();\nclinic.AuthToken.Should().NotBeNullOrWhiteSpace();\nairline.AuthToken.Should().NotBeNullOrWhiteSpace();\n\ntrinsic = new TrinsicService(_options.CloneWithAuthToken(clinic.AuthToken));\n\nvar info = await trinsic.Wallet.GetMyInfoAsync();\ninfo.Should().NotBeNull();\ninfo.Wallet.Should().NotBeNull();\n\nvar template = await trinsic.Template.CreateAsync(new()\n{\nName = $\"dotnet-tests-{Guid.NewGuid()}\",\nFields =\n{\n{\n\"field\", new() { Type = FieldType.Number }\n}\n}\n});\n\n// ISSUE CREDENTIAL\n// Sign a credential as the clinic and send it to Allison\n// Read the JSON credential data\n\n// issueCredentialSample() {\nvar credential = await trinsic.Credential.IssueFromTemplateAsync(new()\n{\nTemplateId = template.Data.Id,\nValuesJson = JsonConvert.SerializeObject(new\n{\nfield = 123\n})\n});\n// }\n\n_testOutputHelper.WriteLine($\"Credential:\\n{credential.DocumentJson}\");\n\ntry\n{\n// sendCredential() {\nvar sendResponse = await trinsic.Credential.SendAsync(new() { Email = \"example@trinsic.id\" });\n// }\n}\ncatch\n{\n} // We expect this to fail\n\n// STORE CREDENTIAL\ntrinsic = new TrinsicService(_options.CloneWithAuthToken(allison.AuthToken));\n\nvar insertItemResponse =\nawait trinsic.Wallet.InsertItemAsync(new() { ItemJson = credential.DocumentJson });\nvar itemId = insertItemResponse.ItemId;\n\n// getItem() {\nvar getItemResponse = await trinsic.Wallet.GetItemAsync(new GetItemRequest\n{\nItemId = itemId\n});\n//}\n\ngetItemResponse.ItemJson.Should().NotBeEmpty();\n\n// searchWalletBasic() {\nvar walletItems = await trinsic.Wallet.SearchWalletAsync(new());\n// }\n\n_testOutputHelper.WriteLine($\"Last wallet item:\\n{walletItems.Items.Last()}\");\n\n// searchWalletSQL() { \n_ = await trinsic.Wallet.SearchWalletAsync(new()\n{ Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" });\n// }\n\n// SHARE CREDENTIAL\nvar proofRequestJson = await File.ReadAllTextAsync(VaccinationCertificateFrame);\n\nvar credentialProof = await trinsic.Credential.CreateProofAsync(new()\n{\nItemId = itemId,\nRevealDocumentJson = proofRequestJson\n});\n\n_testOutputHelper.WriteLine(\"Proof:\");\n_testOutputHelper.WriteLine(credentialProof.ProofDocumentJson);\n\n// VERIFY CREDENTIAL\ntrinsic = new TrinsicService(_options.CloneWithAuthToken(airline.AuthToken));\n\nvar valid = await trinsic.Credential.VerifyProofAsync(new()\n{\nProofDocumentJson = credentialProof.ProofDocumentJson\n});\n\n_testOutputHelper.WriteLine($\"Verification result: {valid.ValidationResults}\");\nAssert.True(valid.ValidationResults[\"SignatureVerification\"].IsValid);\n\n// DELETE CREDENTIAL\ntrinsic = new TrinsicService(_options.CloneWithAuthToken(allison.AuthToken));\n// deleteItem() {\nawait trinsic.Wallet.DeleteItemAsync(new DeleteItemRequest\n{\nItemId = itemId\n});\n//}\n}\n\n[Fact(DisplayName = \"Demo: Wallet deletion\")]\npublic async Task TestWalletDeletion()\n{\nvar trinsic = new TrinsicService(_options.Clone());\nvar (ecosystem, _) = await trinsic.Provider.CreateEcosystemAsync(new());\nvar createWalletResponse = await trinsic.Wallet.CreateWalletAsync(new() { EcosystemId = ecosystem.Id });\n\n// set the auth token to the newly created wallet\ntrinsic = new TrinsicService(_options.CloneWithAuthToken(createWalletResponse.AuthToken));\n\nvar newWalletInfo = await trinsic.Wallet.GetMyInfoAsync();\nvar walletId = newWalletInfo.Wallet.WalletId;\n\n// deleteWallet() {\nawait trinsic.Wallet.DeleteWalletAsync(new DeleteWalletRequest\n{\nWalletId = walletId\n});\n//}\n}\n\n[Fact(DisplayName = \"Demo: trust registries\")]\npublic async Task TestTrustRegistry()\n{\n_ = $\"https://example.com/{Guid.NewGuid():N}\";\n\n// setup\nvar trinsic = new TrinsicService(_options.Clone());\nvar (_, authToken) = await trinsic.Provider.CreateEcosystemAsync(new());\n\n// setAuthTokenSample() {\ntrinsic = new TrinsicService(_options.CloneWithAuthToken(authToken));\n// }\n\nvar schemaUri = \"https://schema.org/Card\";\n\n// registerIssuerSample() {\nvar didUri = \"did:example:test\";\n_ = await trinsic.TrustRegistry.RegisterMemberAsync(new()\n{\nDidUri = didUri,\nSchemaUri = schemaUri\n});\n// }\n\n// checkIssuerStatus() {\nvar issuerStatus = await trinsic.TrustRegistry.GetMemberAuthorizationStatusAsync(new()\n{\nDidUri = didUri,\nSchemaUri = schemaUri\n});\n// }\n\nissuerStatus.Should().NotBeNull();\nissuerStatus.Status.Should().Be(RegistrationStatus.Current);\n\n// getMember() {\nvar member = await trinsic.TrustRegistry.GetMemberAsync(new()\n{\nDidUri = didUri\n});\n// }\n\nmember.Should().NotBeNull();\nmember.AuthorizedMember.Did.Should().Be(didUri);\n\n// listMembers() {\nvar members = await trinsic.TrustRegistry.ListAuthorizedMembersAsync(new()\n{\nSchemaUri = schemaUri\n});\n// }\n\nmembers.AuthorizedMembers[0].Should().Be(member.AuthorizedMember);\n\n// unregisterIssuer() {\n_ = await trinsic.TrustRegistry.UnregisterMemberAsync(new()\n{\nDidUri = didUri,\nSchemaUri = schemaUri\n});\n// }\n}\n\n[Fact(DisplayName = \"Demo: ecosystem creation and listing\")]\npublic async Task EcosystemTests()\n{\n// setup\nvar trinsic = new TrinsicService(_options.Clone());\n\n// test create ecosystem\n// createEcosystem() {\nvar (ecosystem, authToken) = await trinsic.Provider.CreateEcosystemAsync(new()\n{\nDescription = \"My ecosystem\",\n});\n// }\n\necosystem.Should().NotBeNull();\necosystem.Id.Should().NotBeNull();\necosystem.Id.Should().StartWith(\"urn:trinsic:ecosystems:\");\n\ntrinsic = new TrinsicService(_options.CloneWithAuthToken(authToken));\n\n// test get ecosystem info\n// ecosystemInfo() {\n// }\n\n// inviteParticipant() {\n// }\n\n// invitationStatus() {\n// }\n\n// Test upgrading account DID\nvar accountInfo = await trinsic.Wallet.GetMyInfoAsync();\nvar walletId = accountInfo.Wallet.WalletId;\n\n// Wrap in try-catch as this ecosystem will not presently have DID upgrade permissions\ntry\n{\n// upgradeDid() {\nvar upgradeResponse = await trinsic.Provider.UpgradeDIDAsync(new()\n{\nWalletId = walletId,\nMethod = SupportedDidMethod.Ion,\nIonOptions = new()\n{\nNetwork = IonOptions.Types.IonNetwork.TestNet\n}\n});\n// }\n}\ncatch (RpcException e)\n{\ne.StatusCode.Should().Be(StatusCode.PermissionDenied);\n}\n}\n\n[Fact(DisplayName = \"Demo: template management and credential issuance from template\")]\npublic async Task DemoTemplatesWithIssuance()\n{\nvar trinsic = new TrinsicService(_options.Clone());\nvar (ecosystem, authToken) = await trinsic.Provider.CreateEcosystemAsync(new());\n\ntrinsic = new TrinsicService(_options.CloneWithAuthToken(authToken));\n\n// create example template\n// createTemplate() {\nCreateCredentialTemplateRequest createRequest = new()\n{\nName = \"An Example Credential\",\nTitle = \"Example Credential\",\nDescription = \"A credential for Trinsic's SDK samples\",\nAllowAdditionalFields = false,\nFields =\n{\n{ \"firstName\", new() { Title = \"First Name\", Description = \"Given name of holder\" } },\n{ \"lastName\", new() { Title = \"Last Name\", Description = \"Surname of holder\", Optional = true } },\n{ \"age\", new() { Title = \"Age\", Description = \"Age in years of holder\", Type = FieldType.Number } }\n},\nFieldOrdering =\n{\n{ \"firstName\", new() { Order = 0, Section = \"Name\" } },\n{ \"lastName\", new() { Order = 1, Section = \"Name\" } },\n{ \"age\", new() { Order = 2, Section = \"Miscellanous\" } }\n},\nAppleWalletOptions = new()\n{\nPrimaryField = \"firstName\",\nSecondaryFields = { \"lastName\" },\nAuxiliaryFields = { \"age\" }\n}\n};\n\nvar template = await trinsic.Template.CreateAsync(createRequest);\n// }\n\ntemplate.Should().NotBeNull();\ntemplate.Data.Should().NotBeNull();\ntemplate.Data.Id.Should().NotBeNull();\ntemplate.Data.SchemaUri.Should().NotBeNull();\n\nvar templateId = template.Data.Id;\n\n// update template\n// updateTemplate() {\nUpdateCredentialTemplateRequest updateRequest = new()\n{\nId = templateId,\nTitle = \"New Title\",\nDescription = \"New Description\",\nFields =\n{\n{ \"firstName\", new() { Title = \"New title for firstName\" } },\n{ \"lastName\", new() { Description = \"New description for lastName\" } }\n},\nFieldOrdering =\n{\n{ \"age\", new() { Order = 0, Section = \"Misc\" } },\n{ \"firstName\", new() { Order = 1, Section = \"Full Name\" } },\n{ \"lastName\", new() { Order = 2, Section = \"Full Name\" } },\n},\nAppleWalletOptions = new()\n{\nPrimaryField = \"age\",\nSecondaryFields = { \"firstName\", \"lastName\" }\n}\n};\n\nvar updatedTemplate = await trinsic.Template.UpdateAsync(updateRequest);\n// }\n\nupdatedTemplate.UpdatedTemplate.Title.Should().Be(updateRequest.Title);\n\n// issue credential from this template\nvar values = JsonSerializer.Serialize(new\n{\nfirstName = \"Jane\",\nlastName = \"Doe\",\nage = 42\n});\n\n// issueFromTemplate() {\nvar credentialJson = await trinsic.Credential.IssueFromTemplateAsync(new()\n{\nTemplateId = templateId,\nValuesJson = values\n});\n// }\n\ncredentialJson.Should().NotBeNull();\n\nvar jsonDocument = JsonDocument.Parse(credentialJson.DocumentJson).RootElement.EnumerateObject();\n\njsonDocument.Should().Contain(x =&gt; x.Name == \"id\");\njsonDocument.Should().Contain(x =&gt; x.Name == \"credentialSubject\");\n\n// insertItemWallet() {\nvar insertItemResponse =\nawait trinsic.Wallet.InsertItemAsync(new() { ItemJson = credentialJson.DocumentJson });\n// }\n\nvar itemId = insertItemResponse.ItemId;\n\nvar frame = new JObject\n{\n{ \"@context\", \"https://www.w3.org/2018/credentials/v1\" },\n{ \"type\", new JArray(\"VerifiableCredential\") }\n};\n\n// Create proof from input document\n// createProof() {\nvar proof = await trinsic.Credential.CreateProofAsync(new()\n{\nDocumentJson = credentialJson.DocumentJson,\nRevealDocumentJson = frame.ToString(Formatting.None)\n});\nvar selectiveProof = await trinsic.Credential.CreateProofAsync(new()\n{\nDocumentJson = credentialJson.DocumentJson,\nRevealTemplate = new()\n{\n// The other field, not disclosed, is \"age\"\nTemplateAttributes = { \"firstName\", \"lastName\" }\n}\n});\n// }\n// verifyProof() {\nvar valid = await trinsic.Credential.VerifyProofAsync(new()\n{ ProofDocumentJson = proof.ProofDocumentJson });\n// }\nvalid.IsValid.Should().BeTrue();\n\nvar selectiveValid =\nawait trinsic.Credential.VerifyProofAsync(\nnew() { ProofDocumentJson = selectiveProof.ProofDocumentJson });\nselectiveValid.IsValid.Should().BeTrue();\n\n// Create proof from item id\nvar proof2 = await trinsic.Credential.CreateProofAsync(new()\n{\nItemId = itemId,\nRevealDocumentJson = frame.ToString(Formatting.None)\n});\n\nvar valid2 =\nawait trinsic.Credential.VerifyProofAsync(new() { ProofDocumentJson = proof2.ProofDocumentJson });\n\nvalid2.IsValid.Should().BeTrue();\n\ntry\n{\n// checkCredentialStatus() {\nvar checkResponse = await trinsic.Credential.CheckStatusAsync(new() { CredentialStatusId = \"\" });\n// }\n}\ncatch\n{\n} // We expect this to fail\n\ntry\n{\n// updateCredentialStatus() {\nawait trinsic.Credential.UpdateStatusAsync(new() { CredentialStatusId = \"\", Revoked = true });\n// }\n}\ncatch\n{\n} // We expect this to fail\n\n// getCredentialTemplate() {\nvar getTemplateResponse = await trinsic.Template.GetAsync(new() { Id = template.Data.Id });\n// }\n// searchCredentialTemplate() {\nvar searchTemplateResponse = await trinsic.Template.SearchAsync(new() { Query = \"SELECT * FROM c\" });\n// }\n// deleteCredentialTemplate() {\nvar deleteTemplateResponse = await trinsic.Template.DeleteAsync(new() { Id = template.Data.Id });\n// }\n}\n\n[Fact(DisplayName = \"Decode base64 url encoded string\")]\npublic void DecodeBase64UrlString()\n{\nconst string encoded =\n\"CiVodHRwczovL3RyaW5zaWMuaWQvc2VjdXJpdHkvdjEvb2Jlcm9uEnIKKnVybjp0cmluc2ljOndhbGxldHM6Vzl1dG9pVmhDZHp2RXJZRGVyOGlrRxIkODBkMTVlYTYtMTIxOS00MGZmLWE4NTQtZGI1NmZhOTlmNjMwIh51cm46dHJpbnNpYzplY29zeXN0ZW1zOmRlZmF1bHQaMJRXhevRbornRpA-HJ86WaTLGmQlOuoXSnDT_W2O3u3bV5rS5nKpgrfGKFEbRtIgjyIA\";\n\nvar actual = Base64Url.Decode(encoded);\n\nactual.Should().NotBeEmpty();\n}\n}\n</code></pre> <pre><code>import platform\nimport unittest\n\nfrom samples.credential_demo import credential_demo\nfrom samples.ecosystem_demo import ecosystem_demo\nfrom samples.file_management_demo import file_management_demo\nfrom samples.provider_demo import provider_demo\nfrom samples.templates_demo import templates_demo\nfrom samples.trustregistry_demo import trustregistry_demo\nfrom samples.vaccine_demo import vaccine_demo\nfrom samples.wallet_demo import wallet_demo\nfrom trinsic.proto.services.common.v1 import ResponseStatus\nfrom trinsic.service_base import ResponseStatusException\nfrom trinsic.trinsic_service import TrinsicService\nfrom trinsic.trinsic_util import trinsic_config, set_eventloop_policy\n\n\nclass TestServices(unittest.IsolatedAsyncioTestCase):\n    def __init__(self, method_name=\"runTest\"):\n        super().__init__(methodName=method_name)\n        set_eventloop_policy()\n\n    def test_python_platform(self):\n        print(f\"Running on: {platform.platform()}\")\n\n    def test_responsestatus_exception(self):\n        with self.assertRaises(ResponseStatusException) as rse:\n            ResponseStatusException.assert_success(\n                ResponseStatus.UNKNOWN_ERROR, \"test should fail\"\n            )\n        self.assertEqual(\n            f\"test should fail, status={repr(ResponseStatus.UNKNOWN_ERROR)}\",\n            str(rse.exception),\n        )\n        ResponseStatusException.assert_success(\n            ResponseStatus.SUCCESS, \"This should NOT fail\"\n        )\n\n    def test_default_constructor(self):\n        TrinsicService()\n\n    async def test_lib_main(self):\n        from trinsic import __main__\n\n        await __main__.demo()\n\n    async def test_credential_demo(self):\n        await credential_demo()\n\n    async def test_ecosystem_demo(self):\n        await ecosystem_demo()\n\n    async def test_file_management_demo(self):\n        await file_management_demo()\n\n    async def test_provider_service_demo(self):\n        await provider_demo()\n\n    async def test_templates_demo(self):\n        await templates_demo()\n\n    async def test_trust_registry_demo(self):\n        await trustregistry_demo()\n\n    async def test_vaccine_demo(self):\n        await vaccine_demo()\n\n    async def test_wallet_demo(self):\n        await wallet_demo()\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre> <p>AccountInfoRequestRequest for information about the account used to make the requestThis message has no fields</p> <p>AccountInfoResponseInformation about the account used to make the requestdetails AccountDetailsThe account details associated with the calling request contextShow child attributesdetails.name optional stringAccount namedetails.email optional stringEmail address of account.details.sms optional stringSMS number including country codewallet_id stringThe wallet ID associated with this accountdevice_id stringThe device ID associated with this account sessionecosystem_id stringThe ecosystem ID within which this account residespublic_did stringThe public DID associated with this account. This DID is used as the <code>issuer</code> when signing verifiable credentialsauth_tokens WalletAuthToken[]List of active authentication tokens for this wallet. This list does not contain the issued token, only metadata such as ID, description, and creation date.Show child attributesauth_tokens[i].id stringUnique identifier for the token. This field will match the <code>DeviceId</code> in the WalletAuthDataauth_tokens[i].description stringDevice name/descriptionauth_tokens[i].date_created stringDate when the token was created in ISO 8601 format</p> <p>Note</p> <p>This call returns the information associated with the authentication token used to create the request; therefore, it is not possible to pass a different authentication token to this call. Otherwise, Trinsic's zero-knowledge proof authentication scheme would be violated.</p> <p>When using the CLI, this will return information for the account most recently logged in to.</p> <p>When using the SDK, this will return information for the authentication token stored in the <code>AccountService</code> instance's <code>ServiceOptions.AuthToken</code> field, which will be the account most recently logged in to, unless you have manually set this value yourself.</p>"},{"location":"reference/services/credential-service/","title":"Credential Service","text":"<p>The Credential Service exposes functionality for issuance, proof generation, verification, and revocation of Verifiable Credentials.</p> <p>Signature Format</p> <p>The Credential service currently supports BBS+ Signatures , which enable selective disclosure of credential fields during proof generation.</p> <p>Credentials are signed, and proofs are created, using a key pair unique to the signing / holding wallet. This key pair is created and managed by Trinsic upon account creation.</p>"},{"location":"reference/services/credential-service/#issue-credential-from-template","title":"Issue Credential from Template","text":"<p>Issues a credential from a previously-defined template.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic vc issue-from-template [OPTIONS] --template-id &lt;ID&gt;\n\n# OPTIONS\n# --out &lt;OUTPUT_FILE&gt;     (Optional) Output file to store the issued credential\n# --values-data &lt;JSON&gt;    The JSON values of the credential subject\n# --values-file &lt;FILE&gt;    The file with JSON values of the credential subject\n</code></pre> <pre><code>let request = IssueFromTemplateRequest.fromPartial({\ntemplateId: templateResponse?.data?.id ?? \"\",\nvaluesJson: JSON.stringify({\nname: \"Alice\",\nnumberOfBags: 2,\ndateOfBirth: new Date(\"1/1/2000\").toISOString(),\nvaccinated: true,\n}),\n});\n\nlet response = await trinsic.credential().issueFromTemplate(request);\n</code></pre> <pre><code>var credentialJson = await trinsic.Credential.IssueFromTemplateAsync(new()\n{\nTemplateId = templateId,\nValuesJson = values\n});\n</code></pre> <pre><code>values = json.dumps({\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"age\": \"42\"})\nissue_response = await trinsic_service.credential.issue_from_template(\n    request=IssueFromTemplateRequest(\n        template_id=template.data.id, values_json=values\n    )\n)\n</code></pre> <pre><code>issueTemplateResponse, err := trinsic.Credential().IssueFromTemplate(context.Background(),\n&amp;credential.IssueFromTemplateRequest{\nValuesJson: valuesJson,\nTemplateId: templateId,\n})\n</code></pre> <pre><code>var valuesMap = new HashMap&lt;String, Object&gt;();\nvaluesMap.put(\"firstName\", \"Jane\");\nvaluesMap.put(\"lastName\", \"Doe\");\nvaluesMap.put(\"age\", 42);\nvar valuesJson = new Gson().toJson(valuesMap);\nvar issueResponse =\ntrinsic\n.credential()\n.issueFromTemplate(\nIssueFromTemplateRequest.newBuilder()\n.setTemplateId(templateId)\n.setValuesJson(valuesJson)\n.build())\n.get();\n</code></pre> <p>IssueFromTemplateRequestRequest to create and sign a JSON-LD Verifiable Credential from a template using public key tied to callertemplate_id stringID of template to usevalues_json stringJSON document string with keys corresponding to the fields of the template referenced by <code>template_id</code>save_copy boolSave a copy of the issued credential to this user's wallet. This copy will only contain the credential data, but not the secret proof value. Issuers may use this data to keep track of the details for revocation status.expiration_date stringThe ISO8601 expiration UTC date of the credential. This is a reserved field in the VC specification. If specified, the issued credential will contain an expiration date. https://www.w3.org/TR/vc-data-model/#expirationinclude_governance boolIf true, the issued credential will contain an attestation of the issuer's membership in the ecosystem's governance framework.</p> <p>IssueFromTemplateResponseResponse to <code>IssueFromTemplateRequest</code>document_json stringVerifiable Credential document, in JSON-LD form, constructed from the specified template and values; signed with public key tied to caller of <code>IssueFromTemplateRequest</code></p>"},{"location":"reference/services/credential-service/#add-governance-information-to-issued-credential","title":"Add governance information to issued credential","text":"<p>In order to attach governance information to the credential, issuers must request this explicitly by specifying the parameter <code>framework_id</code> in the above request. The framework identifier references the ecosystem governance framework that the issuer is authorized to issue credentials of the designated type (schema). This identifier has the format <code>urn:egf:&lt;ecosystem&gt;:&lt;type&gt;</code>.</p> <p>When this parameter is specified, the issued credential will contain extended information in the <code>issuer</code> field to assert authorization in the given governance framework. The framework identifier will be in the <code>issuer.trustRegistry</code> field. Here's an example of a VC with extended issuer information:</p> <pre><code>\"issuer\": {\n\"id\": \"did:key:z5TcEFAQPu7RkrBCMCJDGgVziV\",\n\"type\": \"AuthoritativeMember\"\n\"governanceFramework\": \"https://acme.org/authorized-issuers\",\n\"trustRegistry\": \"urn:egf:acme:92f21b4cb3bc48dd8bb19a872f03afca\",\n}\n</code></pre> <p>See Trust Registry Service for more information on using governance in your ecosystem.</p>"},{"location":"reference/services/credential-service/#check-revocation-status","title":"Check Revocation Status","text":"<p>Checks a credential's revocation status by its <code>credential_status_id</code>.</p> <p>A <code>credential_status_id</code> can be found in a credential's <code>credentialStatus.id</code> field, if present.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic vc get-status --credential-status-id &lt;ID&gt;\n</code></pre> <pre><code>let checkStatusResponse = await trinsic\n.credential()\n.checkStatus(CheckStatusRequest.fromPartial({}));\n</code></pre> <pre><code>var checkResponse = await trinsic.Credential.CheckStatusAsync(new() { CredentialStatusId = \"\" });\n</code></pre> <pre><code>#     check_response = await trinsic_service.credential.check_status(\n#         request=CheckStatusRequest(credential_status_id=\"\")\n#     )\n</code></pre> <pre><code>status, err := trinsic.Credential().CheckStatus(context.Background(), &amp;credential.CheckStatusRequest{CredentialStatusId: \"\"})\n</code></pre> <pre><code>var checkStatusResponse =\ntrinsic.credential().checkStatus(CheckStatusRequest.newBuilder().build()).get();\n</code></pre> <p>CheckStatusRequestRequest to check a credential's revocation statuscredential_status_id stringCredential Status ID to check. This is not the same as the credential's ID.</p> <p>CheckStatusResponseResponse to <code>CheckStatusRequest</code>revoked boolThe credential's revocation status</p>"},{"location":"reference/services/credential-service/#update-revocation-status","title":"Update Revocation Status","text":"<p>Updates the revocation status of a credential (revoke or unrevoke).</p> <p>A <code>credential_status_id</code> can be found in a credential's <code>credentialStatus.id</code> field, if present.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code># Revoke a credential\ntrinsic vc update-status --revoked --credential-status-id &lt;ID&gt;\n\n# Unrevoke a credential\ntrinsic vc update-status --unrevoked --credential-status-id &lt;ID&gt;\n</code></pre> <pre><code>let updateStatusResponse = await trinsic\n.credential()\n.updateStatus(UpdateStatusRequest.fromPartial({}));\n</code></pre> <pre><code>await trinsic.Credential.UpdateStatusAsync(new() { CredentialStatusId = \"\", Revoked = true });\n</code></pre> <pre><code>#     update_response = await trinsic_service.credential.update_status(\n#         request=UpdateStatusRequest(credential_status_id=\"\", revoked=True)\n#     )\n</code></pre> <pre><code>updateStatusResponse, err := trinsic.Credential().UpdateStatus(context.Background(), &amp;credential.UpdateStatusRequest{CredentialStatusId: \"\", Revoked: true})\n</code></pre> <pre><code>trinsic.credential().updateStatus(UpdateStatusRequest.newBuilder().build());\n</code></pre> <p>UpdateStatusRequestRequest to update a credential's revocation statuscredential_status_id stringCredential Status ID to update. This is not the same as the credential's ID.revoked boolNew revocation status of credential</p> <p>UpdateStatusResponseResponse to <code>UpdateStatusRequest</code>This message has no fields</p>"},{"location":"reference/services/credential-service/#create-proof","title":"Create Proof","text":"<p>Creates and signs a proof for a valid JSON-LD credential, using the BBS+ Signature Suite.</p> <p>If the credential is stored in a Trinsic cloud wallet, pass its <code>item_id</code>; otherwise, pass the raw JSON-LD credential via <code>document_json</code>.</p> <p>Selective Disclosure</p> <p>BBS+ Signatures support the ability to generate a proof for a subset of a credential's fields, instead of every field.</p> <p>This enables increased user privacy: fields which aren't included in <code>reveal_document_json</code> will not be present in the generated proof.</p> <ol> <li>If <code>reveal_document_json</code> is passed, a proof will be generated for only the fields specified. This is a JSON-LD frame.</li> <li>Rather than formulating a complete JSON-LD frame, you can instead provide a list of proof attributes to reveal, and the service will construct the JSON-LD proof frame internally</li> <li>If neither is provided, the entire proof will be returned.</li> </ol>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic vc create-proof --document-id &lt;STRING&gt; --out &lt;OUTPUT_FILE&gt; --reveal-document &lt;JSONLD_FRAME_FILE&gt;\n</code></pre> <pre><code>let proof = await trinsic.credential().createProof(\nCreateProofRequest.fromPartial({\nitemId: insertItemResponse.itemId\n})\n);\nlet selectiveProof = await trinsic.credential().createProof(\nCreateProofRequest.fromPartial({\nitemId: insertItemResponse.itemId,\nrevealTemplate: {\ntemplateAttributes: [\"firstName\", \"lastName\"],\n},\n})\n);\n</code></pre> <pre><code>var proof = await trinsic.Credential.CreateProofAsync(new()\n{\nDocumentJson = credentialJson.DocumentJson,\nRevealDocumentJson = frame.ToString(Formatting.None)\n});\nvar selectiveProof = await trinsic.Credential.CreateProofAsync(new()\n{\nDocumentJson = credentialJson.DocumentJson,\nRevealTemplate = new()\n{\n// The other field, not disclosed, is \"age\"\nTemplateAttributes = { \"firstName\", \"lastName\" }\n}\n});\n</code></pre> <pre><code>proof_response = await trinsic_service.credential.create_proof(\n    request=CreateProofRequest(document_json=credential_json)\n)\nselective_proof_response = await trinsic_service.credential.create_proof(\n    request=CreateProofRequest(\n        document_json=credential_json,\n        reveal_template=RevealTemplateAttributes(template_attributes=[\"firstName\"]),\n    )\n)\n</code></pre> <pre><code>request := &amp;credential.CreateProofRequest{\nProof: &amp;credential.CreateProofRequest_DocumentJson{\nDocumentJson: credentialJson,\n},\n}\n\nproofResponse, err := trinsic.Credential().CreateProof(context.Background(), request)\n\nselectiveRequest := &amp;credential.CreateProofRequest{\nProof: &amp;credential.CreateProofRequest_DocumentJson{\nDocumentJson: credentialJson,\n},\nDisclosure: &amp;credential.CreateProofRequest_RevealTemplate{RevealTemplate: &amp;credential.RevealTemplateAttributes{TemplateAttributes: []string{\"name\"}}},\n}\n\nselectiveResponse, err2 := trinsic.Credential().CreateProof(context.Background(), selectiveRequest)\n</code></pre> <pre><code>var createProofResponse =\ntrinsic\n.credential()\n.createProof(\nCreateProofRequest.newBuilder().setDocumentJson(signedCredentialJson).build())\n.get();\n\nvar credentialProof = createProofResponse.getProofDocumentJson();\n\nvar selectiveProofResponse =\ntrinsic\n.credential()\n.createProof(\nCreateProofRequest.newBuilder()\n.setDocumentJson(signedCredentialJson)\n.setRevealTemplate(\nRevealTemplateAttributes.newBuilder()\n.addTemplateAttributes(\"batchNumber\")\n.build())\n.build())\n.get();\n\nvar selectiveProof = selectiveProofResponse.getProofDocumentJson();\n</code></pre> <p>CreateProofRequestRequest to create a proof for a Verifiable Credential using public key tied to caller. Either <code>item_id</code> or <code>document_json</code> may be provided, not both.reveal_document_json stringA valid JSON-LD frame describing which fields should be revealed in the generated proof. If unspecified, all fields in the document will be revealedreveal_template RevealTemplateAttributesInformation about what sections of the document to revealShow child attributesreveal_template.template_attributes string[]A list of document attributes to reveal. If unset, all attributes will be returned.item_id stringID of wallet item stored in a Trinsic cloud walletdocument_json stringA valid JSON-LD Verifiable Credential document string with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet.use_verifiable_presentation boolWrap the output in a verifiable presentation. If the credential used in the proof is bound to the holder DID, the output will always use a verifiable presentation and this field will be ignored.nonce optional bytesNonce value used to derive the proof. If not specified, a random nonce will be generated. This value may be represented in base64 format in the proof model.</p> <p>CreateProofResponseResponse to <code>CreateProofRequest</code>proof_document_json stringValid JSON-LD proof for the specified credential</p>"},{"location":"reference/services/credential-service/#verify-proof","title":"Verify Proof","text":"<p>Verifies a proof for validity and authenticity. Only supports BBS+ Signatures at present.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code># The JSONLD_FILE refers to the proof document obtained from a CreateProofResponse\ntrinsic vc issuer verify-proof --proof-document &lt;JSONLD_FILE&gt;\n</code></pre> <pre><code>let verifyResponse = await trinsic.credential().verifyProof({\nproofDocumentJson: proof.proofDocumentJson,\n});\n\n\u22ef\n\nproofDocumentJson: selectiveProof.proofDocumentJson,\n</code></pre> <pre><code>var valid = await trinsic.Credential.VerifyProofAsync(new()\n{ ProofDocumentJson = proof.ProofDocumentJson });\n</code></pre> <pre><code>verify_result = await trinsic_service.credential.verify_proof(\n    request=VerifyProofRequest(proof_document_json=credential_proof)\n)\nselective_verify_result = await trinsic_service.credential.verify_proof(\n    request=VerifyProofRequest(\n        proof_document_json=selective_proof_response.proof_document_json\n    )\n)\n</code></pre> <pre><code>verifyResponse, err := trinsic.Credential().VerifyProof(context.Background(), &amp;credential.VerifyProofRequest{\nProofDocumentJson: proofJson,\n})\n</code></pre> <pre><code>var verifyProofResponse =\ntrinsic\n.credential()\n.verifyProof(\nVerifyProofRequest.newBuilder().setProofDocumentJson(credentialProof).build())\n.get();\n\nboolean isValid = verifyProofResponse.getIsValid();\n</code></pre> <p>VerifyProofRequestRequest to verify a proofproof_document_json stringJSON-LD proof document string to verify</p> <p>VerifyProofResponseResponse to <code>VerifyProofRequest</code>is_valid boolWhether all validations in <code>validation_results</code> passedvalidation_results map(string -&gt; ValidationMessage)Results of each validation check performed, such as schema conformance, revocation status, signature, etc. Detailed results are provided for failed validations.Show child attributesvalidation_results[key].is_valid boolWhether this validation check passedvalidation_results[key].messages string[]If validation failed, contains messages explaining why</p> Validation Results <p>The verification process performs a number of validations, each of which may fail independently of the others.</p> <p>For example, a credential may be expired or revoked, but otherwise perfectly valid.</p> <p><code>validation_results</code> contains an entry for each of the following verification steps:</p> Name Description <code>SignatureVerification</code> The cryptographic proof over the entire Verifiable Credential, specifically using BBS+ Proof of Signature <code>CredentialStatus</code> (if supported by credential) Checks if credential has been revoked <code>SchemaConformance</code> Ensures credential conforms with its schema. It is possible to issue a credential omitting a required field (as captured in the credential template). If your use case allows this kind of omission, you can ignore this validation entry. <code>TrustRegistryMembership</code> (if relevant) Verifies that credential issuer is an authorized member of the credential's governing Trust Registry <code>IssuerIsSigner</code> Document <code>issuer</code> is same DID as document signer. If false, it is not safe to assume that the claimed <code>issuer</code> actually issued the credential."},{"location":"reference/services/credential-service/#exchange-credentials","title":"Exchange Credentials","text":""},{"location":"reference/services/credential-service/#send-via-email","title":"Send via Email","text":"<p>Sends a credential to a user via email.</p> <p>The specified email address must be tied to an existing account in the same ecosystem.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic vc send --email &lt;EMAIL_ADDRESS&gt; --item &lt;FILE&gt;\n</code></pre> <pre><code>await trinsic.credential().send(SendRequest.fromPartial({\nemail: \"\",\ndocumentJson: JSON.stringify({}),\n}));\n</code></pre> <pre><code>var sendResponse = await trinsic.Credential.SendAsync(new() { Email = \"example@trinsic.id\" });\n</code></pre> <pre><code>send_response = await trinsic_service.credential.send(\n    request=SendRequest(\n        document_json=credential_json, email=\"example@trinsic.id\"\n    )\n)\n</code></pre> <pre><code>sendResponse, err := trinsic.Credential().Send(context.Background(), &amp;credential.SendRequest{\nDeliveryMethod: &amp;credential.SendRequest_Email{\nEmail: \"example@trinsic.id\",\n},\nDocumentJson: credentialJson,\n})\n</code></pre> <pre><code>trinsic\n.credential()\n.send(\nSendRequest.newBuilder()\n.setDocumentJson(signedCredentialJson)\n.setEmail(recipientEmail)\n.build());\n</code></pre> <p>SendRequestRequest to send a document to another user's walletemail stringEmail address of user to whom you'll send the itemwallet_id stringWallet ID of the recipient within the ecosystemdid_uri stringDID URI of the recipientphone_number stringSMS of user to whom you'll send the itemsend_notification boolSend email notification that credential has been sent to a walletdocument_json stringJSON document to send to recipient</p> <p>SendResponseResponse to <code>SendRequest</code>This message has no fields</p> <p>Alternative Exchange Protocols</p> <p>Credentials may only be sent to a wallet via email address or with the InsertItem call.</p> <p>There are a number of ongoing industry efforts to standardize exchange protocols, such as:</p> <ul> <li>DIDComm Messaging </li> <li>Wallet And Credential Interactions </li> <li>OpenID Connect Credential Provider </li> </ul> <p>We aim to provide support for these methods as they mature.</p>"},{"location":"reference/services/file-management-service/","title":"File Management Service","text":"<p>The File Management Service allows files to be uploaded and thereafter managed by Issuers.</p> <p>Restricted Experimental Service</p> <p>This service exists as an experiment to enable rapid prototyping of certain use-cases, such as linking to files / binary data within Credentials.</p> <p>Ecosystems must be on a paid plan in order to make use of this service.</p> <p>Data Security Precautions</p> <p>Any file uploaded through this service is accessible over the internet to anyone who has the URL.</p> <p>Although the URLs are extremely long and securely generated (thus are extremely costly to brute force), we do not recommend storing highly-sensitive files or documents via the File Management Service.</p> <p>For example, government-issued IDs, social security cards, birth certificates, passports, etc. should not be uploaded to this service.</p>"},{"location":"reference/services/file-management-service/#upload-file","title":"Upload File","text":"<p>Uploads a file to Trinsic's CDN.</p> <p><code>contents</code> must be the raw contents of the file, with a current maximum of 4 megabytes (<code>4,194,304</code> bytes).</p> <p><code>mime_type</code> must be the MIME Type  of the file you are uploading. This determines the file's resulting extension, as well as how it is treated when opened by a browser (displayed as an image, downloaded directly, etc.).</p> <p>If you do not know the MIME Type of the file being uploaded, or otherwise cannot provide it, use <code>application/octet-stream</code> as a safe default.</p> <p>The URL returned by this endpoint will contain a Hashlink  query parameter, in the form of <code>?hl={hash}</code>. The value of <code>hash</code> is a Multihash  string, encoding the hash of the uploaded file contents.</p> <p>The <code>hl</code> parameter is expected to be included with the URL whenever it is issued in a credential. This allows the cryptographic signature to cover the contents of the file (through its hash), without having to include the entire raw file contents in the credential itself.</p>  Sample Request Response TypeScriptC#PythonGoJava <pre><code>// Get raw bytes of string\nconst fileBytes = new TextEncoder().encode(\"Hello, world!\");\nconst fileMimeType = \"application/text\";\n\nconst uploadResponse = await trinsic.fileManagement().uploadFile(\nUploadFileRequest.fromPartial({\ncontents: fileBytes,\nmimeType: fileMimeType,\n})\n);\n</code></pre> <pre><code>// Get raw bytes of string\nvar fileBytes = Encoding.UTF8.GetBytes(\"Hello, world!\");\nconst string fileMimeType = \"application/text\";\n\nvar uploadResponse = trinsic.FileManagement.UploadFile(new UploadFileRequest {\nContents = ByteString.CopyFrom(fileBytes),\nMimeType = fileMimeType\n});\n</code></pre> <pre><code># Get raw bytes of string\nfile_bytes = bytes(\"Hello, world!\", \"utf-8\")\nfile_mime_type = \"application/text\"\n\nupload_response = await trinsic.file_management.upload_file(\n    request=UploadFileRequest(file_bytes, file_mime_type)\n)\n</code></pre> <pre><code>uploadResponse, err := trinsic.FileManagement().UploadFile(context.Background(),\n&amp;filemanagement.UploadFileRequest{\nContents: []byte(\"Hello, world!\"),\nMimeType: \"application/text\",\n})\n</code></pre> <pre><code>// Get raw bytes of string\nbyte[] fileBytes = \"Hello, world!\".getBytes(StandardCharsets.UTF_8);\nString fileMimeType = \"application/text\";\n\nvar uploadResponse =\ntrinsic\n.fileManagement()\n.uploadFile(\nUploadFileRequest.newBuilder()\n.setContents(ByteString.copyFrom(fileBytes))\n.setMimeType(fileMimeType)\n.build())\n.get();\n</code></pre> <p>UploadFileRequestRequest to upload a file to Trinsic's CDNcontents bytesRaw content of filemime_type stringMIME type describing file contents</p> <p>UploadFileResponseResponse to <code>UploadFileRequest</code>uploaded_file FileInformation about newly-uploaded fileShow child attributesuploaded_file.id stringID of file, generated randomly by Trinsic on uploaduploaded_file.uploader_id stringWallet ID of uploaderuploaded_file.size uint32Size, in bytes, of fileuploaded_file.mime_type stringUploader-provided MIME type of fileuploaded_file.uploaded stringISO 8601 timestamp of when file was uploaded to Trinsicuploaded_file.url stringCDN URL of file</p>"},{"location":"reference/services/file-management-service/#get-file","title":"Get File","text":"<p>Fetches information about a file via its ID.</p> <p>Only files uploaded by the calling account will be returned.</p>  Sample Request Response TypeScriptC#PythonGoJava <pre><code>const getFileResponse = await trinsic.fileManagement().getFile(\nGetFileRequest.fromPartial({\nid: fileId,\n})\n);\n</code></pre> <pre><code>var getFileResponse = trinsic.FileManagement.GetFile(new GetFileRequest {\nId = fileId\n});\n</code></pre> <pre><code>get_response = await trinsic.file_management.get_file(\n    request=GetFileRequest(file_id)\n)\n</code></pre> <pre><code>getFileResponse, err := trinsic.FileManagement().GetFile(context.Background(),\n&amp;filemanagement.GetFileRequest{\nId: fileId,\n})\n</code></pre> <pre><code>var getFileResponse =\ntrinsic.fileManagement().getFile(GetFileRequest.newBuilder().setId(fileId).build()).get();\n</code></pre> <p>GetFileRequestRequest to fetch information about a stored fileid stringID of file to fetch</p> <p>GetFileResponseResponse to <code>GetFileRequest</code>file FileFile specified by <code>id</code> parameter of <code>GetFileRequest</code>.Show child attributesfile.id stringID of file, generated randomly by Trinsic on uploadfile.uploader_id stringWallet ID of uploaderfile.size uint32Size, in bytes, of filefile.mime_type stringUploader-provided MIME type of filefile.uploaded stringISO 8601 timestamp of when file was uploaded to Trinsicfile.url stringCDN URL of file</p>"},{"location":"reference/services/file-management-service/#delete-file","title":"Delete File","text":"<p>Deletes a file from Trinsic's CDN.</p> <p>Only files uploaded by the calling account may be deleted.</p>  Sample Request Response TypeScriptC#PythonGoJava <pre><code>await trinsic.fileManagement().deleteFile(\nDeleteFileRequest.fromPartial({\nid: fileId,\n})\n);\n</code></pre> <pre><code>trinsic.FileManagement.DeleteFile(new DeleteFileRequest {\nId = fileId\n});\n</code></pre> <pre><code>await trinsic.file_management.delete_file(request=DeleteFileRequest(file_id))\n</code></pre> <pre><code>deleteResponse, err := trinsic.FileManagement().DeleteFile(context.Background(),\n&amp;filemanagement.DeleteFileRequest{\nId: fileId,\n})\n</code></pre> <pre><code>trinsic.fileManagement().deleteFile(DeleteFileRequest.newBuilder().setId(fileId).build()).get();\n</code></pre> <p>DeleteFileRequestRequest to delete a file from Trinsic's CDN by IDid stringID of file to delete</p> <p>DeleteFileResponseResponse to <code>DeleteFileRequest</code>. Empty payload.This message has no fields</p>"},{"location":"reference/services/file-management-service/#list-files","title":"List Files","text":"<p>Queries the files uploaded by the calling account.</p>  Sample Request Response TypeScriptC#PythonGoJava <pre><code>const listFilesResponse = await trinsic.fileManagement().listFiles(\nListFilesRequest.fromPartial({\nquery: \"SELECT * FROM _ ORDER BY _.uploadDate DESC OFFSET 0 LIMIT 100\",\n})\n);\n</code></pre> <pre><code>var listFilesResponse = trinsic.FileManagement.ListFiles(new ListFilesRequest {\nQuery = \"SELECT * FROM _ ORDER BY _.uploadDate DESC OFFSET 0 LIMIT 100\"\n});\n</code></pre> <pre><code>list_response = await trinsic.file_management.list_files(\n    request=ListFilesRequest(\n        query=\"SELECT * FROM _ ORDER BY _.uploadDate DESC OFFSET 0 LIMIT 100\"\n    )\n)\n</code></pre> <pre><code>listFilesResponse, err := trinsic.FileManagement().ListFiles(context.Background(),\n&amp;filemanagement.ListFilesRequest{\nQuery: \"SELECT * FROM _ ORDER BY _.uploadDate DESC OFFSET 0 LIMIT 100\",\n})\n</code></pre> <pre><code>var listFilesResponse =\ntrinsic\n.fileManagement()\n.listFiles(\nListFilesRequest.newBuilder()\n.setQuery(\"SELECT * FROM _ ORDER BY _.uploadDate DESC OFFSET 0 LIMIT 100\")\n.build())\n.get();\n</code></pre> <p>ListFilesRequestRequest to list filesquery stringQuery to search with. If not specified, will return the most recent 100 files.continuation_token optional stringToken provided by previous <code>ListFilesRequest</code> if more data is available for query</p> <p>ListFilesResponseResponse to <code>ListFilesRequest</code>files File[]Files found by queryShow child attributesfiles[i].id stringID of file, generated randomly by Trinsic on uploadfiles[i].uploader_id stringWallet ID of uploaderfiles[i].size uint32Size, in bytes, of filefiles[i].mime_type stringUploader-provided MIME type of filefiles[i].uploaded stringISO 8601 timestamp of when file was uploaded to Trinsicfiles[i].url stringCDN URL of filehas_more_results boolWhether more results are available for this query via <code>continuation_token</code>continuation_token stringToken to fetch next set of results via <code>ListFilesRequest</code></p>"},{"location":"reference/services/file-management-service/#get-storage-statistics","title":"Get Storage Statistics","text":"<p>Returns aggregate statistics regarding the files uploaded by the calling account.</p>  Sample Request Response TypeScriptC#PythonGoJava <pre><code>const getStorageStatsResponse = await trinsic\n.fileManagement()\n.getStorageStats();\n</code></pre> <pre><code>var getStorageStatsResponse = trinsic.FileManagement.GetStorageStats();\n</code></pre> <pre><code>get_stats_response = await trinsic.file_management.get_storage_stats()\n</code></pre> <pre><code>getStatsResponse, err := trinsic.FileManagement().GetStorageStats(context.Background())\n</code></pre> <pre><code>var getStatsResponse = trinsic.fileManagement().getStorageStats().get();\n</code></pre> <p>GetStorageStatsRequestRequest to get statistics about files uploaded by this accountThis message has no fields</p> <p>GetStorageStatsResponseResponse to <code>GetStorageStatsRequest</code>stats StorageStatsStatistics about files uploaded by the calling accountShow child attributesstats.num_files uint32Number of files uploaded by this accountstats.total_size uint64Sum total size of all files, in bytes</p>"},{"location":"reference/services/provider-service/","title":"Provider Service","text":"<p>The Provider Service enables the creation and management of ecosystems.</p> <p>Named vs Anonymous ecosystems</p> <p>There are two types of ecosystems: named and anonymous.</p> <p>Named ecosystems are suitable for production, and will be prepared for you by Trinsic during onboarding.</p> <p>Anonymous ecosystems have auto-generated names (such as <code>eager-elephant-94jkn5h</code>), and may be created by anyone at any time.</p> <p>Using an anonymous ecosystem for purposes other than prototyping and testing is considered an unauthorized use of Trinsic's platform.</p>"},{"location":"reference/services/provider-service/#create-ecosystem","title":"Create Ecosystem","text":"<p>Creates a new ecosystem, along with a root controlling account.</p> <p>If <code>name</code> is left empty, an anonymous ecosystem will be created.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic provider create-ecosystem --name &lt;ECOSYSTEM_NAME&gt; --email &lt;OWNER_EMAIL&gt;\n</code></pre> <pre><code>let createResponse = await trinsic.provider().createEcosystem(\nCreateEcosystemRequest.fromPartial({\ndescription: \"Test ecosystem from Node\",\n})\n);\n</code></pre> <pre><code>var (ecosystem, authToken) = await trinsic.Provider.CreateEcosystemAsync(new()\n{\nDescription = \"My ecosystem\",\n});\n</code></pre> <pre><code>actual_create = await trinsic_service.provider.create_ecosystem(\n    request=CreateEcosystemRequest(description=\"My ecosystem\")\n)\n</code></pre> <pre><code>actualCreate, err := trinsic.Provider().CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\nDescription: \"My ecosystem\",\nDomain:      \"https://example.com\",\n})\n</code></pre> <pre><code>var response =\ntrinsic\n.provider()\n.createEcosystem(\nCreateEcosystemRequest.newBuilder()\n.setDescription(\"My ecosystem\")\n.setDomain(\"https://example.com\")\n.build())\n.get();\n</code></pre> <p>CreateEcosystemRequestRequest to create an ecosystemname optional stringGlobally unique name for the Ecosystem. This name will be part of the ecosystem-specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen. If not passed, ecosystem name will be auto-generated.description optional stringEcosystem descriptiondetails AccountDetailsThe account details of the owner of the ecosystemShow child attributesdetails.name optional stringAccount namedetails.email optional stringEmail address of account.details.sms optional stringSMS number including country codedomain stringNew domain URL</p> <p>CreateEcosystemResponseResponse to <code>CreateEcosystemRequest</code>ecosystem EcosystemDetails of the created ecosystemShow child attributesecosystem.id stringURN of the ecosystemecosystem.name stringGlobally unique name for the ecosystemecosystem.description stringEcosystem descriptionprofile AccountProfileAccount profile for auth of the owner of the ecosystemShow child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is requiredconfirmation_method ConfirmationMethodIndicates if confirmation of account is required.Show enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is required</p>"},{"location":"reference/services/provider-service/#upgrade-wallet-did","title":"Upgrade Wallet DID","text":"<p>Restricted API</p> <p>This feature is not yet publicly available, and the list of supported DID Methods is not final.</p> <p>Please contact Trinsic to enable this endpoint on your account.</p> <p>Ledger Interactions</p> <p>Depending on the DID Method chosen, you may be responsible for ledger write fees; additionally, there are some logistical concerns to be aware of.</p> <p>Click here to learn more. </p> <p>Upgrades a wallet's DID from the default <code>did:key</code> to another DID Method. This endpoint may only be called by an ecosystem provider.</p> <p>Trinsic will register a DID Document for you, and update the wallet's <code>public_did</code> property to the newly-registered DID. Credentials previously issued by this wallet will not have their <code>issuer</code> field updated to the new DID, but they will still verify correctly.</p> <p>Presently, once a wallet's DID has been upgraded, its DID Method cannot be changed again. However, it is possible to perform further upgrades within a method, to go from a testing to production network (for example, <code>did:ion:test</code> to <code>did:ion</code>). </p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic provider upgrade-did --wallet-id {wallet_id} --method ion --method-options testnet\n</code></pre> <pre><code>let upgradeResponse = await trinsic.provider().upgradeDID(\nUpgradeDidRequest.fromPartial({\nwalletId: walletId,\nmethod: SupportedDidMethod.ION,\nionOptions: IonOptions.fromPartial({\nnetwork: IonOptions_IonNetwork.TestNet,\n}),\n})\n);\n</code></pre> <pre><code>var upgradeResponse = await trinsic.Provider.UpgradeDIDAsync(new()\n{\nWalletId = walletId,\nMethod = SupportedDidMethod.Ion,\nIonOptions = new()\n{\nNetwork = IonOptions.Types.IonNetwork.TestNet\n}\n});\n</code></pre> <pre><code>import asyncio\nfrom trinsic.trinsic_util import set_eventloop_policy\n\n\nasync def provider_demo():\n    return\n\n\nif __name__ == \"__main__\":\n    set_eventloop_policy()\n    asyncio.run(provider_demo())\n</code></pre> <pre><code>upgradeResponse, err := trinsic.Provider().UpgradeDID(context.Background(), &amp;provider.UpgradeDidRequest{\nAccount: &amp;provider.UpgradeDidRequest_WalletId{\nWalletId: walletId,\n},\nMethod: common.SupportedDidMethod_ION,\nOptions: &amp;provider.UpgradeDidRequest_IonOptions{\nIonOptions: &amp;provider.IonOptions{\nNetwork: provider.IonOptions_TestNet,\n},\n},\n})\n</code></pre> <pre><code>var upgradeRequest =\nUpgradeDidRequest.newBuilder()\n.setWalletId(account.getAuthToken())\n.setMethod(SupportedDidMethod.ION)\n.setIonOptions(\nIonOptions.newBuilder().setNetwork(IonOptions.IonNetwork.TestNet).build())\n.build();\n\nvar upgradeResponse = trinsic.provider().upgradeDID(upgradeRequest).get();\n</code></pre> <p>UpgradeDidRequestRequest to upgrade a walletemail stringEmail address of account to upgrade. Mutually exclusive with <code>walletId</code> and <code>didUri</code>.wallet_id stringWallet ID of account to upgrade. Mutually exclusive with <code>email</code> and <code>didUri</code>.did_uri stringDID URI of the account to upgrade. Mutually exclusive with <code>email</code> and <code>walletId</code>.method SupportedDidMethodDID Method to which wallet should be upgradedShow enum valuesSupportedDidMethod.KEY  = 0The did:key method -- all wallets use this by defaultSupportedDidMethod.ION  = 1The did:ion method -- Sidetree implementation on top of Bitcoin by MicrosoftSupportedDidMethod.INDY  = 2The did:sov method -- Hyperledger Indy based by Sovrin Foundationion_options IonOptionsConfiguration for creation of DID on ION networkShow child attributesion_options.network IonNetworkION network on which DID should be publishedShow enum valuesIonNetwork.TestNet  = 0IonNetwork.MainNet  = 1indy_options IndyOptionsConfiguration for creation of DID on INDY networkShow child attributesindy_options.network IndyNetworkSOV network on which DID should be publishedShow enum valuesIndyNetwork.Danube  = 0IndyNetwork.SovrinBuilder  = 1IndyNetwork.SovrinStaging  = 2IndyNetwork.Sovrin  = 3IndyNetwork.IdUnionTest  = 4IndyNetwork.IdUnion  = 5IndyNetwork.IndicioTest  = 6IndyNetwork.IndicioDemo  = 7IndyNetwork.Indicio  = 8</p> <p>UpgradeDidResponseResponse to <code>UpgradeDIDRequest</code>did stringNew DID of wallet</p>"},{"location":"reference/services/template-service/","title":"Template Service","text":"<p>The Template Service allows you to manage and search Credential Templates.</p>"},{"location":"reference/services/template-service/#create-template","title":"Create Template","text":"<p>Creates a new credential template.</p> <p>The <code>name</code> of a template must be unique within your ecosystem, and cannot be changed -- it is used to derive the URI of the template itself.</p> <p>The <code>title</code> and <code>description</code> parameters (for the template itself, as well as for any of its fields) should be human-readable strings. They should describe the credentials issued by the template, not the template itself (for example, a good title for a medical license template would simply be \"Medical License\", not \"Medical License Template\").</p> <p><code>field_ordering</code> may be used to specify the order in which fields are rendered when displaying a credential, and to categorize fields into logical sections. This is used for display only, and has no bearing on working with credentials as an issuer or verifier.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic template create --name 'My Credential' --fields-data '{\\\"field1\\\":{}}'\n</code></pre> <pre><code>const createRequest: CreateCredentialTemplateRequest = {\nname: `An Example Credential-${uuid()}`,\ntitle: \"Example Credential\",\ndescription: \"A credential for Trinsic's SDK samples\",\nallowAdditionalFields: false,\nfields: {\nfirstName: {\ntitle: \"First Name\",\ndescription: \"Given name of holder\",\n},\nlastName: {\ntitle: \"Last Name\",\ndescription: \"Surname of holder\",\noptional: true,\n},\nage: {\ntitle: \"Age\",\ndescription: \"Age in years of holder\",\ntype: FieldType.NUMBER,\n},\n},\nfieldOrdering: {\nfirstName: { order: 0, section: \"Name\" },\nlastName: { order: 1, section: \"Name\" },\nage: { order: 2, section: \"Miscellaneous\" },\n},\nappleWalletOptions: {\nprimaryField: \"firstName\",\nsecondaryFields: [\"lastName\"],\nauxiliaryFields: [\"age\"],\n},\n};\n\nconst createResponse = await trinsic.template().create(createRequest);\n</code></pre> <pre><code>CreateCredentialTemplateRequest createRequest = new()\n{\nName = \"An Example Credential\",\nTitle = \"Example Credential\",\nDescription = \"A credential for Trinsic's SDK samples\",\nAllowAdditionalFields = false,\nFields =\n{\n{ \"firstName\", new() { Title = \"First Name\", Description = \"Given name of holder\" } },\n{ \"lastName\", new() { Title = \"Last Name\", Description = \"Surname of holder\", Optional = true } },\n{ \"age\", new() { Title = \"Age\", Description = \"Age in years of holder\", Type = FieldType.Number } }\n},\nFieldOrdering =\n{\n{ \"firstName\", new() { Order = 0, Section = \"Name\" } },\n{ \"lastName\", new() { Order = 1, Section = \"Name\" } },\n{ \"age\", new() { Order = 2, Section = \"Miscellanous\" } }\n},\nAppleWalletOptions = new()\n{\nPrimaryField = \"firstName\",\nSecondaryFields = { \"lastName\" },\nAuxiliaryFields = { \"age\" }\n}\n};\n\nvar template = await trinsic.Template.CreateAsync(createRequest);\n</code></pre> <pre><code>create_request = CreateCredentialTemplateRequest(\n    name=f\"An Example Credential-{random.Random().randint(0,100)}\",\n    title=\"Example Credential\",\n    description=\"A credential for Trinsic's SDK samples\",\n    allow_additional_fields=False,\n    fields={\n        \"firstName\": TemplateField(\n            title=\"First Name\", description=\"Given name of holder\"\n        ),\n        \"lastName\": TemplateField(\n            title=\"Last Name\", description=\"Surname of holder\", optional=True\n        ),\n        \"age\": TemplateField(\n            title=\"Age\", description=\"Age in years of holder\", type=FieldType.NUMBER\n        ),\n    },\n    field_ordering={\n        \"firstName\": FieldOrdering(order=0, section=\"Name\"),\n        \"lastName\": FieldOrdering(order=1, section=\"Name\"),\n        \"age\": FieldOrdering(order=2, section=\"Miscellaneous\"),\n    },\n    apple_wallet_options=AppleWalletOptions(\n        primary_field=\"firstName\",\n        secondary_fields=[\"lastName\"],\n        auxiliary_fields=[\"age\"],\n    ),\n)\ncreate_response = await trinsic_service.template.create(request=create_request)\n</code></pre> <pre><code>templateRequest := &amp;template.CreateCredentialTemplateRequest{\nName:                  \"An Example Credential\",\nTitle:                 \"Example Credential\",\nDescription:           \"A credential for Trinsic's SDK samples\",\nAllowAdditionalFields: false,\nFields: map[string]*template.TemplateField{\n\"firstName\": {\nTitle:       \"First Name\",\nDescription: \"Given name of holder\",\n},\n\"lastName\": {\nTitle:       \"Last Name\",\nDescription: \"Surname of holder\",\nOptional:    true,\n},\n\"age\": {\nTitle:       \"Age\",\nDescription: \"Age in years of holder\",\nType:        template.FieldType_NUMBER,\n},\n},\nFieldOrdering: map[string]*template.FieldOrdering{\n\"firstName\": {Order: 0, Section: \"Name\"},\n\"lastName\":  {Order: 1, Section: \"Name\"},\n\"age\":       {Order: 2, Section: \"Miscellaneous\"},\n},\nAppleWalletOptions: &amp;template.AppleWalletOptions{\nPrimaryField:    \"firstName\",\nSecondaryFields: []string{\"lastName\"},\nAuxiliaryFields: []string{\"age\"},\n},\n}\n\ntemplateResponse, err := trinsic.Template().Create(context.Background(), templateRequest)\n</code></pre> <pre><code>var templateRequest =\nCreateCredentialTemplateRequest.newBuilder()\n// Set metadata\n.setName(\"An Example Credential\" + UUID.randomUUID())\n.setTitle(\"Example Credential\")\n.setDescription(\"A credential for Trinsic's SDK samples\")\n.setAllowAdditionalFields(false)\n// Construct fields\n.putFields(\n\"firstName\",\nTemplateField.newBuilder()\n.setTitle(\"First Name\")\n.setDescription(\"Given name of holder\")\n.build())\n.putFields(\n\"lastName\",\nTemplateField.newBuilder()\n.setTitle(\"Last Name\")\n.setDescription(\"Surname of holder\")\n.setOptional(true)\n.build())\n.putFields(\n\"age\",\nTemplateField.newBuilder()\n.setTitle(\"Age\")\n.setDescription(\"Age in years of holder\")\n.setType(FieldType.NUMBER)\n.build())\n// Specify ordering and categorization of fields for rendering of credential\n.putFieldOrdering(\n\"firstName\", FieldOrdering.newBuilder().setOrder(0).setSection(\"Name\").build())\n.putFieldOrdering(\n\"lastName\", FieldOrdering.newBuilder().setOrder(1).setSection(\"Name\").build())\n.putFieldOrdering(\n\"age\", FieldOrdering.newBuilder().setOrder(2).setSection(\"Miscellaneous\").build())\n// Specify Apple Wallet configuration\n.setAppleWalletOptions(\nAppleWalletOptions.newBuilder()\n.setPrimaryField(\"firstName\")\n.addSecondaryFields(\"lastName\")\n.addAuxiliaryFields(\"age\")\n.build())\n.build();\nvar template = trinsic.template().create(templateRequest).get();\n</code></pre> <p>CreateCredentialTemplateRequestRequest to create a new templatename stringName of new template. Must be a unique identifier within its ecosystem.fields map(string -&gt; TemplateField)Fields which compose the templateShow child attributesfields[key].title stringHuman-readable name of the fieldfields[key].description stringHuman-readable description of the fieldfields[key].optional boolWhether this field may be omitted when a credential is issued against the templatefields[key].type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4FieldType.URI  = 5fields[key].uri_data UriFieldDataHow to deal with this URI field when rendering credential. Only use if <code>type</code> is <code>URI</code>.Show child attributesfields[key].uri_data.mime_type stringExpected MIME Type of content pointed to by URI. Can be generic (eg, \"image/\") or specific (\"image/png\"). Defaults to \"application/octet-stream\".fields[key].uri_data.render_method UriRenderMethodHow to display the URI value when rendering a credential.Show enum valuesUriRenderMethod.TEXT  = 0Display URI as textUriRenderMethod.LINK  = 1Display URI as a clickable linkUriRenderMethod.INLINE_IMAGE  = 2Display URI as an inline image. Only takes effect if the template field's MIME Type is an image type.allow_additional_fields boolWhether credentials may be issued against this template which have fields not specified in <code>fields</code>title stringHuman-readable name of templatedescription stringHuman-readable description of templatefield_ordering map(string -&gt; FieldOrdering)Optional map describing how to order and categorize the fields within the template. The key of this map is the field <code>name</code>. If not provided, this will be auto-generated.Show child attributesfield_ordering[key].order int32The order of the field; must be unique within the Template. Fields are sorted by order ascending when displaying a credential. Field orders must be contiguous from <code>0</code> to the number of fields minus 1.field_ordering[key].section stringThe human-readable name of the section this field appears in; used to group together fields when displaying a credential. Sections must be contiguous with respect to <code>order</code>.apple_wallet_options AppleWalletOptionsOptions for rendering the template in Apple WalletShow child attributesapple_wallet_options.background_color stringBackground color, in hex format, of credential when stored in an Apple Wallet.apple_wallet_options.foreground_color stringForeground color, in hex format, of credential when stored in an Apple Wallet.apple_wallet_options.label_color stringLabel color, in hex format, of credential when stored in an Apple Wallet.apple_wallet_options.primary_field stringThe ID of the template field which should be used as the primary field of a credential.apple_wallet_options.secondary_fields string[]The secondary fields of the credential. This is a mapping between the order of a secondary field (0 or 1) and the field name.apple_wallet_options.auxiliary_fields string[]The auxiliary fields of the credential. This is a mapping between the order of an auxiliary field (0 or 1) and the field name.</p> <p>CreateCredentialTemplateResponseResponse to <code>CreateCredentialTemplateRequest</code>data TemplateDataCreated templateShow child attributesdata.id stringTemplate IDdata.name stringTemplate namedata.version int32Template version numberdata.fields map(string -&gt; TemplateField)Fields defined for the templateShow child attributesdata.fields[key].title stringHuman-readable name of the fielddata.fields[key].description stringHuman-readable description of the fielddata.fields[key].optional boolWhether this field may be omitted when a credential is issued against the templatedata.fields[key].type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4FieldType.URI  = 5data.fields[key].uri_data UriFieldDataHow to deal with this URI field when rendering credential. Only use if <code>type</code> is <code>URI</code>.Show child attributesdata.fields[key].uri_data.mime_type stringExpected MIME Type of content pointed to by URI. Can be generic (eg, \"image/\") or specific (\"image/png\"). Defaults to \"application/octet-stream\".data.fields[key].uri_data.render_method UriRenderMethodHow to display the URI value when rendering a credential.Show enum valuesUriRenderMethod.TEXT  = 0Display URI as textUriRenderMethod.LINK  = 1Display URI as a clickable linkUriRenderMethod.INLINE_IMAGE  = 2Display URI as an inline image. Only takes effect if the template field's MIME Type is an image type.data.allow_additional_fields boolWhether credentials issued against this template may contain fields not defined by templatedata.schema_uri stringURI pointing to template JSON schema documentdata.ecosystem_id stringID of ecosystem in which template residesdata.type stringTemplate type (<code>VerifiableCredential</code>)data.created_by stringID of template creatordata.date_created stringDate when template was created as ISO 8601 utc stringdata.title stringHuman-readable template titledata.description stringHuman-readable template descriptiondata.field_ordering map(string -&gt; FieldOrdering)Map describing how to order and categorize the fields within the template. The key of this map is the field <code>name</code>.Show child attributesdata.field_ordering[key].order int32The order of the field; must be unique within the Template. Fields are sorted by order ascending when displaying a credential. Field orders must be contiguous from <code>0</code> to the number of fields minus 1.data.field_ordering[key].section stringThe human-readable name of the section this field appears in; used to group together fields when displaying a credential. Sections must be contiguous with respect to <code>order</code>.data.apple_wallet_options AppleWalletOptionsOptions for rendering the template in Apple WalletShow child attributesdata.apple_wallet_options.background_color stringBackground color, in hex format, of credential when stored in an Apple Wallet.data.apple_wallet_options.foreground_color stringForeground color, in hex format, of credential when stored in an Apple Wallet.data.apple_wallet_options.label_color stringLabel color, in hex format, of credential when stored in an Apple Wallet.data.apple_wallet_options.primary_field stringThe ID of the template field which should be used as the primary field of a credential.data.apple_wallet_options.secondary_fields string[]The secondary fields of the credential. This is a mapping between the order of a secondary field (0 or 1) and the field name.data.apple_wallet_options.auxiliary_fields string[]The auxiliary fields of the credential. This is a mapping between the order of an auxiliary field (0 or 1) and the field name.</p>"},{"location":"reference/services/template-service/#update-template","title":"Update Template","text":"<p>Updates a template's display metadata, such as its human-readable title/description.</p> <p>This call cannot be used to update templates in a way that might invalidate previously-issued credentials: fields cannot be added, removed, or renamed, but their <code>title</code> and <code>description</code> properties may be updated.</p> <p>In order to leave a property unchanged (for example, if you wish to change <code>description</code> but not <code>title</code>), simply leave it unspecified (don't set it to an empty string/object). This applies to fields as well: any field not specified in <code>fields</code> will remain unchanged.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>Not yet supported\n</code></pre> <pre><code>const updateRequest: UpdateCredentialTemplateRequest = {\nid: templateId,\ntitle: \"New Title\",\ndescription: \"New Description\",\nfields: {\nfirstName: { title: \"New title for firstName\" },\nlastName: { description: \"New description for lastName\" },\n},\nfieldOrdering: {\nage: { order: 0, section: \"Misc\" },\nfirstName: { order: 1, section: \"Full Name\" },\nlastName: { order: 2, section: \"Full Name\" },\n},\nappleWalletOptions: {\nprimaryField: \"age\",\nsecondaryFields: [\"firstName\", \"lastName\"],\n},\n};\n\nconst updateResponse = await trinsic.template().update(updateRequest);\n</code></pre> <pre><code>UpdateCredentialTemplateRequest updateRequest = new()\n{\nId = templateId,\nTitle = \"New Title\",\nDescription = \"New Description\",\nFields =\n{\n{ \"firstName\", new() { Title = \"New title for firstName\" } },\n{ \"lastName\", new() { Description = \"New description for lastName\" } }\n},\nFieldOrdering =\n{\n{ \"age\", new() { Order = 0, Section = \"Misc\" } },\n{ \"firstName\", new() { Order = 1, Section = \"Full Name\" } },\n{ \"lastName\", new() { Order = 2, Section = \"Full Name\" } },\n},\nAppleWalletOptions = new()\n{\nPrimaryField = \"age\",\nSecondaryFields = { \"firstName\", \"lastName\" }\n}\n};\n\nvar updatedTemplate = await trinsic.Template.UpdateAsync(updateRequest);\n</code></pre> <pre><code>update_request = UpdateCredentialTemplateRequest(\n    id=template_id,\n    title=\"New Title\",\n    description=\"New Description\",\n    fields={\n        \"firstName\": TemplateFieldPatch(title=\"New title for firstName\"),\n        \"lastName\": TemplateFieldPatch(description=\"New description for lastName\"),\n    },\n    field_ordering={\n        \"age\": FieldOrdering(order=0, section=\"Misc\"),\n        \"firstName\": FieldOrdering(order=1, section=\"Full Name\"),\n        \"lastName\": FieldOrdering(order=2, section=\"Full Name\"),\n    },\n    apple_wallet_options=AppleWalletOptions(\n        primary_field=\"age\", secondary_fields=[\"firstName\", \"lastName\"]\n    ),\n)\nupdate_response = await trinsic_service.template.update(request=update_request)\n</code></pre> <pre><code>var newTemplateTitle = \"New Title\"\nvar newTemplateDescription = \"New Description\"\nvar newFirstNameTitle = \"New title for firstName\"\nvar newLastNameDescription = \"New description for lastName\"\n\nupdateRequest := &amp;template.UpdateCredentialTemplateRequest{\nId:          templateId,\nTitle:       &amp;newTemplateTitle,\nDescription: &amp;newTemplateDescription,\nFields: map[string]*template.TemplateFieldPatch{\n\"firstName\": {Title: &amp;newFirstNameTitle},\n\"lastName\":  {Description: &amp;newLastNameDescription},\n},\nFieldOrdering: map[string]*template.FieldOrdering{\n\"age\":       {Order: 0, Section: \"Misc\"},\n\"firstName\": {Order: 1, Section: \"Full Name\"},\n\"lastName\":  {Order: 2, Section: \"Full Name\"},\n},\nAppleWalletOptions: &amp;template.AppleWalletOptions{\nPrimaryField:    \"age\",\nSecondaryFields: []string{\"firstName\", \"lastName\"},\n},\n}\n\nupdateResponse, err := trinsic.Template().Update(context.Background(), updateRequest)\n</code></pre> <pre><code>var updateRequest =\nUpdateCredentialTemplateRequest.newBuilder()\n.setId(templateId)\n// Specify new title and description for the template\n.setTitle(\"New Title\")\n.setDescription(\"New Description\")\n// Update title/description for a few fields\n.putFields(\n\"firstName\",\nTemplateFieldPatch.newBuilder().setTitle(\"New title for firstName\").build())\n.putFields(\n\"lastName\",\nTemplateFieldPatch.newBuilder()\n.setDescription(\"New description for lastName\")\n.build())\n// Specify new ordering / categorization for template fields\n.putFieldOrdering(\n\"age\", FieldOrdering.newBuilder().setOrder(0).setSection(\"Misc\").build())\n.putFieldOrdering(\n\"firstName\", FieldOrdering.newBuilder().setOrder(1).setSection(\"Full Name\").build())\n.putFieldOrdering(\n\"lastName\", FieldOrdering.newBuilder().setOrder(2).setSection(\"Full Name\").build())\n// Specify new Apple Wallet configuration\n.setAppleWalletOptions(\nAppleWalletOptions.newBuilder()\n.setPrimaryField(\"age\")\n.addSecondaryFields(\"firstName\")\n.addSecondaryFields(\"lastName\")\n.build())\n.build();\n\nvar updatedTemplate = trinsic.template().update(updateRequest).get();\n</code></pre> <p>UpdateCredentialTemplateRequestRequest to update display information for a templateid stringID of Template to updatetitle stringNew human-readable title of Templatedescription stringNew human-readable description of Templatefields map(string -&gt; TemplateFieldPatch)Fields to update within the TemplateShow child attributesfields[key].title stringHuman-readable name of the fieldfields[key].description stringHuman-readable description of the fieldfields[key].uri_data UriFieldDataHow to deal with this URI field when rendering credential. Only use if <code>type</code> is <code>URI</code>.Show child attributesfields[key].uri_data.mime_type stringExpected MIME Type of content pointed to by URI. Can be generic (eg, \"image/\") or specific (\"image/png\"). Defaults to \"application/octet-stream\".fields[key].uri_data.render_method UriRenderMethodHow to display the URI value when rendering a credential.Show enum valuesUriRenderMethod.TEXT  = 0Display URI as textUriRenderMethod.LINK  = 1Display URI as a clickable linkUriRenderMethod.INLINE_IMAGE  = 2Display URI as an inline image. Only takes effect if the template field's MIME Type is an image type.field_ordering map(string -&gt; FieldOrdering)New field ordering options. See documentation for template creation for usage information.Show child attributesfield_ordering[key].order int32The order of the field; must be unique within the Template. Fields are sorted by order ascending when displaying a credential. Field orders must be contiguous from <code>0</code> to the number of fields minus 1.field_ordering[key].section stringThe human-readable name of the section this field appears in; used to group together fields when displaying a credential. Sections must be contiguous with respect to <code>order</code>.apple_wallet_options AppleWalletOptionsNew Apple Wallet configurationShow child attributesapple_wallet_options.background_color stringBackground color, in hex format, of credential when stored in an Apple Wallet.apple_wallet_options.foreground_color stringForeground color, in hex format, of credential when stored in an Apple Wallet.apple_wallet_options.label_color stringLabel color, in hex format, of credential when stored in an Apple Wallet.apple_wallet_options.primary_field stringThe ID of the template field which should be used as the primary field of a credential.apple_wallet_options.secondary_fields string[]The secondary fields of the credential. This is a mapping between the order of a secondary field (0 or 1) and the field name.apple_wallet_options.auxiliary_fields string[]The auxiliary fields of the credential. This is a mapping between the order of an auxiliary field (0 or 1) and the field name.</p> <p>UpdateCredentialTemplateResponseResponse to <code>UpdateCredentialTemplateRequest</code>updated_template TemplateDataThe Template after the update has been appliedShow child attributesupdated_template.id stringTemplate IDupdated_template.name stringTemplate nameupdated_template.version int32Template version numberupdated_template.fields map(string -&gt; TemplateField)Fields defined for the templateShow child attributesupdated_template.fields[key].title stringHuman-readable name of the fieldupdated_template.fields[key].description stringHuman-readable description of the fieldupdated_template.fields[key].optional boolWhether this field may be omitted when a credential is issued against the templateupdated_template.fields[key].type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4FieldType.URI  = 5updated_template.fields[key].uri_data UriFieldDataHow to deal with this URI field when rendering credential. Only use if <code>type</code> is <code>URI</code>.Show child attributesupdated_template.fields[key].uri_data.mime_type stringExpected MIME Type of content pointed to by URI. Can be generic (eg, \"image/\") or specific (\"image/png\"). Defaults to \"application/octet-stream\".updated_template.fields[key].uri_data.render_method UriRenderMethodHow to display the URI value when rendering a credential.Show enum valuesUriRenderMethod.TEXT  = 0Display URI as textUriRenderMethod.LINK  = 1Display URI as a clickable linkUriRenderMethod.INLINE_IMAGE  = 2Display URI as an inline image. Only takes effect if the template field's MIME Type is an image type.updated_template.allow_additional_fields boolWhether credentials issued against this template may contain fields not defined by templateupdated_template.schema_uri stringURI pointing to template JSON schema documentupdated_template.ecosystem_id stringID of ecosystem in which template residesupdated_template.type stringTemplate type (<code>VerifiableCredential</code>)updated_template.created_by stringID of template creatorupdated_template.date_created stringDate when template was created as ISO 8601 utc stringupdated_template.title stringHuman-readable template titleupdated_template.description stringHuman-readable template descriptionupdated_template.field_ordering map(string -&gt; FieldOrdering)Map describing how to order and categorize the fields within the template. The key of this map is the field <code>name</code>.Show child attributesupdated_template.field_ordering[key].order int32The order of the field; must be unique within the Template. Fields are sorted by order ascending when displaying a credential. Field orders must be contiguous from <code>0</code> to the number of fields minus 1.updated_template.field_ordering[key].section stringThe human-readable name of the section this field appears in; used to group together fields when displaying a credential. Sections must be contiguous with respect to <code>order</code>.updated_template.apple_wallet_options AppleWalletOptionsOptions for rendering the template in Apple WalletShow child attributesupdated_template.apple_wallet_options.background_color stringBackground color, in hex format, of credential when stored in an Apple Wallet.updated_template.apple_wallet_options.foreground_color stringForeground color, in hex format, of credential when stored in an Apple Wallet.updated_template.apple_wallet_options.label_color stringLabel color, in hex format, of credential when stored in an Apple Wallet.updated_template.apple_wallet_options.primary_field stringThe ID of the template field which should be used as the primary field of a credential.updated_template.apple_wallet_options.secondary_fields string[]The secondary fields of the credential. This is a mapping between the order of a secondary field (0 or 1) and the field name.updated_template.apple_wallet_options.auxiliary_fields string[]The auxiliary fields of the credential. This is a mapping between the order of an auxiliary field (0 or 1) and the field name.</p>"},{"location":"reference/services/template-service/#get-template","title":"Get Template","text":"<p>Fetches a template definition by <code>id</code>.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic template get --id &lt;TEMPLATE_ID&gt;\n</code></pre> <pre><code>let getTemplateResponse = await trinsic.template().get(\nGetCredentialTemplateRequest.fromPartial({\nid: \"id\",\n})\n);\n</code></pre> <pre><code>var getTemplateResponse = await trinsic.Template.GetAsync(new() { Id = template.Data.Id });\n</code></pre> <pre><code>get_template_response = await trinsic_service.template.get(\n    request=GetCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre> <pre><code>getResponse, err := trinsic.Template().Get(context.Background(), &amp;template.GetCredentialTemplateRequest{Id: templateResponse.Data.Id})\n</code></pre> <pre><code>var getResponse =\ntrinsic\n.template()\n.get(GetCredentialTemplateRequest.newBuilder().setId(templateId).build())\n.get();\n</code></pre> <p>GetCredentialTemplateRequestRequest to fetch a template by IDid stringID of template to fetch</p> <p>GetCredentialTemplateResponseResponse to <code>GetCredentialTemplateRequest</code>template TemplateDataTemplate fetched by IDShow child attributestemplate.id stringTemplate IDtemplate.name stringTemplate nametemplate.version int32Template version numbertemplate.fields map(string -&gt; TemplateField)Fields defined for the templateShow child attributestemplate.fields[key].title stringHuman-readable name of the fieldtemplate.fields[key].description stringHuman-readable description of the fieldtemplate.fields[key].optional boolWhether this field may be omitted when a credential is issued against the templatetemplate.fields[key].type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4FieldType.URI  = 5template.fields[key].uri_data UriFieldDataHow to deal with this URI field when rendering credential. Only use if <code>type</code> is <code>URI</code>.Show child attributestemplate.fields[key].uri_data.mime_type stringExpected MIME Type of content pointed to by URI. Can be generic (eg, \"image/\") or specific (\"image/png\"). Defaults to \"application/octet-stream\".template.fields[key].uri_data.render_method UriRenderMethodHow to display the URI value when rendering a credential.Show enum valuesUriRenderMethod.TEXT  = 0Display URI as textUriRenderMethod.LINK  = 1Display URI as a clickable linkUriRenderMethod.INLINE_IMAGE  = 2Display URI as an inline image. Only takes effect if the template field's MIME Type is an image type.template.allow_additional_fields boolWhether credentials issued against this template may contain fields not defined by templatetemplate.schema_uri stringURI pointing to template JSON schema documenttemplate.ecosystem_id stringID of ecosystem in which template residestemplate.type stringTemplate type (<code>VerifiableCredential</code>)template.created_by stringID of template creatortemplate.date_created stringDate when template was created as ISO 8601 utc stringtemplate.title stringHuman-readable template titletemplate.description stringHuman-readable template descriptiontemplate.field_ordering map(string -&gt; FieldOrdering)Map describing how to order and categorize the fields within the template. The key of this map is the field <code>name</code>.Show child attributestemplate.field_ordering[key].order int32The order of the field; must be unique within the Template. Fields are sorted by order ascending when displaying a credential. Field orders must be contiguous from <code>0</code> to the number of fields minus 1.template.field_ordering[key].section stringThe human-readable name of the section this field appears in; used to group together fields when displaying a credential. Sections must be contiguous with respect to <code>order</code>.template.apple_wallet_options AppleWalletOptionsOptions for rendering the template in Apple WalletShow child attributestemplate.apple_wallet_options.background_color stringBackground color, in hex format, of credential when stored in an Apple Wallet.template.apple_wallet_options.foreground_color stringForeground color, in hex format, of credential when stored in an Apple Wallet.template.apple_wallet_options.label_color stringLabel color, in hex format, of credential when stored in an Apple Wallet.template.apple_wallet_options.primary_field stringThe ID of the template field which should be used as the primary field of a credential.template.apple_wallet_options.secondary_fields string[]The secondary fields of the credential. This is a mapping between the order of a secondary field (0 or 1) and the field name.template.apple_wallet_options.auxiliary_fields string[]The auxiliary fields of the credential. This is a mapping between the order of an auxiliary field (0 or 1) and the field name.</p>"},{"location":"reference/services/template-service/#delete-template","title":"Delete Template","text":"<p>Deletes a credential template by <code>id</code>.</p>  Sample Request Response Trinsic CLIC#PythonGoJava <pre><code>trinsic template delete --id &lt;TEMPLATE_ID&gt;\n</code></pre> <pre><code>var deleteTemplateResponse = await trinsic.Template.DeleteAsync(new() { Id = template.Data.Id });\n</code></pre> <pre><code>delete_template_response = await trinsic_service.template.delete(\n    request=DeleteCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre> <pre><code>deleteResponse, err := trinsic.Template().Delete(context.Background(), &amp;template.DeleteCredentialTemplateRequest{Id: templateResponse.Data.Id})\n</code></pre> <pre><code>var deleteResponse =\ntrinsic\n.template()\n.delete(DeleteCredentialTemplateRequest.newBuilder().setId(templateId).build())\n.get();\n</code></pre> <p>DeleteCredentialTemplateRequestRequest to delete a template by IDid stringID of template to delete</p> <p>DeleteCredentialTemplateResponseResponse to <code>DeleteCredentialTemplateRequest</code>This message has no fields</p>"},{"location":"reference/services/template-service/#search-templates","title":"Search Templates","text":"<p>Searches all templates defined in the current ecosystem, and a <code>continuation_token</code> to paginate large result sets.</p> <p>If no <code>query</code> is specified, this call by default returns the first 100 templates.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic wallet search \\\n--query \"SELECT * FROM c\"\n</code></pre> <pre><code>let searchTemplateResponse = await trinsic.template().search(\nSearchCredentialTemplatesRequest.fromPartial({\nquery: \"Select * from c\",\n})\n);\n</code></pre> <pre><code>var searchTemplateResponse = await trinsic.Template.SearchAsync(new() { Query = \"SELECT * FROM c\" });\n</code></pre> <pre><code>search_template_response = await trinsic_service.template.search(\n    request=SearchCredentialTemplatesRequest(query=\"SELECT * FROM c\")\n)\n</code></pre> <pre><code>searchResponse, err := trinsic.Template().Search(context.Background(), &amp;template.SearchCredentialTemplatesRequest{Query: \"SELECT * FROM c\"})\n</code></pre> <pre><code>var searchResponse =\ntrinsic\n.template()\n.search(\nSearchCredentialTemplatesRequest.newBuilder()\n.setQuery(\"SELECT * FROM c WHERE c.id = '\" + templateId + \"'\")\n.build())\n.get();\n</code></pre> <p>SearchCredentialTemplatesRequestRequest to search templates using a SQL queryquery stringSQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code>continuation_token optional stringToken provided by previous <code>SearchCredentialTemplatesResponse</code> if more data is available for query</p> <p>SearchCredentialTemplatesResponseResponse to <code>SearchCredentialTemplatesRequest</code>items_json stringRaw JSON data returned from queryhas_more_results boolWhether more results are available for this query via <code>continuation_token</code>continuation_token stringToken to fetch next set of results via <code>SearchCredentialTemplatesRequest</code></p>"},{"location":"reference/services/template-service/#advanced-search","title":"Advanced Search","text":"<p>The Search endpoint supports SQL queries through the <code>query</code> parameter.</p> <p>This allows for arbitrary query predicates, as well as more advanced functionality -- such as modifying the output format.</p>"},{"location":"reference/services/template-service/#schema","title":"Schema","text":"<p>Any table name may be used in your query (we use <code>c</code> here) -- it doesn't matter what it is.</p> Name Type Description id string Corresponds to the <code>id</code> returned when template was created type string Always <code>VerifiableCredential</code> ecosystemId string ID of ecosystem in which template resides createdBy string ID of account which defined the template name string Name provided during template creation schemaUri string HTTPS URL pointing to JSON Schema generated by Trinsic for this template contextUri string HTTPS URL pointing to JSON-LD Context generated by Trinsic for this template version int Version of template; increments whenever template is modified. fields object JSON Object representing the template's fields <p>Note that <code>fields</code> is an object, not a string; thus, any of its sub-fields may be queried against.</p> <p>More Info</p> <p>This endpoint works very similarly to querying Wallet items; please see Wallet Service &gt; Search for more information.</p>"},{"location":"reference/services/trust-registry-service/","title":"Trust Registry Service","text":"<p>The Trust Registry Service exposes functionality for managing Trust Registries -- lists of authorized issuers for the various credential types within an ecosystem.</p>"},{"location":"reference/services/trust-registry-service/#register-issuer","title":"Register Issuer","text":"<p>Registers an authorized issuer for a specific credential type (identified by its <code>schema_uri</code>).</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic trust-registry register-member \\\n--schema https://w3id.org/vaccination#VaccinationCertificate \\\n--did did:key:xxxxx.....\n</code></pre> <pre><code>let response = await trinsic.trustRegistry().registerMember(\nRegisterMemberRequest.fromPartial({\ndidUri: didUri,\nschemaUri: schemaUri,\n})\n);\n</code></pre> <pre><code>var didUri = \"did:example:test\";\n_ = await trinsic.TrustRegistry.RegisterMemberAsync(new()\n{\nDidUri = didUri,\nSchemaUri = schemaUri\n});\n</code></pre> <pre><code>await trinsic_service.trust_registry.register_member(\n    request=RegisterMemberRequest(\n        did_uri=did_example_test,\n        schema_uri=https_schema_org,\n    )\n)\n</code></pre> <pre><code>registerMemberResponse, err := trinsic.TrustRegistry().RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\nSchemaUri: schemaURI,\nMember:    &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n})\n</code></pre> <pre><code>var memberResponse =\ntrinsic\n.trustRegistry()\n.registerMember(\nRegisterMemberRequest.newBuilder().setDidUri(didUri).setSchemaUri(typeUri).build())\n.get();\n</code></pre> <p>RegisterMemberRequestRequest to register a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.did_uri stringDID URI of member to registerwallet_id stringTrinsic Wallet ID of member to registeremail stringEmail address of member to register. Must be associated with an existing Trinsic account.schema_uri stringURI of credential schema to register member as authorized issuer ofvalid_from_utc uint64Unix Timestamp member is valid from. Member will not be considered valid before this timestamp.valid_until_utc uint64Unix Timestamp member is valid until. Member will not be considered valid after this timestamp.</p> <p>RegisterMemberResponseResponse to <code>RegisterMemberRequest</code>This message has no fields</p>"},{"location":"reference/services/trust-registry-service/#unregister-issuer","title":"Unregister Issuer","text":"<p>Unregisters an issuer for a specific credential type (identified by its <code>schema_uri</code>).</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic trust-registry unregister-member \\\n--schema https://w3id.org/vaccination#VaccinationCertificate \\\n--did did:example:fabre\n</code></pre> <pre><code>let unregisterResult = await trinsic.trustRegistry().unregisterMember({\ndidUri: didUri,\nschemaUri: schemaUri\n})\n</code></pre> <pre><code>_ = await trinsic.TrustRegistry.UnregisterMemberAsync(new()\n{\nDidUri = didUri,\nSchemaUri = schemaUri\n});\n</code></pre> <pre><code>unregister_issuer_response = await trinsic_service.trust_registry.unregister_member(\n    request=UnregisterMemberRequest(\n        schema_uri=https_schema_org,\n        did_uri=did_example_test,\n    )\n)\n</code></pre> <pre><code>    unregisterMemberResponse, err := trinsic.TrustRegistry().UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\nSchemaUri: schemaURI,\n})\n\n\u22ef\n\n// Do absolutely nothing\n</code></pre> <pre><code>trinsic\n.trustRegistry()\n.unregisterMember(\nUnregisterMemberRequest.newBuilder().setDidUri(didUri).setSchemaUri(typeUri).build());\n</code></pre> <p>UnregisterMemberRequestRequest to unregister a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.did_uri stringDID URI of member to unregisterwallet_id stringTrinsic Wallet ID of member to unregisteremail stringEmail address of member to unregister. Must be associated with an existing Trinsic account.schema_uri stringURI of credential schema to unregister member as authorized issuer of</p> <p>UnregisterMemberResponseResponse to <code>UnregisterMemberRequest</code>This message has no fields</p>"},{"location":"reference/services/trust-registry-service/#list-issuers","title":"List Issuers","text":"<p>Lists all issuers that are authorized within the ecosystem, optionally filtering against a specific credential type.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic trust-registry list-members\n</code></pre> <pre><code>const members = await trinsic.trustRegistry().listAuthorizedMembers({\nschemaUri: schemaUri\n}\n);\n</code></pre> <pre><code>var members = await trinsic.TrustRegistry.ListAuthorizedMembersAsync(new()\n{\nSchemaUri = schemaUri\n});\n</code></pre> <pre><code>list_response = await trinsic_service.trust_registry.list_authorized_members(\n    request=ListAuthorizedMembersRequest(schema_uri=https_schema_org)\n)\n</code></pre> <pre><code>listMembersResponse, err := trinsic.TrustRegistry().ListAuthorizedMembers(context.Background(), &amp;trustregistry.ListAuthorizedMembersRequest{\nSchemaUri: &amp;schemaURI,\n})\n</code></pre> <pre><code>var members =\ntrinsic\n.trustRegistry()\n.listAuthorizedMembers(\nListAuthorizedMembersRequest.newBuilder().setSchemaUri(typeUri).build())\n.get();\n</code></pre> <p>ListAuthorizedMembersRequestschema_uri stringid of schema that needs to be checkedcontinuation_token stringToken to fetch next set of results, from previous <code>ListAuthorizedMembersResponse</code></p> <p>ListAuthorizedMembersResponseResponse to <code>ListAuthorizedMembersRequest</code>authorized_members AuthorizedMember[]JSON string containing array of resultant objectsShow child attributesauthorized_members[i].did stringauthorized_members[i].authorized_member_schemas AuthorizedMemberSchema[]Show child attributesauthorized_members[i].authorized_member_schemas[i].schema_uri stringauthorized_members[i].authorized_member_schemas[i].status stringauthorized_members[i].authorized_member_schemas[i].status_details stringauthorized_members[i].authorized_member_schemas[i].valid_from uint64authorized_members[i].authorized_member_schemas[i].valid_until uint64has_more_results boolWhether more data is available to fetch for querycontinuation_token stringToken to fetch next set of results via <code>ListAuthorizedMembersRequest</code></p>"},{"location":"reference/services/trust-registry-service/#get-issuer","title":"Get Issuer","text":"<p>Gets an issuer's entry in the ecosystem's trust registry.</p> <p>This call returns data regarding every credential the issuer is registered to issue for. </p>  Sample Request Response <pre><code>=== \"Trinsic CLI\"\n```bash\ntrinsic trust-registry get-member \\\n    --did did:example:fabre \\  // OR\n    --email test@example.com \\ // OR\n    --wallet urn:trinsic:wallets:example\n```\n</code></pre> TypeScriptC#PythonGoJava <pre><code>const member = await trinsic.trustRegistry().getMember({\ndidUri: didUri\n});\n</code></pre> <pre><code>var member = await trinsic.TrustRegistry.GetMemberAsync(new()\n{\nDidUri = didUri\n});\n</code></pre> <pre><code>get_member_response = await trinsic_service.trust_registry.get_member(\n    request=GetMemberRequest(did_uri=did_example_test)\n)\n</code></pre> <pre><code>getMemberResponse, err := trinsic.TrustRegistry().GetMember(context.Background(), &amp;trustregistry.GetMemberRequest{\nMember: &amp;trustregistry.GetMemberRequest_DidUri{\nDidUri: didURI,\n},\n})\n</code></pre> <pre><code>var member =\ntrinsic\n.trustRegistry()\n.getMember(GetMemberRequest.newBuilder().setDidUri(typeUri).build())\n.get();\n</code></pre> <p>GetMemberRequestRequest to get a member of the governance frameworkdid_uri stringDID URI of member to getwallet_id stringTrinsic Wallet ID of member to getemail stringEmail address of member to get. Must be associated with an existing Trinsic account.</p> <p>GetMemberResponseResponse to <code>GetMemberAuthorizationStatusRequest</code>authorized_member AuthorizedMemberMember for given did in given frameworkShow child attributesauthorized_member.did stringauthorized_member.authorized_member_schemas AuthorizedMemberSchema[]Show child attributesauthorized_member.authorized_member_schemas[i].schema_uri stringauthorized_member.authorized_member_schemas[i].status stringauthorized_member.authorized_member_schemas[i].status_details stringauthorized_member.authorized_member_schemas[i].valid_from uint64authorized_member.authorized_member_schemas[i].valid_until uint64</p>"},{"location":"reference/services/trust-registry-service/#check-issuer-status","title":"Check Issuer Status","text":"<p>Checks the authorization status of an issuer for a specific credential type.</p>  Sample Request Response Trinsic CLITypeScriptC#PythonGoJava <pre><code>trinsic trust-registry get-membership-status \\\n--credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n--did did:example:fabre\n</code></pre> <pre><code>let issuerStatus = await trinsic.trustRegistry().getMemberAuthorizationStatus({\ndidUri: didUri,\nschemaUri: schemaUri,\n}\n);\n</code></pre> <pre><code>var issuerStatus = await trinsic.TrustRegistry.GetMemberAuthorizationStatusAsync(new()\n{\nDidUri = didUri,\nSchemaUri = schemaUri\n});\n</code></pre> <pre><code>check_response = (\n    await trinsic_service.trust_registry.get_member_authorization_status(\n        request=GetMemberAuthorizationStatusRequest(\n            did_uri=did_example_test,\n            schema_uri=https_schema_org,\n        )\n    )\n)\n</code></pre> <pre><code>getMembershipStatusResponse, err := trinsic.TrustRegistry().GetMemberAuthorizationStatus(context.Background(), &amp;trustregistry.GetMemberAuthorizationStatusRequest{\nDidUri:    didURI,\nSchemaUri: schemaURI,\n})\n</code></pre> <pre><code>var issuerStatus =\ntrinsic\n.trustRegistry()\n.getMemberAuthorizationStatus(\nGetMemberAuthorizationStatusRequest.newBuilder()\n.setDidUri(didUri)\n.setSchemaUri(typeUri)\n.build())\n.get();\n</code></pre> <p>GetMemberAuthorizationStatusRequestRequest to fetch member status in governance framework for a specific credential schema.did_uri stringDID URI of memberschema_uri stringURI of credential schema associated with member</p> <p>GetMemberAuthorizationStatusResponseResponse to <code>GetMemberAuthorizationStatusRequest</code>status RegistrationStatusStatus of member for given credential schemaShow enum valuesRegistrationStatus.CURRENT  = 0Member is currently authorized, as of the time of the queryRegistrationStatus.EXPIRED  = 1Member's authorization has expiredRegistrationStatus.TERMINATED  = 2Member has voluntarily ceased Issuer role under the specific EGFRegistrationStatus.REVOKED  = 3Member authority under specific EGF was terminated by the governing authorityRegistrationStatus.NOT_FOUND  = 10Member is not associated with given credential schema in the EGF</p>"},{"location":"reference/services/wallet-service/","title":"Wallet API","text":"<p>The Wallet API is the main interface for interacting with a cloud wallet. It is primarly used when you're providing custom wallet experience and building your own digital wallet integration. If you'd like to use Trinsic's integrated cloud wallet app, you likely won't need to use this API.</p> <p>Migrating from Account API?</p> <p>Check out our migration guide on how to migrate your code that uses the deprecated Account API.</p>"},{"location":"reference/services/wallet-service/#create-wallet","title":"Create Wallet","text":"<p>Create a new wallet and return the authentication token and wallet information about the newly created wallet.</p>  Sample Request Response C# <pre><code>using Trinsic;\nusing Trinsic.Services.UniversalWallet.V1;\n\nvar trinsic = new TrinsicService();\n\nvar request = new CreateWalletRequest {\nEcosystemId = \"acme-corp\",\nDescription = \"user123\"\n};\nvar response = await trinsic.Wallet.CreateWalletAsync(request);\n\n// Response: {\n//     \"authToken\": \"dGhpcyBpcyBhbiBleGFtcGxlIGF1dGhlbmNpdGlvbiB0b2tlbgo=\",\n//     \"tokenId\": \"0b4f42cb-4d44-4629-89dd-47b814229ffe\",\n//     \"wallet\": {\n//         \"walletId\": \"urn:trinsic:wallets:z7438uW5X4gZ1rZsiZaBdxX\",\n//         \"publicDid\": \"did:key:123456\"\n//     }\n// }\n</code></pre> <p>CreateWalletRequestecosystem_id stringEcosystem ID of the wallet to createdescription optional stringWallet name or description. Use this field to add vendor specific information about this wallet, such as email, phone, internal ID, or anything you'd like to associate with this wallet. This field is searchable.identity optional ExternalIdentityOptional identity to add to the wallet (email or sms).  Use this field when inviting participants into an ecosystem. If this field is set, an auth token will not be sent in the response.Show child attributesidentity.identity stringThe user identity to add to the wallet This can be an email address or phone number (formatted as +[country code][phone number])identity.provider IdentityProviderThe type of identity provider, like EMAIL or PHONEShow enum valuesIdentityProvider.Unknown  = 0Identity provider is unknownIdentityProvider.Email  = 1Identity provider is emailIdentityProvider.Phone  = 2Identity provider is phone</p> <p>CreateWalletResponseauth_token stringAuth token for the newly created wallettoken_id stringToken ID of the newly generated tokenwallet WalletConfigurationWallet configurationShow child attributeswallet.name stringName/description of the walletwallet.email optional stringDeprecated and will be removed on August 1, 2023 -- use external_identities.  This field is set to the first email address present in <code>external_identities</code>, if any.wallet.sms optional stringDeprecated -- use external_identitieswallet.wallet_id stringwallet.public_did stringThe DID of the walletwallet.config_type stringwallet.auth_tokens WalletAuthToken[]List of active authentication tokens for this wallet. This list does not contain the issued token, only metadata such as ID, description, and creation date.Show child attributeswallet.auth_tokens[i].id stringUnique identifier for the token. This field will match the <code>DeviceId</code> in the WalletAuthDatawallet.auth_tokens[i].description stringDevice name/descriptionwallet.auth_tokens[i].date_created stringDate when the token was created in ISO 8601 formatwallet.external_identity_ids string[]List of external identity IDs (email addresses, phone numbers, etc.) associated with this wallet. This is deprecated; use <code>external_identities</code> instead.wallet.ecosystem_id stringEcosystem in which this wallet is contained.wallet.description stringwallet.external_identities WalletExternalIdentity[]List of external identities associated with this wallet.Show child attributeswallet.external_identities[i].provider IdentityProviderThe type of this identity (whether this identity is an email address, phone number, etc.)Show enum valuesIdentityProvider.Unknown  = 0Identity provider is unknownIdentityProvider.Email  = 1Identity provider is emailIdentityProvider.Phone  = 2Identity provider is phonewallet.external_identities[i].id stringThe actual email address/phone number/etc. for this identity</p>"},{"location":"reference/services/wallet-service/#add-external-identity","title":"Add External Identity","text":"<p>This service is used to attach external identity, such as email or phone number, to a wallet. The purpose of this process is to allow the user to authenticate to their existing wallet (using the <code>Authenticate</code> endpoint) to get an auth token. This may be needed if the user is logging in on a different device, have lost access to the initial auth token, etc.</p> <p>The process for adding external identity is based on confirming an OTP code that will be sent to the user's email address or phone number. To do this, you should call the services <code>AddExternalIdentityInit</code> and <code>AddExternalIdentityConfirm</code>.</p>"},{"location":"reference/services/wallet-service/#addexternalidentityinit","title":"<code>AddExternalIdentityInit</code>","text":"Sample Request Response C# <pre><code>using Trinsic;\nusing Trinsic.Services.UniversalWallet.V1;\n\n// these endpoints require authenticated user context\nvar options = new TrinsicOptions { AuthToken = \"&lt;auth token&gt;\" };\nvar trinsic = new TrinsicService(options);\n\n// step 1 - initiate identity challenge\nvar requestInit = new AddExternalIdentityInitRequest {\nIdentity = \"user123@acme-corp.org\",\nProvider = IdentityProvider.Email\n};\nvar responseInit = await trinsic.Wallet.AddExternalIdentityInitAsync(requestInit);\n\n// step 2 - confirm challenge response\nvar requestConfirm = new AddExternalIdentityConfirmRequest {\nChallenge = responseInit.Challenge,\nResponse = \"123456\" // OTP code\n};\nawait trinsic.Wallet.AddExternalIdentityConfirmAsync(requestConfirm);\n</code></pre> <p>AddExternalIdentityInitRequestidentity stringThe user identity to add to the wallet This can be an email address or phone number (formatted as +[country code][phone number])provider IdentityProviderThe type of identity provider, like EMAIL or PHONEShow enum valuesIdentityProvider.Unknown  = 0Identity provider is unknownIdentityProvider.Email  = 1Identity provider is emailIdentityProvider.Phone  = 2Identity provider is phone</p> <p>AddExternalIdentityInitResponsechallenge stringChallenge or reference to the challenge to be used in the <code>AddExternalIdentityConfirm</code> endpoint</p>"},{"location":"reference/services/wallet-service/#addexternalidentityconfirm","title":"<code>AddExternalIdentityConfirm</code>","text":"Request Response <p>AddExternalIdentityConfirmRequestchallenge stringThe challenge received from the <code>AddExternalIdentityInit</code> endpointresponse stringThe response to the challenge. If using Email or Phone, this is the OTP code sent to the user's email or phone</p> <p>AddExternalIdentityConfirmResponseThis message has no fields</p>"},{"location":"reference/services/wallet-service/#remove-external-identity","title":"Remove External Identity","text":"<p>Removes an external identity from the associated identities of the authenticated wallet.</p>  Request Response <p>RemoveExternalIdentityRequestidentity stringThe user identity to remove from the wallet This can be an email address or phone number (formatted as +[country code][phone number])</p> <p>RemoveExternalIdentityResponseThis message has no fields</p>"},{"location":"reference/services/wallet-service/#authenticate","title":"Authenticate","text":"<p>Authenticate and return an auth token for an existing wallet using one of the associated external identities. This endpoint requires that the wallet user has previously added at least one external identity using the above endpoints.</p> <p>Once a token is obtained, it can be reused for future sessions -- users don't need to authenticate if they already have a valid token. You can store the auth token in secure enclaves on the users device, browser, etc.</p> <p>When should users authenticate?</p> <ul> <li>If your integration solution doesn't manage the wallet tokens, users may need to re-authenticate on their device to get a new auth token</li> <li>Users want to log in to a different device using their email or phone number</li> <li>Returning users that have lost their previous session and require new auth token</li> </ul>"},{"location":"reference/services/wallet-service/#authenticateinit","title":"<code>AuthenticateInit</code>","text":"Sample Request Response C# <pre><code>using Trinsic;\nusing Trinsic.Services.UniversalWallet.V1;\n\nvar trinsic = new TrinsicService();\n\n// step 1 - initiate auth challenge\nvar requestInit = new AuthenticateInitRequest {\nIdentity = \"user123@acme-corp.org\",\nProvider = IdentityProvider.Email,\nEcosystemId = \"acme-corp\" // short name or full ecosystem ID\n};\nvar responseInit = await trinsic.Wallet.AuthenticateInit(requestInit);\n\n// step 2 - confirm auth response\nvar requestConfirm = new AuthenticateConfirmRequest {\nChallenge = responseInit.Challenge,\nResponse = \"123456\" // OTP code\n};\nvar responseConfirm = await trinsic.Wallet.AuthenticateConfirm(requestConfirm);\n\n// Response:\n// {\n//     \"authToken\": \"dGhpcyBpcyBhbiBleGFtcGxlIGF1dGhlbmNpdGlvbiB0b2tlbgo=\"\n// }\n\n// use the new token to make authenticated calls\nvar options = new TrinsicOptions { AuthToken = responseConfirm.AuthToken };\ntrinsic = new TrinsicService(options);\n</code></pre> <p>AuthenticateInitRequestidentity stringIdentity to add to the walletprovider IdentityProviderIdentity providerShow enum valuesIdentityProvider.Unknown  = 0Identity provider is unknownIdentityProvider.Email  = 1Identity provider is emailIdentityProvider.Phone  = 2Identity provider is phoneecosystem_id stringEcosystem ID to which the wallet belongs</p> <p>AuthenticateInitResponsechallenge stringThe challenge received from the <code>AcquireAuthTokenInit</code> endpoint Pass this challenge back to the <code>AcquireAuthTokenConfirm</code> endpoint</p>"},{"location":"reference/services/wallet-service/#authenticateconfirm","title":"<code>AuthenticateConfirm</code>","text":"Request Response <p>AuthenticateConfirmRequestchallenge stringThe challenge received from the <code>AcquireAuthTokenInit</code> endpointresponse stringThe response to the challenge. If using Email or Phone, this is the OTP code sent to the user's email or phone</p> <p>AuthenticateConfirmResponseauth_token stringAuth token for the wallet</p>"},{"location":"reference/services/wallet-service/#insert-item","title":"Insert Item","text":"<p>Stores a credential (or any other JSON object) in a wallet.</p>  Sample Request Response TypeScriptC#PythonGoJava <pre><code>let insertItemResponse = await trinsic.wallet().insertItem(\nInsertItemRequest.fromPartial({\nitemJson: issueResponse.documentJson,\n})\n);\n</code></pre> <pre><code>var insertItemResponse =\nawait trinsic.Wallet.InsertItemAsync(new() { ItemJson = credentialJson.DocumentJson });\n</code></pre> <pre><code>insert_response = await trinsic.wallet.insert_item(\n    request=InsertItemRequest(\n        item_json=credential, item_type=\"VerifiableCredential\"\n    )\n)\n</code></pre> <pre><code>insertResponse, err := trinsic.Wallet().InsertItem(context.Background(), &amp;wallet.InsertItemRequest{\nItemJson: credentialJson,\nItemType: \"VerifiableCredential\",\n})\n</code></pre> <pre><code>var insertResponse =\ntrinsic\n.wallet()\n.insertItem(\nInsertItemRequest.newBuilder()\n.setItemJson(credentialJson)\n.setItemType(\"VerifiableCredential\")\n.build())\n.get();\n</code></pre> <p>InsertItemRequestRequest to insert a JSON document into a walletitem_json stringDocument to insert; must be stringified JSONitem_type optional stringItem type (ex. \"VerifiableCredential\")</p> <p>InsertItemResponseResponse to <code>InsertItemRequest</code>item_id stringID of item inserted into wallet</p> <p>What can be stored in a wallet?</p> <p>Wallets are mainly intended to hold Verifiable Credentials, but can technically store any JSON blob.</p> <p>If you store a Verifiable Credential in a Wallet, ensure that its <code>item_type</code> is <code>VerifiableCredential</code>.</p> <p>Otherwise, ensure its <code>item_type</code> is not <code>VerifiableCredential</code>.</p>"},{"location":"reference/services/wallet-service/#get-item","title":"Get Item","text":"<p>Retrieves an item by its ID.</p>  Sample Request Response TypeScriptC#PythonGoJava <pre><code>let getItemResponse = await trinsic.wallet().getItem({\nitemId: itemId,\n});\n</code></pre> <pre><code>var getItemResponse = await trinsic.Wallet.GetItemAsync(new GetItemRequest\n{\nItemId = itemId\n});\n</code></pre> <pre><code>item = await trinsic.wallet.get_item(request=GetItemRequest(item_id))\n</code></pre> <pre><code>getResponse, err := trinsic.Wallet().GetItem(context.Background(), &amp;wallet.GetItemRequest{\nItemId: itemId,\n})\n</code></pre> <pre><code>var getResponse =\ntrinsic.wallet().getItem(GetItemRequest.newBuilder().setItemId(itemId).build()).get();\n</code></pre> <p>GetItemRequestRequest to fetch an item from walletitem_id stringID of item in wallet</p> <p>GetItemResponseResponse to <code>GetItemRequest</code>item_json stringItem data as a JSON stringitem_type stringType of item specified when item was inserted into wallet</p>"},{"location":"reference/services/wallet-service/#delete-item","title":"Delete Item","text":"<p>Deletes an item.</p>  Sample Request Response TypeScriptC#PythonGoJava <pre><code>await trinsic.wallet().deleteItem({\nitemId: itemId,\n});\n</code></pre> <pre><code>await trinsic.Wallet.DeleteItemAsync(new DeleteItemRequest\n{\nItemId = itemId\n});\n</code></pre> <pre><code>await trinsic.wallet.delete_item(request=DeleteItemRequest(item_id=item_id))\n</code></pre> <pre><code>deleteResponse, err := trinsic.Wallet().DeleteItem(context.Background(),\n&amp;wallet.DeleteItemRequest{\nItemId: itemId,\n})\n</code></pre> <pre><code>trinsic.wallet().deleteItem(DeleteItemRequest.newBuilder().setItemId(itemId).build()).get();\n</code></pre> <p>DeleteItemRequestRequest to delete an item in a walletitem_id stringID of item to delete</p> <p>DeleteItemResponseResponse to <code>DeleteItemRequest</code>This message has no fields</p>"},{"location":"reference/services/wallet-service/#delete-wallet","title":"Delete Wallet","text":"<p>Deletes a wallet, and all its credentials, permanently.</p> <p>Any wallet may delete itself by passing its own ID to this call. Only Provider wallets may delete wallets other than themselves.</p> <p>Wallet deletion is permanent and cannot be undone.</p>  Sample Request Response TypeScriptC#PythonGoJava <pre><code>await trinsic.wallet().deleteWallet({\nwalletId: walletId,\n});\n</code></pre> <pre><code>await trinsic.Wallet.DeleteWalletAsync(new DeleteWalletRequest\n{\nWalletId = walletId\n});\n</code></pre> <pre><code>await trinsic.wallet.delete_wallet(request=DeleteWalletRequest(wallet_id=wallet_id))\n</code></pre> <pre><code>deleteWalletResponse, err := trinsic.Wallet().DeleteWallet(context.Background(),\n&amp;wallet.DeleteWalletRequest{\nAccount: &amp;wallet.DeleteWalletRequest_WalletId{\nWalletId: walletId,\n},\n})\n</code></pre> <pre><code>trinsic\n.wallet()\n.deleteWallet(DeleteWalletRequest.newBuilder().setWalletId(walletId).build())\n.get();\n</code></pre> <p>DeleteWalletRequestRequest to delete a walletemail stringEmail address of account to delete. Mutually exclusive with <code>walletId</code> and <code>didUri</code>.wallet_id stringWallet ID of account to delete. Mutually exclusive with <code>email</code> and <code>didUri</code>.did_uri stringDID URI of the account to delete. Mutually exclusive with <code>email</code> and <code>walletId</code>.</p> <p>DeleteWalletResponseResponse to <code>DeleteWalletRequest</code>. Empty payload.This message has no fields</p>"},{"location":"reference/services/wallet-service/#search-wallet","title":"Search Wallet","text":"<p>Searches a wallet, returning all matching items, and a <code>continuation_token</code> to paginate large result sets.</p> <p>If no <code>query</code> is specified, this call by default returns the first 100 items in the wallet.</p>  Sample Request Response TypeScriptC#PythonGoJava <pre><code>let items = await trinsic.wallet().searchWallet();\n</code></pre> <pre><code>var walletItems = await trinsic.Wallet.SearchWalletAsync(new());\n</code></pre> <pre><code>wallet_items = await trinsic.wallet.search_wallet()\n</code></pre> <pre><code>searchResponse, err := trinsic.Wallet().SearchWallet(context.Background(), &amp;wallet.SearchRequest{})\n</code></pre> <pre><code>var walletItems = trinsic.wallet().searchWallet().get();\n</code></pre> <p>SearchRequestRequest to search items in walletquery stringSQL Query to execute against items in walletcontinuation_token optional stringToken provided by previous <code>SearchResponse</code> if more data is available for query</p> <p>SearchResponseResponse to <code>SearchRequest</code>items string[]Array of query results, as JSON stringshas_more_results boolWhether more results are available for this query via <code>continuation_token</code>continuation_token stringToken to fetch next set of results via <code>SearchRequest</code></p> <p>Verifiable Presentation Request Spec</p> <p>In the future, this endpoint will support the Verifiable Presentation Request Spec .</p>"},{"location":"reference/services/wallet-service/#advanced-search","title":"Advanced Search","text":"<p>The Search endpoint supports SQL queries through the <code>query</code> parameter.</p> <p>This allows for arbitrary query predicates, as well as more advanced functionality -- such as modifying the output format.</p>"},{"location":"reference/services/wallet-service/#schema","title":"Schema","text":"<p>Any table name may be used in your query (we use <code>c</code> here) -- it doesn't matter what it is.</p> Name Type Description id string Corresponds to the <code>item_id</code> returned when item was inserted into wallet type string Specified via <code>item_type</code> when item was inserted into wallet data object The JSON object passed via <code>item_json</code> when item was inserted into wallet <p>Note that <code>data</code> is an object, not a string; thus, any of its sub-fields may be queried against.</p> <p>For example, <code>SELECT * FROM c WHERE c.data.someField = 'Hello, World!'</code> would match against the following JSON object inserted via InsertItem:</p> <pre><code>{\n\"someField\": \"Hello, World!\"\n}\n</code></pre>"},{"location":"reference/services/wallet-service/#common-sql-queries","title":"Common SQL Queries","text":""},{"location":"reference/services/wallet-service/#paging","title":"Paging","text":"<p>Paging uses the <code>OFFSET</code> clause that takes in a value indicating how many records should be skipped in the returned query. To specify the size of the result set (page size) use the <code>LIMIT</code> clause.</p> <pre><code>SELECT * FROM c OFFSET 10 LIMIT 5\n</code></pre>"},{"location":"reference/services/wallet-service/#sorting","title":"Sorting","text":"<p>The optional <code>ORDER BY</code> clause specifies the sorting order for results returned by the query. To control sorting order, specify <code>ASC</code> or <code>DESC</code> at the end; if not specified ascending order is used by default.</p> <pre><code>SELECT * FROM c ORDER BY c.credential.issued DESC\n</code></pre>"},{"location":"reference/services/wallet-service/#filtering","title":"Filtering","text":"<p>The optional WHERE clause (<code>WHERE &lt;filter_condition&gt;</code>) specifies condition(s) that the source JSON items must satisfy for the query to include them in results. A JSON item must evaluate the specified conditions to true to be considered for the result. The index layer uses the <code>WHERE</code> clause to determine the smallest subset of source items that can be part of the result.</p> <pre><code>SELECT * FROM c WHERE c.name = 'Trinsic' AND c.dateCreated &gt;= \"2020-09-30T23:14:25.7251173Z\"\n</code></pre>"},{"location":"reference/services/wallet-service/#grouping","title":"Grouping","text":"<p>The <code>GROUP BY</code> clause divides the query's results according to the values of one or more specified properties. Examples and detailed description on working with grouped results can be found here </p>"},{"location":"reference/services/wallet-service/#additional-resources","title":"Additional Resources","text":"<p>You can read the full documentation on working with SQL queries on the Azure Cosmos DB website .</p>"},{"location":"sdk/","title":"Tools and API access","text":"<p>Our API exposes all endpoints using a gRPC interface. We provide SDKs for access to our endpoints for all platforms. Check the individual pages for details on installing the packages on your platform.</p> <p>All endpoints, request and response messages and their fields are identical for all platforms, though casing may differ depending on what is ideomatic for that language.</p>"},{"location":"sdk/#bring-your-own-sdk","title":"Bring your own SDK","text":"<p>If you'd like to generate your own SDK from the proto files, you can find them in our GitHub repository or the Buf Schema Registry. We support gRPC and gRPC-web modes.</p>"},{"location":"sdk/#making-authenticated-requests","title":"Making authenticated requests","text":"<p>To make authenticated requests with your generated code, make sure to set the <code>Authorization</code> header with a value equal to <code>Bearer &lt;YOUR AUTH TOKEN&gt;</code>. In gRPC tooling, this is usually refered as Metadata.</p>"},{"location":"walkthroughs/vaccination/","title":"Walkthrough: Build a Vaccine Card","text":"<p>This walkthrough demonstrates how a vaccination card can be issued, held, and shared using Verifiable Credentials with Trinsic.</p>"},{"location":"walkthroughs/vaccination/#meet-allison","title":"Meet Allison","text":"<p>We'll follow Allison as she obtains a vaccine certificate, stores it in her digital wallet, and presents it to board an airplane.</p> <p>In most credential exchange scenarios, there are three primary roles: Issuer, Holder, and Verifier.</p> <p>Holder: Stores credentials received from issuers, and presents them to verifiers. (Said credentials are often, but not always, attesting information about the holder)</p> <p>Issuer: Signs and issues credentials which attest information about a credential subject.</p> <p>Verifier: Verifies credentials presented by holders.</p> <p>In this case, Allison will be the holder, a vaccination clinic will be the issuer, and an airline will be the verifier.</p>"},{"location":"walkthroughs/vaccination/#our-sdks","title":"Our SDKs","text":"<p>You can follow along using one of our SDKs, or use the Trinsic CLI, which implements full platform functionality.</p> Trinsic CLITypescriptC#PythonJavaGo <p>Click here for installation instructions for the Trinsic CLI.</p> <p>Click here for installation instructions for the Node/Browser SDK.</p> <p>Click here for installation instructions for the .NET SDK.</p> <p>Click here for installation instructions for the Python SDK.</p> <p>Click here for installation instructions for the Java SDK.</p> <p>Click here for installation instructions for the Go SDK.</p>"},{"location":"walkthroughs/vaccination/#ecosystem-setup","title":"Ecosystem Setup","text":"<p>Before we begin, you'll need an ecosystem -- somewhere for the resources we're about to create (wallets, templates, credentials) to live.</p>"},{"location":"walkthroughs/vaccination/#use-existing-ecosystem","title":"Use Existing Ecosystem","text":"<p>If you've already signed up as a customer, you'll have received an email with an ecosystem ID and authentication token.</p> <p>Copy this ecosystem ID down, and skip to the next step.</p>"},{"location":"walkthroughs/vaccination/#create-new-ecosystem","title":"Create New Ecosystem","text":"<p>If you don't already have an ecosystem provisioned for you, you'll need to create one first.</p> <p>This will be a sandbox ecosystem; suitable for prototyping and testing, but not production purposes. To receive a production ecosystem, sign up.</p> Trinsic CLITypescriptC#PythonJavaGo <pre><code>trinsic provider create-ecosystem\n</code></pre> <pre><code>const ecosystem = await trinsic\n.provider()\n.createEcosystem(CreateEcosystemRequest.fromPartial({}));\nconst ecosystemId = ecosystem.ecosystem!.id;\n</code></pre> <pre><code>var trinsic = new TrinsicService(_options);\nvar (ecosystem, _) = await trinsic.Provider.CreateEcosystemAsync(new());\nvar ecosystemId = ecosystem?.Id;\n</code></pre> <pre><code>ecosystem = await trinsic_service.provider.create_ecosystem()\necosystem_id = ecosystem.ecosystem.id\n</code></pre> <pre><code>var ecosystemResponse =\ntrinsic.provider().createEcosystem(CreateEcosystemRequest.getDefaultInstance()).get();\n\nvar ecosystemId = ecosystemResponse.getEcosystem().getId();\n</code></pre> <pre><code>ecosystem, _ := trinsic.Provider().CreateEcosystem(context.Background(), nil)\necosystemId := ecosystem.Ecosystem.Id\n</code></pre> <p>The response to this call contains the name and ID of your newly-created ecosystem; copy either of these down.</p> <p>Further Reading: Ecosystems</p> <ul> <li>Learn more about Ecosystems</li> <li>Browse the Provider API reference</li> </ul>"},{"location":"walkthroughs/vaccination/#create-accounts","title":"Create Accounts","text":"<p>We need to create Trinsic accounts for the participants in this credential exchange. Accounts and wallets can be considered interchangeably; all accounts have exactly one associated wallet.</p> <p>Accounts can be created with a single call; they're designed to minimize onboarding friction for your users.</p> <p>The clinic's account will issue the credential, Allison's account will hold it, and the airline's account will verify its contents.</p> Trinsic CLITypescriptC#PythonJavaGo <p>The CLI makes it easy to create wallets. For demo purposes, we'll create all three on the same machine.</p> <p>When using the CLI, the authentication token of the most recently used account is saved in <code>~/.trinsic</code>. In a real-world scenario, you should back this token up securely.</p> <pre><code>trinsic account login --ecosystem {ECOSYSTEM_ID}\n# Save auth token in `allison.txt` before continuing\n\ntrinsic account login --ecosystem {ECOSYSTEM_ID}\n# Save auth token in `airline.txt` before continuing\n\ntrinsic account login --ecosystem {ECOSYSTEM_ID}\n# Save auth token in `clinic.txt` before continuing\n</code></pre> <pre><code>// Create 3 different profiles for each participant in the scenario\nconst allison = await trinsic\n.wallet()\n.createWallet({ ecosystemId: ecosystemId });\nconst clinic = await trinsic\n.wallet()\n.createWallet({ ecosystemId: ecosystemId });\nconst airline = await trinsic\n.wallet()\n.createWallet({ ecosystemId: ecosystemId });\n</code></pre> <p>If you would like to save the account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p> <pre><code>var allison = await trinsic.Wallet.CreateWalletAsync(new() { EcosystemId = ecosystemId! });\nvar clinic = await trinsic.Wallet.CreateWalletAsync(new() { EcosystemId = ecosystemId! });\nvar airline = await trinsic.Wallet.CreateWalletAsync(new() { EcosystemId = ecosystemId! });\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p> <pre><code># Create an account for each participant in the scenario\nallison = await trinsic_service.wallet.create_wallet(\n    request=CreateWalletRequest(ecosystem_id=ecosystem_id)\n)\nairline = await trinsic_service.wallet.create_wallet(\n    request=CreateWalletRequest(ecosystem_id=ecosystem_id)\n)\nclinic = await trinsic_service.wallet.create_wallet(\n    request=CreateWalletRequest(ecosystem_id=ecosystem_id)\n)\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p> <pre><code>// Create an account for each participant in the scenario\nvar allison =\ntrinsic\n.wallet()\n.createWallet(CreateWalletRequest.newBuilder().setEcosystemId(ecosystemId).build())\n.get();\nvar clinic =\ntrinsic\n.wallet()\n.createWallet(CreateWalletRequest.newBuilder().setEcosystemId(ecosystemId).build())\n.get();\nvar airline =\ntrinsic\n.wallet()\n.createWallet(CreateWalletRequest.newBuilder().setEcosystemId(ecosystemId).build())\n.get();\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p> <pre><code>// Create an account for each participant in the scenario\ncreateWallet := &amp;wallet.CreateWalletRequest{EcosystemId: ecosystemId}\nallison, _ := trinsic.Wallet().CreateWallet(context.Background(), createWallet)\nairline, _ := trinsic.Wallet().CreateWallet(context.Background(), createWallet)\nclinic, _ := trinsic.Wallet().CreateWallet(context.Background(), createWallet)\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p> <p>Production Usage</p> <p>In this example, we've created anonymous accounts; the only way to access them is by saving the authentication token generated on account creation.</p> <p>In a production scenario, you may want to create accounts tied to a user's email address or phone number. This allows users to securely access their Trinsic cloud wallets at any time.</p> <p>Note that accounts are tied to their ecosystem. If you create an account tied to <code>bob@example.com</code> in the <code>example1</code> ecosystem, it will not be visible in any other ecosystem. The same email address can be used to create accounts in multiple ecosystems.</p> <p>Further Reading: Accounts and Wallets</p> <ul> <li>Learn more about Wallets</li> <li>Browse the Account API reference</li> <li>Read about authentication tokens and security</li> </ul>"},{"location":"walkthroughs/vaccination/#define-a-template","title":"Define a Template","text":"<p>Before we can issue a credential, we need to create a Template for it.</p> <p>Templates are simply a list of the fields that a credential can have.</p> Trinsic CLITypescriptC#PythonJavaGo <p>First, prepare a JSON file which describes your template:</p> templateData.json <pre><code>{\n\"firstName\": {\n\"type\": \"string\",\n\"description\": \"First name of vaccine recipient\"\n},\n\"lastName\": {\n\"type\": \"string\",\n\"description\": \"Last name of vaccine recipient\"\n},\n\"batchNumber\":{\n\"type\": \"string\",\n\"description\": \"Batch number of vaccine\"\n},\n\"countryOfVaccination\":{\n\"type\": \"string\",\n\"description\": \"Country in which the subject was vaccinated\"\n}\n}\n</code></pre> <p>Then create the template:</p> <pre><code>trinsic template create -n \"VaccinationCertificate\" --fields-file templateData.json\n</code></pre> <p>The output of this command will include a template ID; copy this down for later use.</p> <pre><code>//Define all fields\nconst firstNameField = TemplateField.fromPartial({\ndescription: \"First name of vaccine recipient\",\ntype: FieldType.STRING,\n});\n\nconst lastNameField = TemplateField.fromPartial({\ntype: FieldType.STRING,\ndescription: \"Last name of vaccine recipient\",\n});\n\nconst batchNumberField = TemplateField.fromPartial({\ntype: FieldType.STRING,\ndescription: \"Batch number of vaccine\",\n});\n\nconst countryOfVaccinationField = TemplateField.fromPartial({\ntype: FieldType.STRING,\ndescription: \"Country in which the subject was vaccinated\",\n});\n\n//Create request\nlet request = CreateCredentialTemplateRequest.fromPartial({\nname: `VaccinationCertificate-${uuid()}`,\nfields: {\nfirstName: firstNameField,\nlastName: lastNameField,\nbatchNumber: batchNumberField,\ncountryOfVaccination: countryOfVaccinationField,\n},\n});\n\n//Create template\nconst response = await trinsicService.template().create(request);\nconst template = response.data;\n</code></pre> <pre><code>// Set active profile to `clinic` so we can create a template\ntrinsic = new TrinsicService(_options.CloneWithAuthToken(clinic.AuthToken!));\n\n// Prepare request to create template\nCreateCredentialTemplateRequest templateRequest = new() {\nName = \"VaccinationCertificate\",\nAllowAdditionalFields = false\n};\n\ntemplateRequest.Fields.Add(\"firstName\", new() { Description = \"First name of vaccine recipient\" });\ntemplateRequest.Fields.Add(\"lastName\", new() { Description = \"Last name of vaccine recipient\" });\ntemplateRequest.Fields.Add(\"batchNumber\", new() { Description = \"Batch number of vaccine\", Type = FieldType.String });\ntemplateRequest.Fields.Add(\"countryOfVaccination\", new() { Description = \"Country in which the subject was vaccinated\" });\n\n// Create template\nvar template = await trinsic.Template.CreateAsync(templateRequest);\nvar templateId = template?.Data?.Id;\n</code></pre> <pre><code>template = await trinsic_service.template.create(\n    request=CreateCredentialTemplateRequest(\n        name=f\"VaccinationCertificate-{uuid.uuid4()}\",\n        allow_additional_fields=False,\n        fields={\n            \"firstName\": TemplateField(\n                description=\"First name of vaccine recipient\"\n            ),\n            \"lastName\": TemplateField(description=\"Last name of vaccine recipient\"),\n            \"batchNumber\": TemplateField(\n                description=\"Batch number of vaccine\", type=FieldType.STRING\n            ),\n            \"countryOfVaccination\": TemplateField(\n                description=\"Country in which the subject was vaccinated\"\n            ),\n        },\n    )\n)\n\ntemplate_id = template.data.id\n</code></pre> <pre><code>// Set active profile to 'clinic'\ntemplateService.setAuthToken(clinic);\n\n// Define fields for template\nvar fields = new HashMap&lt;String, TemplateField&gt;();\nfields.put(\n\"firstName\",\nTemplateField.newBuilder().setDescription(\"First name of vaccine recipient\").build());\nfields.put(\n\"lastName\",\nTemplateField.newBuilder().setDescription(\"Last name of vaccine recipient\").build());\nfields.put(\n\"batchNumber\",\nTemplateField.newBuilder()\n.setType(FieldType.STRING)\n.setDescription(\"Batch number of vaccine\")\n.build());\nfields.put(\n\"countryOfVaccination\",\nTemplateField.newBuilder()\n.setDescription(\"Country in which the subject was vaccinated\")\n.build());\n\n// Create template request\nvar templateRequest =\nCreateCredentialTemplateRequest.newBuilder()\n.setName(\"VaccinationCertificate\")\n.setAllowAdditionalFields(false)\n.putAllFields(fields)\n.build();\n\n// Execute template creation\nvar template = templateService.create(templateRequest).get();\nvar templateId = template.getData().getId();\n</code></pre> <pre><code>templateRequest := &amp;template.CreateCredentialTemplateRequest{Name: \"VaccinationCertificate\", AllowAdditionalFields: false, Fields: make(map[string]*template.TemplateField)}\ntemplateRequest.Fields[\"firstName\"] = &amp;template.TemplateField{Description: \"First name of vaccine recipient\"}\ntemplateRequest.Fields[\"lastName\"] = &amp;template.TemplateField{Description: \"Last name of vaccine recipient\"}\ntemplateRequest.Fields[\"batchNumber\"] = &amp;template.TemplateField{Description: \"Batch number of vaccine\", Type: template.FieldType_STRING}\ntemplateRequest.Fields[\"countryOfVaccination\"] = &amp;template.TemplateField{Description: \"Country in which the subject was vaccinated\"}\n\ncreatedTemplate, _ := trinsic.Template().Create(context.Background(), templateRequest)\n\ntemplateId := createdTemplate.Data.Id\n</code></pre> <p>Further Reading: Templates</p> <ul> <li>Learn more about Templates</li> <li>Browse the Template API reference</li> </ul>"},{"location":"walkthroughs/vaccination/#issue-a-credential","title":"Issue a Credential","text":"<p>Upon receiving her vaccine, the clinic issues Allison a Verifiable Credential, which proves that she was given the vaccine by the clinic.</p> <p>A credential is a JSON document that has been cryptographically signed; this signature enables verifiers to trust that the data comes a trusted source, and has not been tampered with.</p> <p>To issue a vaccine certificate, we'll use the template we created in the last step.</p> Trinsic CLITypescriptC#PythonJavaGo <p>First, prepare a file named <code>values.json</code> with the following content:</p> values.json <pre><code>{\n\"firstName\": \"Allison\",\n\"lastName\": \"Allisonne\",\n\"batchNumber\": \"123454321\",\n\"countryOfVaccination\": \"US\"\n}\n</code></pre> <p>Then issue the credential:</p> <pre><code>trinsic config --auth-token $(cat clinic.txt)\ntrinsic vc issue-from-template --template-id {TEMPLATE_ID} --values-file values.json --out credential.json\n</code></pre> <p>The output of this command will contain a signed JSON document, which has been saved to <code>credential.json</code>.</p> <p>Note that TEMPLATE_ID refers to the \"Schema\" URI of the template you created earlier called \"VaccinationCertificate\". More specifically, it's the property 'schema_uri' in the JSON returned by the <code>trinsic template create...</code> command.</p> <pre><code>// Prepare the credential values JSON document\nconst credentialValues = JSON.stringify({\nfirstName: \"Allison\",\nlastName: \"Allisonne\",\nbatchNumber: \"123454321\",\ncountryOfVaccination: \"US\",\n});\n\n// Sign a credential as the clinic and send it to Allison\ntrinsic.options.authToken = clinic.authToken;\nconst issueResponse = await trinsic.credential().issueFromTemplate(\nIssueFromTemplateRequest.fromPartial({\ntemplateId: template.id,\nvaluesJson: credentialValues,\n})\n);\n</code></pre> <pre><code>// Prepare credential values\nvar credentialValues = new Dictionary&lt;string, string&gt; {\n{ \"firstName\", \"Allison\" },\n{ \"lastName\", \"Allisonne\" },\n{ \"batchNumber\", \"123454321\" },\n{ \"countryOfVaccination\", \"US\" }\n};\n\n// Issue credential as clinic\nvar issueResponse = await trinsic.Credential.IssueFromTemplateAsync(new() {\nTemplateId = templateId,\nValuesJson = JsonSerializer.Serialize(credentialValues)\n});\n\nvar signedCredential = issueResponse?.DocumentJson;\n</code></pre> <pre><code># Prepare values for credential\nvalues = json.dumps(\n    {\n        \"firstName\": \"Allison\",\n        \"lastName\": \"Allisonne\",\n        \"batchNumber\": \"123454321\",\n        \"countryOfVaccination\": \"US\",\n    }\n)\n\n# Issue credential\nissue_response = await trinsic_service.credential.issue_from_template(\n    request=IssueFromTemplateRequest(template_id=template.id, values_json=values)\n)\n\ncredential = issue_response.document_json\n</code></pre> <pre><code>// Set active profile to 'clinic' so we can issue credential signed\n// with the clinic's signing keys\ntrinsicService.setAuthToken(clinic);\n\n// Prepare credential values\nvar valuesMap = new HashMap&lt;String, Object&gt;();\nvaluesMap.put(\"firstName\", \"Allison\");\nvaluesMap.put(\"lastName\", \"Allissonne\");\nvaluesMap.put(\"batchNumber\", \"123454321\");\nvaluesMap.put(\"countryOfVaccination\", \"US\");\n\n// Serialize values to JSON\nvar valuesJson = new Gson().toJson(valuesMap);\n\n// Issue credential\nvar issueResponse =\ntrinsicService\n.credential()\n.issueFromTemplate(\nIssueFromTemplateRequest.newBuilder()\n.setTemplateId(templateId)\n.setValuesJson(valuesJson)\n.build())\n.get();\n\nvar credential = issueResponse.getDocumentJson();\n</code></pre> <pre><code>// Prepare values for credential\nvaluesStruct := struct {\nFirstName            string\nLastName             string\nbatchNumber          string\ncountryOfVaccination string\n}{\nFirstName:            \"Allison\",\nLastName:             \"Allisonne\",\nbatchNumber:          \"123454321\",\ncountryOfVaccination: \"US\",\n}\nvalues, _ := json.Marshal(valuesStruct)\n\n// Issue credential\nissueResponse, _ := trinsic.Credential().IssueFromTemplate(context.Background(), &amp;credential.IssueFromTemplateRequest{\nTemplateId: createdTemplate.Id,\nValuesJson: string(values),\n})\n\nissuedCredential := issueResponse.DocumentJson\n</code></pre> <p>Further Reading: Issuance and Credentials</p> <ul> <li>Learn more about Verifiable Credentials</li> <li>Browse the Credential API reference</li> </ul>"},{"location":"walkthroughs/vaccination/#send-credential-to-allison","title":"Send Credential to Allison","text":"<p>Now that the clinic has a signed credential, it must be securely transmitted to Allison, so she can store it in her wallet.</p> <p>Because it's just a JSON string, it could be delivered in many ways -- for example, in the response to an HTTPS request which triggered the issuance process.</p> <p>Send via Trinsic</p> <p>Trinsic also offers the ability to send a credential directly to a Trinsic user's wallet.</p> <p>Click here to learn more about this feature.</p>"},{"location":"walkthroughs/vaccination/#store-credential-in-wallet","title":"Store Credential in Wallet","text":"<p>Once Allison receives the credential, it must be stored in her wallet.</p> Trinsic CLITypescriptC#PythonJavaGo <pre><code>trinsic config --auth-token $(cat allison.txt)\ntrinsic wallet insert-item --item credential.json\n</code></pre> <pre><code>// Alice stores the credential in her cloud wallet.\ntrinsic.options.authToken = allison.authToken;\nconst insertResponse = await trinsic.wallet().insertItem(\nInsertItemRequest.fromPartial({\nitemJson: issueResponse.documentJson,\n})\n);\n</code></pre> <pre><code>// Set active profile to 'allison' so we can manage her cloud wallet\ntrinsic = new TrinsicService(_options.CloneWithAuthToken(allison.AuthToken!));\n\n// Insert credential into Allison's wallet\nvar insertItemResponse = await trinsic.Wallet.InsertItemAsync(new() {\nItemJson = signedCredential\n});\n\nvar itemId = insertItemResponse?.ItemId;\n</code></pre> <pre><code># Allison stores the credential in her cloud wallet\ntrinsic_service.service_options.auth_token = allison.auth_token\n\ninsert_response = await trinsic_service.wallet.insert_item(\n    request=InsertItemRequest(item_json=credential)\n)\n\nitem_id = insert_response.item_id\n</code></pre> <pre><code>// Set active profile to 'allison' so we can manage her cloud wallet\n// setAuthToken() {\ntrinsic.setAuthToken(allison.getAuthToken());\n// }\n\n// Allison stores the credential in her cloud wallet.\nvar insertItemResponse =\ntrinsic\n.wallet()\n.insertItem(InsertItemRequest.newBuilder().setItemJson(credential).build())\n.get();\n\nfinal var itemId = insertItemResponse.getItemId();\n</code></pre> <pre><code>// Allison stores the credential in her cloud wallet\ntrinsic.SetAuthToken(allison.AuthToken)\ninsertResponse, _ := trinsic.Wallet().InsertItem(context.Background(), &amp;wallet.InsertItemRequest{ItemJson: issuedCredential})\n\nitemId := insertResponse.ItemId\n</code></pre> <p>The response to this call contains an Item ID; copy this down.</p> <p>Further Reading: Wallets</p> <ul> <li>Learn more about Wallets</li> <li>Browse the Wallet API reference</li> </ul>"},{"location":"walkthroughs/vaccination/#create-a-proof-of-vaccination","title":"Create a Proof of Vaccination","text":"<p>Before boarding, the airline requests proof of vaccination from Allison. Specifically, they want to see proof that she holds a <code>VaccinationCertificate</code> credential.</p> <p>Let's use the CreateProof call to build a proof for Allison's held credential.</p> Trinsic CLITypescriptC#PythonJavaGo <pre><code>trinsic config --auth-token $(cat allison.txt)\ntrinsic vc create-proof --item-id \"{ITEM_ID}\" --out proof.json\n</code></pre> <pre><code>// Allison shares the credential with the venue.\ntrinsic.options.authToken = allison.authToken;\nconst proofResponse = await trinsic.credential().createProof(\nCreateProofRequest.fromPartial({\nitemId: insertResponse.itemId,\n})\n);\n</code></pre> <pre><code>// Build a proof for the signed credential as allison\nvar proofResponse = await trinsic.Credential.CreateProofAsync(new() {\nItemId = itemId\n});\n\nvar proofJson = proofResponse?.ProofDocumentJson;\n</code></pre> <pre><code># Allison shares the credential with the airline\ntrinsic_service.service_options.auth_token = allison.auth_token\n\nproof_response = await trinsic_service.credential.create_proof(\n    request=CreateProofRequest(item_id=item_id)\n)\n\ncredential_proof = proof_response.proof_document_json\n</code></pre> <pre><code>// Set active profile to 'allison' so we can create a proof using her key\ntrinsic.setAuthToken(allison.getAuthToken());\n\n// Allison shares the credential with the venue\nvar createProofResponse =\ntrinsic\n.credential()\n.createProof(CreateProofRequest.newBuilder().setItemId(itemId).build())\n.get();\n\nvar credentialProof = createProofResponse.getProofDocumentJson();\n</code></pre> <pre><code>// Allison shares the credential with the airline\ntrinsic.SetAuthToken(allison.AuthToken)\nproofResponse, _ := trinsic.Credential().CreateProof(context.Background(), &amp;credential.CreateProofRequest{\nProof: &amp;credential.CreateProofRequest_ItemId{ItemId: itemId},\n})\n\ncredentialProof := proofResponse.ProofDocumentJson\n</code></pre> <p>Allison sends this proof to the airline for them to verify.</p> <p>Partial Proofs</p> <p>In this example, the proof is being created over the entire credential; all of its fields are revealed to the verifier.</p> <p>It is possible for the airline to send Allison a frame which requests only certain fields of the credential. The airline would not be able to see other fields of the credential, but cryptographic guarantees would still hold over the revealed fields.</p> <p>See the CreateProof reference for more information.</p> <p>OpenID Connect for Presentation</p> <p>Trinsic offers an OpenID Connect service as an alternative flow for the exchange of a credential between a holder and a verifier.</p> <p>In this flow, a holder simply clicks a link (or scans a QR code), logs into their Trinsic cloud wallet, and selects a credential to share.</p>"},{"location":"walkthroughs/vaccination/#verify-proof","title":"Verify Proof","text":"<p>Once the airline receives the proof, they can use the VerifyProof call to ensure its authenticity.</p> Trinsic CLITypescriptC#PythonJavaGo <pre><code>trinsic config --auth-token $(cat airline.txt)\ntrinsic vc verify-proof --proof-document proof.json\n</code></pre> <pre><code>// The airline verifies the credential\ntrinsic.options.authToken = airline.authToken;\nconst verifyResponse = await trinsic.credential().verifyProof(\nVerifyProofRequest.fromPartial({\nproofDocumentJson: proofResponse.proofDocumentJson,\n})\n);\n</code></pre> <pre><code>// Set active profile to `airline`\ntrinsic = new TrinsicService(_options.CloneWithAuthToken(airline.AuthToken!));\n\n// Verify that Allison has provided a valid proof\nvar verifyResponse = await trinsic.Credential.VerifyProofAsync(new() {\nProofDocumentJson = proofJson\n});\n\nvar credentialValid = verifyResponse?.IsValid ?? false;\n</code></pre> <pre><code># The airline verifies the credential\ntrinsic_service.service_options.auth_token = airline.auth_token\n\nverify_result = await trinsic_service.credential.verify_proof(\n    request=VerifyProofRequest(proof_document_json=credential_proof)\n)\n\nvalid = verify_result.is_valid\n</code></pre> <pre><code>trinsic.setAuthToken(airline.getAuthToken());\n\n// Verify that Allison has provided a valid proof\nvar verifyProofResponse =\ntrinsic\n.credential()\n.verifyProof(\nVerifyProofRequest.newBuilder().setProofDocumentJson(credentialProof).build())\n.get();\n\nboolean isValid = verifyProofResponse.getIsValid();\n</code></pre> <pre><code>// The airline verifies the credential\ntrinsic.SetAuthToken(airline.AuthToken)\nverifyResult, _ := trinsic.Credential().VerifyProof(context.Background(), &amp;credential.VerifyProofRequest{ProofDocumentJson: credentialProof})\nvalid := verifyResult.IsValid\n</code></pre> <p>Interoperability</p> <p>The Verifiable Credentials and Proofs that Trinsic's platform produces are based on open standards.</p> <p>Although we use the VerifyProof call in this example, the proof could be verified using any standards-compliant software.</p>"},{"location":"walkthroughs/vaccination/#full-source-code","title":"Full Source Code","text":"TypescriptC#PythonJavaGo <p>This sample is available as <code>VaccineDemoShared.ts</code> in our SDK repository.</p> <p>This sample is available as <code>VaccineWalkthroughTests.cs</code> in our SDK repository.</p> <p>This sample is available as <code>vaccine_demo.py</code> in our SDK repository.</p> <p>This sample is available as <code>VaccineDemo.java</code> in our SDK repository.</p> <p>This sample is available as <code>vaccine_test.go</code> in our SDK repository.</p>"},{"location":"walkthroughs/vaccination/#governance-setup","title":"Governance Setup","text":"<p>Before we begin, you'll need to prepare your trust registry. This defines who is an authorized issuer of your vaccine card.</p>"},{"location":"walkthroughs/vaccination/#register-issuer","title":"Register Issuer","text":"<p>First, let's grab our account info. You can use an email address, walletId or PublicDID as identifiers for a wallet. We will use publicDID.</p>  Sample Request Response Trinsic CLI <pre><code>trinsic account info\n</code></pre> <p>The response should look like: <pre><code>{\n...\n\"ecosystem_id\": \"urn:trinsic:ecosystems:&lt;ecosystem-name&gt;\",\n\"public_did\": \"did:key:xxxxxxxx......\", // &lt;public_did&gt;\n\"wallet_id\": \"urn:trinsic:wallets:xxxxxx....&gt;\"\n}\n</code></pre></p> <p>RegisterMemberRequestRequest to register a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.did_uri stringDID URI of member to registerwallet_id stringTrinsic Wallet ID of member to registeremail stringEmail address of member to register. Must be associated with an existing Trinsic account.schema_uri stringURI of credential schema to register member as authorized issuer ofvalid_from_utc uint64Unix Timestamp member is valid from. Member will not be considered valid before this timestamp.valid_until_utc uint64Unix Timestamp member is valid until. Member will not be considered valid after this timestamp.</p> <p>RegisterMemberResponseResponse to <code>RegisterMemberRequest</code>This message has no fields</p> <p>Registers an authorized issuer for a specific credential type (identified by its <code>schema_uri</code>), using the public_did, framework_id and template_uri from above:</p>  Sample Request Response Trinsic CLI <pre><code>trinsic trust-registry register-member \\\n--framework-id &lt;framework_id&gt; \\\n--schema &lt;template_uri&gt; \\\n--did &lt;public_did&gt;\n</code></pre> <p>RegisterMemberRequestRequest to register a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.did_uri stringDID URI of member to registerwallet_id stringTrinsic Wallet ID of member to registeremail stringEmail address of member to register. Must be associated with an existing Trinsic account.schema_uri stringURI of credential schema to register member as authorized issuer ofvalid_from_utc uint64Unix Timestamp member is valid from. Member will not be considered valid before this timestamp.valid_until_utc uint64Unix Timestamp member is valid until. Member will not be considered valid after this timestamp.</p> <p>RegisterMemberResponseResponse to <code>RegisterMemberRequest</code>This message has no fields</p>"},{"location":"walkthroughs/vaccination/#check-issuer-status","title":"Check Issuer Status","text":"<p>Check the status of an issuer for a specific credential type using the public_did, framework_uri and template_uri from above:</p>  Sample Request Response Trinsic CLI <pre><code>trinsic trust-registry get-membership-status \\\n--framework-id &lt;framework_id&gt; \\\n--schema &lt;template_uri&gt; \\\n--did &lt;public_did&gt;\n</code></pre> <p>The response should look like: <pre><code>ok\n</code></pre></p> <p>GetMemberAuthorizationStatusRequestRequest to fetch member status in governance framework for a specific credential schema.did_uri stringDID URI of memberschema_uri stringURI of credential schema associated with member</p> <p>GetMemberAuthorizationStatusResponseResponse to <code>GetMemberAuthorizationStatusRequest</code>status RegistrationStatusStatus of member for given credential schemaShow enum valuesRegistrationStatus.CURRENT  = 0Member is currently authorized, as of the time of the queryRegistrationStatus.EXPIRED  = 1Member's authorization has expiredRegistrationStatus.TERMINATED  = 2Member has voluntarily ceased Issuer role under the specific EGFRegistrationStatus.REVOKED  = 3Member authority under specific EGF was terminated by the governing authorityRegistrationStatus.NOT_FOUND  = 10Member is not associated with given credential schema in the EGF</p>"},{"location":"walkthroughs/vaccination/#issue-a-credential-with-governance-framework","title":"Issue a Credential with Governance framework","text":"<p>We need to prepare a credential with a governance framework specified. This will consist of:</p> <ol> <li>Issuing the credential with governance enabled</li> <li>Inserting the credential into your wallet</li> <li>Deriving a proof of the credential</li> </ol> Trinsic CLI <p>First, prepare a file named <code>values.json</code> with the following content:</p> values.json <pre><code>{\n\"firstName\": \"Allison\",\n\"lastName\": \"Allisonne\",\n\"batchNumber\": \"123454321\",\n\"countryOfVaccination\": \"US\"\n}\n</code></pre> <p>Then issue the credential:</p> <pre><code>trinsic vc issue-from-template --template-id &lt;template_id&gt; --values-file values.json --out credential.json\n</code></pre> <pre><code>trinsic wallet insert-item --item credential.json\n</code></pre> <p>The response should look like: <pre><code>ok\nitem id \u2192 \"urn:uuid:...\" // &lt;item_id&gt;\n</code></pre></p> <pre><code>trinsic vc create-proof --item-id &lt;item_id&gt; --out proof.json\n</code></pre>"},{"location":"walkthroughs/vaccination/#verify-a-proof-with-governance-status","title":"Verify a proof with governance status","text":"<p>Now we can verify the proof from the previous step, and get the governance status.</p> Trinsic CLI <pre><code>trinsic vc verify-proof --proof-document proof.json\n</code></pre> <p>The response should look like: <pre><code>is valid \u2192 \"true\"\nvalidation results \u2192 {\n\"CredentialStatus\": {\n\"is_valid\": true,\n    \"messages\": []\n},\n  \"IssuerIsSigner\": {\n\"is_valid\": true,\n    \"messages\": []\n},\n  \"SchemaConformance\": {\n\"is_valid\": true,\n    \"messages\": []\n},\n  \"SignatureVerification\": {\n\"is_valid\": true,\n    \"messages\": []\n},\n  \"TrustRegistryMembership\": {\n\"is_valid\": true,\n    \"messages\": []\n}\n}\n</code></pre></p>"},{"location":"walkthroughs/vaccination/#revoke-issuer","title":"Revoke Issuer","text":"<p>Revoke the status of an issuer for a specific credential type using the public_did, framework_uri and template_uri from above:</p>  Sample Request Response Trinsic CLI <pre><code>trinsic trust-registry unregister-member \\\n--schema &lt;template_uri&gt; \\\n--did &lt;public_did&gt;\n</code></pre> <p>UnregisterMemberRequestRequest to unregister a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.did_uri stringDID URI of member to unregisterwallet_id stringTrinsic Wallet ID of member to unregisteremail stringEmail address of member to unregister. Must be associated with an existing Trinsic account.schema_uri stringURI of credential schema to unregister member as authorized issuer of</p> <p>UnregisterMemberResponseResponse to <code>UnregisterMemberRequest</code>This message has no fields</p>"},{"location":"walkthroughs/vaccination/#verify-a-proof-with-governance-status-after-revocation-of-issuer","title":"Verify a proof with governance status after revocation of issuer","text":"<p>Now we can verify the proof from the previous step, and get the governance status.</p> Trinsic CLI <pre><code>trinsic vc verify-proof --proof-document proof.json\n</code></pre> <p>The response should look like: <pre><code>is valid \u2192 \"false\"\nvalidation results \u2192 {\n\"CredentialStatus\": {\n\"is_valid\": true,\n    \"messages\": []\n},\n  \"IssuerIsSigner\": {\n\"is_valid\": true,\n    \"messages\": []\n},\n  \"SchemaConformance\": {\n\"is_valid\": true,\n    \"messages\": []\n},\n  \"SignatureVerification\": {\n\"is_valid\": true,\n    \"messages\": []\n},\n  \"TrustRegistryMembership\": {\n\"is_valid\": false,\n    \"messages\": [\n\"issuer is not authorized in the specified registry\"\n]\n}\n}\n</code></pre></p> <p>Further Reading: Trust Registries</p> <ul> <li>Learn more about Governance</li> <li>Browse the Provider API reference</li> </ul>"},{"location":"walkthroughs/vaccination/#next-steps","title":"Next Steps","text":"<p>Congratulations! If you've completed all the steps of this walkthrough, you've just created a mini ecosystem of issuers, verifiers, and holders all exchanging credentials. Depending on your goals, there are a couple of possible next steps to take.</p> <ul> <li>Try out a sample app</li> <li>Browse the Service Reference</li> <li>Learn more about the key concepts and technologies at play</li> </ul>"},{"location":"web/","title":"Typescript SDK","text":"<p>The Trinsic Typescript SDK makes it easy to interact with the Trinsic API from any client-side web, Node.js, or React Native application. You can find the SDKs source on Github. The @trinsic/trinsic package comes with Typescript bindings.</p>"},{"location":"web/#installation","title":"Installation","text":"<p>Install the package for Node or Browser from npmjs.com </p> <p>Supported runtimes</p> <p>Recent browsers, Node.js (v16+), React Native (including expo) are all supported. A sample react native application is here</p> Install <pre><code>npm install @trinsic/trinsic\n</code></pre> <p>To import the Trinsic SDK:</p> <pre><code>import { TrinsicService } from \"@trinsic/trinsic\";\n\n// instantiate the service without parameters\nlet trinsic = new TrinsicService();\nconst walletResponse = await trinsic.wallet().createWallet({ ecosystemId: \"acme-corp\" });\n\n// instantiate the service with 'authToken' from the response\ntrinsic = new TrinsicService({ authToken: walletResponse.authToken });\nconst infoResponse = await trinsic.wallet().getMyInfo({});\n\nconsole.log(infoResponse);\n</code></pre> <p>You can find all the SDK methods documented here</p>"}]}