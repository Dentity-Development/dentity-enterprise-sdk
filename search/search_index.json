{"config":{"indexing":"full","jieba_dict":null,"jieba_dict_user":null,"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Introduction"},{"location":"#issue-and-verify-universally-accepted-digital-credentials","text":"<p>Trinsic is the proof of anything platform. We make it easy for people and organizations to prove things about themselves with technology instead of paper documents. Our software is based on Decentralized Identifiers (DIDs) and Verifiable Credentials (VCs), a new digital identity standard. </p> <p>Using Trinsic, organizations and their customers share data between each other in a trustworthy, standardized, and privacy-preserving way without requiring a centralized server or database. </p> <p>We make all of this possible by signing, sharing and storing verifiable data within identity wallets owned by individuals. People can easily share them with others to prove things about themselves anywhere.</p> <p>Learn how to issue and verify universally-accepted digital credentials so that anywhere people go online or in-person, they can simply tap their phone, prove who they are, and get what they need.</p>","title":"Issue and verify universally-accepted digital credentials."},{"location":"#our-products","text":"","title":"Our Products"},{"location":"#trinsic-core","text":"<p>Trinsic Core is infrastructure for digital trust. It's our set of APIs for sending verifiable data between digital identity wallets. Core gives people and organizations the ability to easily and securely prove things about themselves with digital credentials.</p> <p>With Core, you can transform credentials, licenses, passes, and certificates into a W3C standard format that can be exchanged digitally and verified instantly by anyone called a \"verifiable credential\".</p>","title":"Trinsic Core"},{"location":"#trinsic-ecosystems","text":"<p>A layer built on top of Core, Trinsic Ecosystems is a product for organizations that want to build an ecosystem of different issuers, holders, and verifiers of credentials. By ecosystem, we mean a network of companies and consumers that need to be able to securely share and instantly verify data. </p> <p>At Trinsic, we call the organizations that bring together these ecosystems of companies and customers \"providers\" since they are providing digital trust to the ecosystem through Trinsic's infrastructure.</p>  <p>Get Started in 15 Minutes</p> <p>Want to get started using digital credentials quickly? Try our tutorial to get a conceptual walkthrough of a common use case.</p>","title":"Trinsic Ecosystems"},{"location":"early-adopter/","text":"<p>For development teams ready to integrate verifiable credentials for a specific industry or use case, Trinsic Ecosystems has been built specifically for you. We're currently in beta with a small group of customers.</p> <p>If you'd like to join the beta for Trinsic Ecosystems, please reach out! Simply fill out the form below, and we'll get in touch.</p> <p>Sign Up</p>","title":"Introducing Trinsic Ecosystems"},{"location":"roadmap/","text":"","title":"Roadmap"},{"location":"roadmap/#sdks","text":"","title":"SDKs"},{"location":"roadmap/#available-sdks","text":"<ul> <li> .NET</li> <li> Node</li> <li> Python</li> <li> Web</li> <li> Java</li> </ul>","title":"Available SDKs"},{"location":"roadmap/#coming-soon","text":"<ul> <li> Android</li> <li> iOS</li> <li> Go</li> <li> Ruby</li> </ul>","title":"Coming Soon"},{"location":"support/","text":"<p>Normally, the best way to ask quick questions is through the Trinsic Community slack channel.</p> <p>If you have a bug to report, please report it on the Github issues on our SDK. Contributions and additions to this docs site are always welcome.</p> <p>Finally, if you're interested in getting in touch with the team for any other reason, contact us at support@trinsic.id. We treat any feedback as gold.</p>","title":"Have a Question?"},{"location":"android/","text":"<p>The Trinsic Android sample application makes it easy to interact with the Trinsic API. The sample application is located here</p>","title":"Android Sample Application"},{"location":"android/#installation","text":"<ol> <li>Clone the <code>sdk-examples</code> repository</li> <li>Open the folder <code>sdk-examples/android</code> in Android Studio</li> <li>Run gradle build for the first time, it will take a while, but it should pull down all the required <code>.jar</code> files</li> <li>You should be able to build and run the android application.</li> <li>There is an <code>sdk-examples/android-controller</code> application written in Python which allows you to issue credentials/verify proofs outside of the android application for demonstration purposes.</li> </ol>  <p>Note</p> <p>If you want to included the two required Trinsic <code>.jar</code> files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p>  <pre><code>def urlFile = { url, name -&gt;\n    File file = new File(\"$buildDir/download/${name}.jar\")\n    file.parentFile.mkdirs()\n    if (!file.exists()) {\n        new URL(url).withInputStream { downloadStream -&gt;\n            file.withOutputStream { fileOut -&gt;\n                fileOut &lt;&lt; downloadStream\n            }\n        }\n    }\n    files(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\n    // other dependencies\n    implementation urlFile('https://github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0')\n    implementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1')\n}\n</code></pre>","title":"Installation"},{"location":"android/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Java API Reference</p>","title":"Next Steps"},{"location":"cli/","text":"<p>The Trinsic CLI makes it easy to interact with the Trinsic API from your terminal. You can get the CLI on homebrew or build the CLI from source on Github. It contains all the commands of Trinsic's SDKs and makes them interactive. </p>","title":"The Trinsic CLI"},{"location":"cli/#installation","text":"MacOS and LinuxWindowsFrom source   <p>We use homebrew to distribute the CLI packages for MacOS and Linux. Install Homebrew</p> <p>Then run these commands to install the Trinsic CLI <pre><code>brew tap trinsic-id/tap\nbrew install trinsic-cli\n</code></pre></p>   <p>The CLI can be installed using Winget <pre><code>winget install trinsic.okapi\nwinget install trinsic.cli\n</code></pre></p>   <p>The CLI can also be built from source.</p> <p>This requires the Rustup toolchain  installed on your system.</p> <p>Once installed, run this command in terminal:</p> <pre><code>cargo +nightly install --git https://github.com/trinsic-id/sdk trinsic\n</code></pre> <p>To verify that the CLI has been installed successfully, try running:</p> <pre><code>trinsic --help\n</code></pre>","title":"Installation"},{"location":"cli/#next-steps","text":"<p>Once the CLI is installed, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference. For more information about the CLI, read the configuration guide</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"},{"location":"cli/config/","text":"<p>The CLI stores its configuration in the user's home directory in <code>~/.trinsic/</code>. This directory contains the main configuration file <code>config.toml</code> and all the profile data.</p>","title":"Configuration"},{"location":"cli/config/#show-configuration","text":"<p>To print the current configuration file in the terminal use:</p> <pre><code>trinsic config --show\n</code></pre> <p>Typical configuration file may look like this:</p> <pre><code>[server]\naddress = \"https://prod.trinsic.cloud\"\n\n[profile]\ndefault = \"my_profile\"\n</code></pre>","title":"Show Configuration"},{"location":"cli/config/#update-configuration-entry","text":"<p>To change the configuration values, use the <code>config</code> subcommand with the attribute and its value.</p> <pre><code>trinsic config &lt;attribute_name&gt; &lt;attribute_value&gt;\n</code></pre> <p>The following attributes are currently supported:</p>  <code>server-address</code>  <p>Updates the default server address the CLI communicates</p> <pre><code>trinsic config --server-address https://example.com/\n</code></pre>  <code>profile-default</code>  <p>Updates the default profile used with the CLI</p> <pre><code>trinsic config --profile-default alice\n</code></pre>","title":"Update Configuration Entry"},{"location":"cli/demo/","text":"","title":"Trinsic CLI Demo"},{"location":"cli/demo/#steps-to-run","text":"<ul> <li>Click the green Run button</li> <li>Follow walkthrough</li> <li>Note: If you resize this window, make sure to reload the page. If not, the CLI will have display problems.</li> </ul>","title":"Steps to Run"},{"location":"dotnet/","text":"<p>The Trinsic C# / .NET SDK makes it easy to interact with the Trinsic API from your .NET application. The most recent version of the library can be found on NuGet. The Trinsic SDK supports .NET applications written in C#, VB.NET, and F# that utilize any supported version of .NET Core. You can also find the SDKs source on Github.</p>  <p>Supported runtimes</p> <p>.NET targets for iOS, Android, and Blazor are fully supported using the same package dependencies via .NET 6.</p>","title":"The Trinsic C# / .NET SDK"},{"location":"dotnet/#installation-in-a-new-project","text":"<p>Add the required dependencies from Nuget.org </p> Package Manager.NET CLIPackageReference   <pre><code>PM&gt; Install-Package Trinsic\n</code></pre>   <pre><code>dotnet add package Trinsic\n</code></pre>   <pre><code>&lt;PackageReference Include=\"Trinsic\" /&gt;\n</code></pre>","title":"Installation in a new project"},{"location":"dotnet/#configuration","text":"<pre><code>// accountServiceConstructor() {\nvar myAccountService = new AccountService(_options);\n// }\n// accountServiceSignIn() {\nvar myProfile = await myAccountService.SignInAsync(new());\n// }\nmyAccountService.Options.AuthToken = myProfile;\n// accountServiceGetInfo() {\nvar output = await myAccountService.GetInfoAsync();\n// }\nAssert.NotNull(output);\n</code></pre>","title":"Configuration"},{"location":"dotnet/#next-steps","text":"<p>Once the .NET SDK package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API C# API Reference</p>","title":"Next Steps"},{"location":"go/","text":"<p>The Trinsic Go SDK makes it easy to interact with the Trinsic API from any Go application. The most recent version of the library can be found on ____. You can find the SDKs source on Github.</p>","title":"The Trinsic Go SDK"},{"location":"go/#installation-and-configuration","text":"<ul> <li>NOTE: Windows installation is possible, but requires jumping through a few hoops. More details to come later.</li> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>You need to have CGO configured for the okapi native binary link</li> <li>Issue the following command: <pre><code>go install github.com/trinsic-id/sdk/go@latest\n</code></pre></li> <li>To test the installation, try the following go code:</li> </ul> <pre><code>opts, err := sdk.NewServiceOptions()\nif err != nil {\n    panic(\"could not create service options\")\n}\naccountService, err := sdk.NewAccountService(opts)\nif err != nil {\n    panic(\"Account service not created\")\n}\n\nprofile, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\nif err != nil {\n    panic(\"Sign in failed!\")\n}\nfmt.Printf(\"%v\\n\", profile)\n</code></pre>","title":"Installation and Configuration"},{"location":"go/#next-steps","text":"<p>Once the go package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Go API Reference</p>","title":"Next Steps"},{"location":"ios/","text":"<p>The Trinsic Swift SDK makes it easy to interact with the Trinsic API from any application built for iOS, MacCatalyst, or MacOS. The SDK is available for Swift Package Manager and can be added in your dependency section in <code>Package.swift</code> as follows:</p> <pre><code>dependencies: [\n    .package(name: \"Trinsic\", url: \"https://github.com/trinsic-id/sdk-swift\", branch: \"main\")\n],\n</code></pre> <p>You can find more details, source code, and tests for the Swift SDK at trinsic-id/sdk-swift.</p>","title":"The Trinsic Swift SDK"},{"location":"java/","text":"<p>The Trinsic Java SDK makes it easy to interact with the Trinsic API from any Java application. The most recent version of the package is found on the Github Release. You can find the SDKs source on Github.</p>","title":"The Trinsic Java SDK"},{"location":"java/#installation","text":"<ol> <li>Add the <code>urlFile</code> code shown below to your <code>build.gradle</code>.</li> <li>Add the implementations as shown below to your <code>build.gradle</code>.</li> <li>Run <code>gradle build</code> to download the required jar files. This can take some time.</li> </ol>","title":"Installation"},{"location":"java/#configuration","text":"<ol> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>LD_LIBRARY_PATH</code>, even on Windows.</li> </ol>  <p>Note</p> <p>If you want to included the two required Trinsic <code>.jar</code> files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p>  <pre><code>def urlFile = { url, name -&gt;\n    File file = new File(\"$buildDir/download/${name}.jar\")\n    file.parentFile.mkdirs()\n    if (!file.exists()) {\n        new URL(url).withInputStream { downloadStream -&gt;\n            file.withOutputStream { fileOut -&gt;\n                fileOut &lt;&lt; downloadStream\n            }\n        }\n    }\n    files(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\n    // other dependencies\n    implementation urlFile('https://github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0')\n    implementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1')\n}\n</code></pre>","title":"Configuration"},{"location":"java/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Java API Reference</p>","title":"Next Steps"},{"location":"learn/","text":"<p>Understand the key concepts involved when using Trinsic, or work through our tutorials to learn how to build out specific functionality.</p>","title":"Learn"},{"location":"learn/credentials/","text":"<p></p> <p>\"Verifiable Credentials\", or \"VCs\" are digital documents that conform to the W3C Verifiable Credential Data Model. VCs provide a standard for digitally issuing, holding, and verifying data about a subject. A verifiable credential is a set of tamper-evident claims and metadata that cryptographically prove who issued it.  https://www.w3.org/TR/vc-data-model/</p> <p>Verifiable credentials are unique from other kinds of digital documents because they enable you to verify the following things: </p> <ol> <li>The original issuing entity (the source of the data) </li> <li>It was issued to the entity presenting it (the subject of the data) </li> <li>It hasn't been tampered with (the veracity of the data)</li> <li>Whether the issuer revoked the credential as of a particular point in time (the status of the data)</li> </ol> <p>trust triangle</p>","title":"What are Verifiable Credentials"},{"location":"learn/credentials/#components-of-a-credential","text":"<p>To break down the components of a credential, we'll use a digital driver's license as an example.</p>","title":"Components of a Credential"},{"location":"learn/credentials/#issuer-did","text":"<p>As you can see from the diagram above, a verifier will only accept a credential if they trust its source. For example, in the United States a TSA agent will only let you on an airplane if you present a valid driver's license (or other gov ID); they do this because they trust the DMV or other agency that issued it. In order to validate where a credential came from, verifiers use the issuer's DID.</p> <p>Each new issuer is assigned an issuer DID. The issuer DID acts as a public-facing address or public key. In self-sovereign identity, these DIDs are usually written to a public blockchain, but other locations are possible, too. Each issuer DID has an associated private key which is used to cryptographically \"sign\" each issued credential. In fact, each attribute inside the credential is signed in this manner, allowing the holder of the credential to share only a subset of the attributes when desired. For example, someone could share their name and age from their driver's license without sharing the driver's license number, address, and hair color. Using the issuer DID and straightforward public-private key cryptography, anyone can verify the attributes in the credential were attested to by the issuer. </p>","title":"Issuer DID"},{"location":"learn/credentials/#schema","text":"<p>Each credential needs a template so the data can be shared and interpreted correctly. That template is called a Schema.</p> <p>Schemas are the general structure of the credential. In our example, they tell us what information must be included on the driver's license in order for it to be valid, like Full name, Address, Eye color, etc. </p> <p>In short, they are the attributes that you want to include in this credential.</p>","title":"Schema"},{"location":"learn/credentials/#example","text":"<pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"description\": \"Email\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"emailAddress\": {\n            \"type\": \"string\",\n            \"format\": \"email\"\n            }\n        },\n    \"required\": [\"emailAddress\"],\n    \"additionalProperties\": false\n}\n</code></pre> <p>Schemas are nonproprietary; any issuer can view/use the schemas written by any other issuer.</p> <p>We abstract schema creation away into the same action as creation of a credential template. Keep reading to read how to create a schema and credential template. </p>","title":"Example:"},{"location":"learn/credentials/#verifications","text":"<p>Passes are documents generated from credentials that contain only the information required to be verified. They can be generated in advance or in real-time. Passes minimize the information about you that is shared with third parties.</p> <p>Credentials are signed using BLS keys. These create from the credential fields. </p>","title":"Verifications"},{"location":"learn/ecosystems/","text":"<p>Exchanging credentials often requires many different participants to all communicate and collaborate. Aligning standards and incentives is challenging. </p> <p>We've made it simple to create an ecosystem of participants to all exchange credentials. </p>","title":"Ecosystems"},{"location":"learn/ecosystems/#potential-scenarios","text":"<p>Industry groups, enterprises, and startups who are deploying this technology to multi-party ecosystems. Our focus on building for interoperability, hyper-scalability, and ease of use means you can get to market faster with a better product with Trinsic than any other way. </p> <p>Trust ecosystems are networks of participants that can authenticate to and share data with one another. Trust ecosystems exist all around us, but most are analog and disaggregated. The first trust ecosystems to go digital were payments networks. Visa, MasterCard, etc. introduced a standard mechanism to allow consumers to make purchases with any merchant using credit from any bank. Visa created an enduring business while simultaneously unlocking value for all participants involved.</p> <p>Credit card networks represent only one kind of trust ecosystem. A trust ecosystem at a minimum has the following 4 roles.</p> <ul> <li>Provider - provides the tools and rules to the rest of the participants to ensure a healthy ecosystem, generally through a product experience that is sold to the other participants</li> <li>Issuer - is the source of data that is shared throughout an ecosystem</li> <li>Verifier - consumes data in an ecosystem</li> <li>Holder - holds data, and is generally the subject of the data, in an ecosystem</li> </ul>","title":"Potential Scenarios"},{"location":"learn/ecosystems/#anatomy-of-a-trust-ecosystem","text":"<p>Before diving into the value provided by each participant, it\u2019s helpful to cover how it works at a high level. You may dive deeper into any of these items by clicking into the respective pages. We\u2019ll use the analogy of a payment network to conceptualize the purpose of each component.</p> <p>Wallet - A place to securely store verifiable credentials.</p> <p>Credential - W3C Verifiable Credentials that contain valuable data about a subject. These are signed and issued by an issuer.</p> <p>Pass - A presentation of a verifiable credential that only includes the information required for use case.</p> <p>Underlying Tech - All of the additional standardized technology Trinsic uses to build trust ecosystems.</p>","title":"Anatomy of a Trust Ecosystem"},{"location":"learn/ecosystems/#value-of-trust-ecosystems-to-participants","text":"<p>The first step to successfully building a trust ecosystem that can scale is to identify the value for each of the participants. Here we will elaborate on the value derived by each actor in an ecosystem and how Trinsic\u2019s platform is optimized to help deliver it.</p>","title":"Value of Trust Ecosystems to Participants"},{"location":"learn/ecosystems/#providers","text":"<p>Providers typically already have, or are building, a product or platform to sell to the issuers and verifiers with the goal of creating a sustainable business. </p> <p>Visa, for example, isn\u2019t a currency, a bank, or a merchant. They sell the rails for transaction settlement to banks and merchants to enable the seamless transactions we all enjoy. By taking a small interchange fee, they capture value alongside the banks and merchants and have built a sustainable business.</p> <p>Trinsic is the only company to offer a product tailored specifically for providers. That means instead of patching together various open source components meant for issuers or verifiers, Trinsic offers a product built from the ground-up to accommodate the unique needs of providers. Ultimately, that means providers using Trinsic get to market faster with better products.</p>","title":"Providers"},{"location":"learn/ecosystems/#issuers","text":"<p>Issuers realize value when they extend or augment their existing business operations. By issuing the data they already have in verifiable credential form, they often can increase revenue, reduce verification costs, and improve brand presence. </p> <p>When credit cards were in their infancy, banks began issuing cards because it allowed them to continue their existing business (giving credit) in a new way. Likewise, the issuers that get the most value from verifiable credentials are ones who already have data about people, and simply need to give it to them in a new way (e.g. medical labs who already give paper documents can now give digital form).</p> <p>Trinsic\u2019s platform is optimized to both reduce onboarding costs and add help issuers scale without increasing their costs</p> <ul> <li>Before credit cards banks could offer various consumer loans</li> </ul>","title":"Issuers"},{"location":"learn/ecosystems/#holders","text":"<p>Holders acquire the most convenient way to prove something about themselves digitally, both in-person and online</p> <ul> <li>Before credit cards, consumers needed to pay with paper. Paying with credit meant bespoke processes with each individual retailer (e.g. opening a tab at a bar, creating a Macy\u2019s account, etc). Likewise today our digital identities are all siloed and separate, resulting in a myriad of problems for consumers.</li> </ul>","title":"Holders"},{"location":"learn/ecosystems/#verifiers","text":"<p>Verifiers get instant, trusted authentication and verification without needing to maintain their own infrastructure</p> <ul> <li>Before credit card networks like Visa, merchants needed to issue credit and manage collections in-house if they wanted customers who could buy on credit. Likewise, companies in virtually every industry have compliance, risk, and identity departments where they manage this in-house. Just as Visa turned electronic payments into a simple terminal installation for merchants, so too will trust ecosystems unlock the ability for verifiers of all kinds to focus on their true business without compromising on trust and security.</li> </ul> <p>Like the internet itself, trust over IP represents a massive business opportunity for innovators in all industries. And like the internet itself, the vast majority of the value will be created at the application layer.</p>","title":"Verifiers"},{"location":"learn/intro/","text":"<p>Trinsic is a hosting provider for identity wallets and an SDK for developers that want to interact with them. You can use Trinsic to give your end-users identity wallets and then share, store, and verify data through them.</p>","title":"What is Trinsic?"},{"location":"learn/intro/#wallets","text":"<p>Identity Wallets are secure, partitioned data stores for information that needs to get verified. This normally is a person, but it can also be an organization or a device. </p> <p>You can use Trinsic's platform to invite end-users to create a cloud-hosted identity wallet that can be accessed on any device using multi-factor passwordless authentication. </p> <p>Once created, applications and organizations can issue data to the identity wallet. Other applications can request to verify information from the wallet. If the end-user accepts the request, a proof of the requested information will be created and sent to the requester. </p> <p>Using identity wallets, you can build powerful products that preserve your end-users' privacy without compromising on convenience.</p> <p>Wallet Service</p>","title":"Wallets"},{"location":"learn/intro/#credentials-proofs","text":"<p>Trinsic's wallets are built to represent verifiable data as credentials. This allows any information sent to the identity wallet to be easily verified using interoperable standards. Because we follow a standardized open data model, identity wallets can bridge software platforms, letting individuals use their data wherever they choose. </p> <p>To minimize the amount of information that is requested from identity wallets, a credential's attributes can be filtered to generate a proof of the credential with only the data required to fulfill a verifier's request.</p> <p>Credential Service</p>","title":"Credentials &amp; Proofs"},{"location":"learn/intro/#templates","text":"<p>Credential templates let you publish a credential format for others to follow. There are often more than one issuer of the same type of credential, and this allows issuers to reuse the same credential format and share the same attribute types. </p> <p>When data models can be reused, more interoperability can be achieved between different systems. This lets data that previously had to be manually entered via form or sent via custom API integration get automatically exchanged and verified without needing human interaction. </p> <p>Template Service</p>","title":"Templates"},{"location":"learn/intro/#trust-registries","text":"<p>A trust registry is a way for a wallet to publish a list of other wallets that it trusts to issue and verifier credentials. </p> <p>This is useful when building trust without a centralized service or database. If you onboard wallets, it is likely that the wallet holders already have a connection with you. You can publish a list of issuers and verifiers that you've also vetted and onboarded and the wallet holders can reference this list before receiving or sharing their information with another wallet.</p> <p>When verifying a credential, a verifier can cross-reference the issuer's identifier within the credential with a trust registry to ensure it was actually issued by an organization that they trust.</p> <p>Trust Registry Service</p>","title":"Trust Registries"},{"location":"learn/intro/#ecosystems","text":"<p>When creating a product that uses identity wallets, it is useful to have the tools to onboard participants that want to either issue, store, or verify credentials. Trinsic Ecosystems is a set of tools built so you can invite participants to an ecosystem and configure their wallets for them. This makes it possible to quickly go live with a proof of concept or pilot without requiring your ecosystem participants to do any setup or integrations themselves.</p> <p>Provider Service</p>","title":"Ecosystems"},{"location":"learn/intro/#open-standards","text":"<p>Trinsic's technology is all based on open web standards. Our goal is to promote a future of applications where identity and personal data is independent from applications. To meet this end, we use decentralized identifiers that can be generated and resolved without needing a centralized database. We also follow the data model for verifiable credentials so that data sent by one application can be presented at another without requiring a specific vendor. </p> <p>Learn More</p>","title":"Open Standards"},{"location":"learn/intro/#security-and-privacy","text":"<p>As a hosting provider of identity wallets, we've recognized the need for strong security and privacy since before we started building. </p> <p>Our identity wallets are secured using zero knowledge authentication. No private keys are stored or processed on our servers. They are all generated locally by our SDKs. We do this using a lightweight zero-knowledge proof protocol. Even if an adversary were to intercept a payload, they would not be able to reuse the token to gain additional access to our system.</p> <p>Learn More</p>","title":"Security and Privacy"},{"location":"learn/security/","text":"","title":"Security Infrastructure"},{"location":"learn/security/#overview","text":"<p>Our cloud services are secured using a novel method of authentication based on zero-knowledge proofs . This approach allows us to introduce passwordless client authentication with improved security and user experience.</p> <p>Compared to traditional security methods that store users' credentials on the server, our approach relies on a one-time client/server negotiation without storing any user secrets on our servers. All secrets are stored with the user client and are entirely in their control. During authentication, users present proof of knowledge of these secret tokens, instead of the actual tokens. This proof is generated with each request and is unique for that request only.</p>","title":"Overview"},{"location":"learn/security/#zero-knowledge-architecture","text":"<p>TODO: Comparison to traditional security models</p>","title":"Zero-knowledge Architecture"},{"location":"learn/security/#oberon-auth-scheme","text":"<p>A succinct ZKP protocol for authentication. It works by using techniques similar to Identity-Based/Attribute-Based signatures.</p> <p>Oberon allows endpoints to issue multi-factor capable tokens to consumers who can prove their validity without disclosing the tokens themselves and without requiring email, SMS, or authenticator apps. Endpoints only need to store a single public key and not any tokens. An attacker that breaks into the server doesn't have any password/token files to steal and only would see a public key. The proof of token validity is only 256 bytes while the token itself is only 48 bytes. The issuing party and verifying servers can be separate entities.</p> <p>Crypto details for Oberon </p>","title":"Oberon Auth Scheme"},{"location":"learn/security/#account-registration","text":"<p>The below diagram illustrates how client and server interact during the registration process and negotiate the data for authentication:</p> <pre><code>sequenceDiagram\n  actor Client\n  Client-&gt;&gt;Server: Register new account or ecosystem\n  Server--&gt;&gt;Client: Generated token\n  Note right of Server: Does not store token\n  opt\n    Note over Client: Apply multi-factor security&lt;br /&gt;using PIN, word phrase, HSM, etc.&lt;br /&gt;by cryptographically blinding&lt;br/&gt;the secret token\n    Client-&gt;&gt;Client: Token protection\n  end\n  Client-&gt;&gt;Client: Save token on client device</code></pre>","title":"Account Registration"},{"location":"learn/security/#api-requests","text":"<p>The process of making authenticated API requests against the server involves generating a proof of knowledge and appending it to the request headers. This proof is:</p> <ul> <li>valid for a limited time only (order of milliseconds)</li> <li>unique and cannot be used twice (replay protection)</li> <li>bound to the current request payload (mitm protection)</li> </ul> <p>The diagram below illustrates the steps involved in generating proof and interacting with the server.</p> <pre><code>sequenceDiagram\n    actor U as Client\n    participant A as Server\n\n    U-&gt;&gt;U: Read Token\n    U-&gt;&gt;U: Generate proof of token\n    U-&gt;&gt;A: Make API Request\n    note right of U: Proof is added in 'Authorization' header\n\n    A-&gt;&gt;A: Check authorization\n\n    alt sucesss\n        A-&gt;&gt;A: Process request\n        A--&gt;&gt;U: Send response\n    else invalid proof\n        A--&gt;&gt;U: 401 Unauthorized\n    end</code></pre>","title":"API Requests"},{"location":"learn/standards/","text":"","title":"Underlying Tech"},{"location":"learn/standards/#linked-data","text":"<p>When we consider credentials getting exchanged online far and wide, a problem starts to occur - how does everyone know what every else means when they show a credential? To the rescue comes Linked Data, a format for representing structured data with self-contained descriptors of that data.</p> <p>\"Linked data is to spreadsheets and databases what the web of hypertext documents is to word processor files\" - W3C Wiki on Linked Data</p>","title":"Linked Data"},{"location":"learn/standards/#decentralized-identifiers","text":"<p>Taken from the Verifiable Credential Data Model, a decentralized identifier is \"a portable URL-based identifier, also known as a DID, associated with an entity. These identifiers are most often used in a verifiable credential and are associated with subjects such that a verifiable credential itself can be easily ported from one repository to another without the need to reissue the credential. An example of a DID is <code>did:example:123456abcdef</code>\"</p>","title":"Decentralized Identifiers"},{"location":"learn/standards/#zero-knowledge-proofs","text":"<p>One of the most exciting qualities of verifiable credentials are their ability to minimize the data shared about you when you prove who you are. The classic example is showing your driver's license in a bar. While a human bouncer may forget all the revealing information on your driver's license, a computerized bouncer that scans your driver's license never forgets any information. With zero knowledge proofs, you can choose specific information from your credentials to share with verifiers.</p> <p>These are enabled through a BBS+ Signature specification.</p>","title":"Zero Knowledge Proofs"},{"location":"learn/templates/","text":"<p>Trinsic's credential templates make it easy to define types of credentials and publish these types for multiple issuers all to use. Credential templates will create two things to include in a credential: a json schema and a json ld context. Templates remove all of that complexity and let you define a list of attributes along with the attribute types and descriptions. </p> <p>This an example of a list of attributes that would comprise a credential template: </p> <pre><code>{\n    \"name\": {\n        \"type\": \"string\",\n        \"description\": \"Name of the business\",\n    },\n    \"website\": {\n        \"type\": \"string\",\n        \"description\": \"More information about the business\"\n    },\n    \"rating\":{\n        \"type\": \"number\",\n        \"description\": \"rating on scale of 1-10\",\n        \"optional\": false\n    },\n    \"details\":{\n        \"type\": \"string\",\n        \"description\": \"An individual's last name\",\n        \"optional\": false\n    }\n}\n</code></pre> <p>This will create a Template that has the following structure: <pre><code>TemplateData {\n    id: \"urn:template:alices-local-guides:review\",\n    name: \"Review\",\n    version: 1,\n    fields: {\n        \"name\": TemplateField {\n            description: \"Name of the business\",\n            optional: false,\n            r#type: String,\n        },\n        \"rating\": TemplateField {\n            description: \"rating on scale of 1-10\",\n            optional: false,\n            r#type: Number,\n        },\n        \"details\": TemplateField {\n            description: \"An individual's last name\",\n            optional: false,\n            r#type: String,\n        },\n        \"website\": TemplateField {\n            description: \"More information about the business\",\n            optional: false,\n            r#type: String,\n        },\n    },\n    allow_additional_fields: true,\n    schema_uri: \"https://staging-schema.trinsic.cloud/__default/review\",\n    context_uri: \"https://staging-schema.trinsic.cloud/__default/review/context\",\n    ecosystem_id: \"__default\",\n    r#type: \"VerifiableCredential\",\n}\n</code></pre> You can view the <code>schema_uri</code> and the <code>context_uri</code> in the browser as raw json</p>","title":"Credential Templates"},{"location":"learn/trust-registries/","text":"<p>In many real-world credential exchange scenarios, a credential holder or verifier has the question \u201cHow do I know the issuer of this credential is trustworthy?\u201d</p> <p>Credential holders may also be uneasy about sharing information with a verifier if trust in the verifier has not been established.</p> <p>These problems can be solved by having a trusted third party vouch for the trustworthiness of a credential exchange participant.</p> <p>A trust registry is a list of authorized issuers and verifiers in the ecosystem and the types of credentials and passes they are authorized to issue and verify.</p>","title":"Trust Registries"},{"location":"learn/trust-registries/#specification","text":"<p>The Trust over IP Foundation has a specification for an interoperable trust registry. </p> <p>Our implementation is based off of this spec.</p>","title":"Specification"},{"location":"learn/wallets/","text":"","title":"Wallets"},{"location":"learn/wallets/#what-are-wallets","text":"<p>A wallet is a secure place to store credentials. You can create a wallet using the Trinsic CLI or SDK and begin using it to store and share credentials.  Wallet storage is scoped to a single person or subject. Each wallet has the capability to store and share credentials and proofs. A provider wallet can also define templates, create an ecosystem governance framework, and invite wallets to their ecosystem. </p> <p>Data wallets are meant to help individuals manage their digital credentials and cryptographic keys. </p>","title":"What are wallets?"},{"location":"learn/wallets/#how-to-use-wallets-in-your-app","text":"<p>Instead of users creating accounts when they sign up for your app, users can instead connect their wallet. Because many users will be first-time wallet holders, if a user is signing up for your app and they don't have a wallet, we make it easy to create new wallets for your users with the <code>invite</code> command. Once you've invited a user to a wallet, they can enter the 2fa code to log in. </p> <p>You can give each of your end-users a wallet tied to their email address or phone number. </p>","title":"How to use wallets in your app"},{"location":"learn/wallets/#wallet-architecture","text":"<p>While wallets are hosted on our server, your client application must connect with the wallet (using device stored keys). Wallet communication is peer to peer. </p> <p>Wallets can be thought of a little like an email inbox. Each wallet can only be accessed by a set of keys stored on devices. </p>","title":"Wallet Architecture"},{"location":"learn/wallets/#commands","text":"<ul> <li>Store Item</li> <li>Search</li> <li>Send</li> </ul>","title":"Commands"},{"location":"node/","text":"<p>The Trinsic Node SDK makes it easy to interact with the Trinsic API from any backend javascript application. The most recent version of the library can be found on npm. You can find the SDKs source on Github.</p>","title":"The Trinsic Javascript / Node SDK"},{"location":"node/#installation","text":"<p>Install the package for Node from npmjs.com </p> Install   <pre><code>npm i @trinsic/trinsic\n</code></pre>","title":"Installation"},{"location":"node/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference.</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"},{"location":"python/","text":"<p>The Trinsic Python SDK makes it easy to interact with the Trinsic API from any Python application. The most recent version of the library can be found on PyPi. You can find the SDKs source on Github.</p>","title":"The Trinsic Python SDK"},{"location":"python/#installation-and-configuration","text":"<ul> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>LD_LIBRARY_PATH</code>, even on Windows.</li> <li>Recommended: Create a virtual environment</li> <li>Install the trinsic package <pre><code>pip install trinsic-sdk\n</code></pre></li> <li>Test installation by running the following python script:</li> </ul> <pre><code>import asyncio\nfrom trinsic.services import AccountService\n\nasync def demo():\n    account_service = AccountService()\n    profile = await account_service.sign_in()\n    print(profile)\n    account_service.close()\nif __name__ == \"__main__\":\n    asyncio.run(demo())\n</code></pre> <ul> <li>The output should look something like this: <pre><code>AccountProfile(profile_type='https://trinsic.id/security/v1/oberon', auth_data=b'\\n*urn:trinsic:wallets:JkhchLXS8NDwTjmJjNogkQ\\x12$1d58106c-325a-4f45-abe0-6a14aa613a10', auth_token=b'\\x83E\\x06p\\xd60V\\xe0D\\x12NU\\xe7\\n6\\x06\\x19 \\x0b\\xe0\\x8er\\xf2\\xc1\\xb3\\x96\\xdb\\xbd/\\xf5#\\xa7\\xe7F\\x10\\x97E\\xe2\\xa9\\xc4\\x10\\xdfJ\\xbe\\xea\\xa3Fz', protection=TokenProtection())\n</code></pre></li> </ul>","title":"Installation and Configuration"},{"location":"python/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Python API Reference</p>","title":"Next Steps"},{"location":"reference/","text":"<p>If you are ready to begin integrating the SDK, make sure you have an SDK installed and configured. You can install each SDK by following the instructions in each page under Build in the sidebar.</p> <p>When using the SDK, you can pass parameters to the default service constructors and use the provided methods to set different active profiles.</p>","title":"Overview"},{"location":"reference/#authorization","text":"<p>See our security section for more information on how we have implemented wallet authentication and authorization.</p>","title":"Authorization"},{"location":"reference/#sdk-services","text":"<p>Our SDK is broken down into the following services:</p> <ul> <li>Account Service</li> <li>Credential Service</li> <li>Provider Service</li> <li>Template Service</li> <li>Trust Registry Service</li> <li>Wallet Service</li> </ul>","title":"SDK Services"},{"location":"reference/#using-an-sdk-service","text":"<p>If you are using one of the Trinsic SDKs, you will need to create an instance of a service in order to use it.</p> TypeScriptC#PythonGoJavaRuby   <pre><code>const accountService = new AccountService();\n</code></pre>   <pre><code>var myAccountService = new AccountService(_options);\n</code></pre>   <pre><code>account_service = AccountService(server_config=trinsic_config())\n</code></pre>   <pre><code>opts, err := NewServiceOptions(WithTestEnv())\nif !assert2.Nil(err) {\n    return\n}\n\naccountService, err := NewAccountService(opts)\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var accountService = new AccountService(TrinsicUtilities.getTrinsicServiceOptions());\n</code></pre>   <pre><code>account_service = Trinsic::AccountService.new(nil, Trinsic::trinsic_prod_server)\n</code></pre>    <p>All service constructors also accept a ServiceOptions object as an argument, allowing you to specify a default ecosystem and other configuration properties.</p> ServiceOptionsConfiguration for Trinsic SDK Servicesserver_endpoint stringTrinsic API endpoint. Defaults to `prod.trinsic.cloud`server_port int32Trinsic API port; defaults to `443`server_use_tls boolWhether TLS is enabled between SDK and Trinsic API; defaults to `true`auth_token stringAuthentication token for SDK calls; defaults to empty string (unauthenticated)default_ecosystem stringDefault ecosystem ID to use for various SDK calls; defaults to `default` <p>The exact structure of this object will depend on the language you are working with. You can always rely on your editor's intellisense when in doubt. </p>","title":"Using an SDK Service"},{"location":"reference/other/openid/","text":"","title":"OpenID Credential Exchange Service"},{"location":"reference/other/openid/#overview","text":"<p>Trinsic provides an OpenID Connect  (\"OIDC\") service which enables verifiers to request credentials from a user's cloud wallet in a simple and secure way.</p> <p>This service does not require the use of Trinsic's SDKs in the user's browser, and is therefore lightweight and easy to integrate.</p>  <p>Credential Issuance</p> <p>Currently, Trinsic's OpenID Connect service only enables the sharing of a credential between holder and verifier. We plan to support issuance through this service at a later date.</p> <p>In the meantime, use the InsertItem SDK call to store credentials in a holder's wallet.</p>","title":"Overview"},{"location":"reference/other/openid/#integration","text":"","title":"Integration"},{"location":"reference/other/openid/#openid-connect-protocol","text":"<p>Because this is an OpenID Connect service, any compliant library may be used -- as long as it enables you to specify additional custom query parameters on the initial outbound URL.</p>  <p>OIDC Flow Implementation</p> <p>The specifics of the OpenID Connect protocol -- and how to implement it -- are out of scope for this documentation.</p> <p>If you would like to see an example implementation of a verification flow against this service, see the sample below.</p>","title":"OpenID Connect Protocol"},{"location":"reference/other/openid/#configuration","text":"<p>Configure your OIDC library with the following parameters:</p> <ul> <li><code>authority</code><ul> <li>Must be <code>https://connect.trinsic.cloud/</code></li> </ul> </li> <li><code>response_type</code><ul> <li>Must be <code>code</code></li> </ul> </li> <li><code>scope</code><ul> <li>Must be <code>openid</code></li> </ul> </li> <li><code>client_id</code><ul> <li>Any string which uniquely represents your client application</li> <li>In future, we may require registration of client IDs with Trinsic</li> </ul> </li> <li><code>redirect_uri</code><ul> <li>The URI your user should be redirected to once they have completed (or canceled) the flow</li> </ul> </li> <li>Additional Query Parameters<ul> <li><code>trinsic:ecosystem</code><ul> <li>Name of Ecosystem to fetch credentials from</li> <li>Only credentials which were issued within this Ecosystem may be returned</li> </ul> </li> <li><code>trinsic:schema</code><ul> <li>Comma-separated list of Schema URLs</li> <li>Only credentials which match one of these schemas may be returned</li> </ul> </li> </ul> </li> </ul>","title":"Configuration"},{"location":"reference/other/openid/#response-data","text":"<p>Once the user has returned to your redirect URL, exchange the authorization code (added to your redirect URI as a query parameter named <code>code</code>) for an identity token using your OIDC library.</p> <p>You will receive a JSON object of the following form:</p> <pre><code>{\n    \"id_token\": \"{JWT containing same data as vp_token}\",\n    \"access_token\":\"invalid\",\n    \"token_type\":\"Bearer\",\n    \"vp_token\":{\n        \"@context\":[\n            \"https://www.w3.org/2018/credentials/v1\",\n            \"https://w3id.org/bbs/v1\",\n            ...\n        ],\n        \"id\":\"{UUID of Holder Wallet}\",\n        \"type\":[\n            ...,\n            \"VerifiableCredential\"\n        ],\n        \"credentialSchema\":{\n            ...\n        },\n        \"credentialStatus\":{\n            ...\n        },\n        \"credentialSubject\":{\n            ...\n        },\n        \"issuanceDate\":\"{Issue date of credential}\",\n        \"issuer\":\"{DID of Issuer}\",\n        \"proof\":{\n            ...\n        }\n    }\n}\n</code></pre>  <p>Credential Format</p> <p>Note that the above data has been modified for brevity. </p> <p>The <code>@context</code> and <code>type</code> arrays will contain additional entries which are specific to the credential.</p>","title":"Response Data"},{"location":"reference/other/openid/#verify-the-received-proof","text":"<p><code>vp_token</code> is a Verifiable Proof; before making use of its data, you must verify it. </p> <p>This proof can be verified with any library that supports VC verifications for BBS+ signatures. It can also be verified using Trinsic's SDK; this is as simple as passing the proof to the VerifyProof call.</p>  <p>Always Verify</p> <p>It may be tempting to simply take the data in <code>vp_token</code> and act upon it without first verifying the proof.</p> <p>Always verify the proof before making use of its data. </p> <p>Without verification, the received proof is of no more value than an unsubstantiated claim made by your user.</p>","title":"Verify the Received Proof"},{"location":"reference/other/openid/#sample","text":"<p>If you'd like to see how to implement a basic OIDC flow against this service, or just want to see it in action, check out our client-side verification flow example .</p> <p>You'll need to fork the repl and follow the instructions in <code>README.md</code>.</p>","title":"Sample"},{"location":"reference/proto/","text":"<p></p> <p>This page documents the Protobuf Services and Messages which compose the Trinsic API.</p> <p></p> <p>Top</p>","title":"Protocol Documentation"},{"location":"reference/proto/#sdkoptionsv1optionsproto","text":"<p></p>","title":"sdk/options/v1/options.proto"},{"location":"reference/proto/#serviceoptions","text":"<p>Configuration for Trinsic SDK Services</p>    Field Type Description     server_endpoint string Trinsic API endpoint. Defaults to <code>prod.trinsic.cloud</code>   server_port int32 Trinsic API port; defaults to <code>443</code>   server_use_tls bool Whether TLS is enabled between SDK and Trinsic API; defaults to <code>true</code>   auth_token string Authentication token for SDK calls; defaults to empty string (unauthenticated)   default_ecosystem string Default ecosystem ID to use for various SDK calls; defaults to <code>default</code>       <p></p> <p>Top</p>","title":"ServiceOptions"},{"location":"reference/proto/#servicescommonv1commonproto","text":"<p></p>","title":"services/common/v1/common.proto"},{"location":"reference/proto/#nonce","text":"<p>Nonce used to generate an oberon proof</p>    Field Type Description     timestamp int64 UTC unix millisecond timestamp the request was made   request_hash bytes blake3256 hash of the request body    <p></p>","title":"Nonce"},{"location":"reference/proto/#serverconfig","text":"Field Type Description     endpoint string service endpoint   port int32 service port   use_tls bool indicates if tls is used     <p></p>","title":"ServerConfig"},{"location":"reference/proto/#responsestatus","text":"Name Number Description     SUCCESS 0    WALLET_ACCESS_DENIED 10    WALLET_EXISTS 11    ITEM_NOT_FOUND 20    SERIALIZATION_ERROR 200    UNKNOWN_ERROR 100       <p></p> <p>Top</p>","title":"ResponseStatus"},{"location":"reference/proto/#servicesproviderv1providerproto","text":"<p></p>","title":"services/provider/v1/provider.proto"},{"location":"reference/proto/#service-provider","text":"Method Name Request Type Response Type Description     CreateEcosystem CreateEcosystemRequest CreateEcosystemResponse Create new ecosystem and assign the authenticated user as owner   UpdateEcosystem UpdateEcosystemRequest UpdateEcosystemResponse Update an existing ecosystem   AddWebhook AddWebhookRequest AddWebhookResponse Add a webhook endpoint to the ecosystem   DeleteWebhook DeleteWebhookRequest DeleteWebhookResponse Delete a webhook endpoint from the ecosystem   EcosystemInfo EcosystemInfoRequest EcosystemInfoResponse Get ecosystem information   GenerateToken GenerateTokenRequest GenerateTokenResponse Generates an unprotected authentication token that can be used to configure server side applications   Invite InviteRequest InviteResponse Invite a user to the ecosystem   InvitationStatus InvitationStatusRequest InvitationStatusResponse Check the invitation status   GetOberonKey GetOberonKeyRequest GetOberonKeyResponse Returns the public key being used to create/verify oberon tokens   GetEventToken GetEventTokenRequest GetEventTokenResponse Generate a signed token (JWT) that can be used to connect to the message bus     <p></p>","title":"Service - Provider"},{"location":"reference/proto/#addwebhookrequest","text":"<p>Request to add a webhook to an ecosystem</p>    Field Type Description     destination_url string Destination to post webhook calls to   secret string HMAC secret for webhook validation   events string[] Events to subscribe to. Default is \"*\" (all events)    <p></p>","title":"AddWebhookRequest"},{"location":"reference/proto/#addwebhookresponse","text":"<p>Response to <code>AddWebhookRequest</code></p>    Field Type Description     ecosystem Ecosystem Ecosystem with new webhook    <p></p>","title":"AddWebhookResponse"},{"location":"reference/proto/#createecosystemrequest","text":"Field Type Description     name string Globally unique name for the Ecosystem. This name will be part of the ecosystem specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen.   description string Ecosystem description   uri string External URL associated with your organization or ecosystem entity   details services.account.v1.AccountDetails The account details of the owner of the ecosystem    <p></p>","title":"CreateEcosystemRequest"},{"location":"reference/proto/#createecosystemresponse","text":"Field Type Description     ecosystem Ecosystem Details of the created ecosystem   profile services.account.v1.AccountProfile Account profile for auth of the owner of the ecosystem   confirmation_method services.account.v1.ConfirmationMethod Indicates if confirmation of account is required. This setting is configured globally by the server administrator.    <p></p>","title":"CreateEcosystemResponse"},{"location":"reference/proto/#deletewebhookrequest","text":"<p>Request to delete a webhook from an ecosystem</p>    Field Type Description     webhook_id string ID of webhook to delete    <p></p>","title":"DeleteWebhookRequest"},{"location":"reference/proto/#deletewebhookresponse","text":"<p>Response to <code>DeleteWebhookRequest</code></p>    Field Type Description     ecosystem Ecosystem Ecosystem after removal of webhook    <p></p>","title":"DeleteWebhookResponse"},{"location":"reference/proto/#ecosystem","text":"Field Type Description     id string URN of the ecosystem   name string Globally unique name for the ecosystem   description string Ecosystem description   uri string External URL associated with the organization or ecosystem entity   webhooks WebhookConfig[] Configured webhooks, if any    <p></p>","title":"Ecosystem"},{"location":"reference/proto/#ecosysteminforequest","text":"<p>Request to fetch information about an ecosystem</p> <p></p>","title":"EcosystemInfoRequest"},{"location":"reference/proto/#ecosysteminforesponse","text":"<p>Response to <code>InfoRequest</code></p>    Field Type Description     ecosystem Ecosystem Ecosystem corresponding to requested <code>ecosystem_id</code>    <p></p>","title":"EcosystemInfoResponse"},{"location":"reference/proto/#generatetokenrequest","text":"Field Type Description     description string Description to identify this token    <p></p>","title":"GenerateTokenRequest"},{"location":"reference/proto/#generatetokenresponse","text":"Field Type Description     profile services.account.v1.AccountProfile Account authentication profile that contains unprotected token    <p></p>","title":"GenerateTokenResponse"},{"location":"reference/proto/#geteventtokenrequest","text":"<p>generates an events token bound to the provided ed25519 pk</p>    Field Type Description     pk bytes     <p></p>","title":"GetEventTokenRequest"},{"location":"reference/proto/#geteventtokenresponse","text":"<p>response message containing a token (JWT) that can be used to connect directly to the message streaming architecture</p>    Field Type Description     token string a JWT bound to the PK provided in the request    <p></p>","title":"GetEventTokenResponse"},{"location":"reference/proto/#getoberonkeyrequest","text":"<p>request message for GetOberonKey</p> <p></p>","title":"GetOberonKeyRequest"},{"location":"reference/proto/#getoberonkeyresponse","text":"<p>response message for GetOberonKey</p>    Field Type Description     key string Oberon Public Key as RAW base64 URL encoded string    <p></p>","title":"GetOberonKeyResponse"},{"location":"reference/proto/#invitationstatusrequest","text":"<p>Request details for the status of onboarding an individual or organization. The reference_id passed is the response from the <code>Onboard</code> method call</p>    Field Type Description     invitation_id string ID of invitation    <p></p>","title":"InvitationStatusRequest"},{"location":"reference/proto/#invitationstatusresponse","text":"Field Type Description     status InvitationStatusResponse.Status Status of invitation   status_details string Human-readable string with details about invitation status    <p></p>","title":"InvitationStatusResponse"},{"location":"reference/proto/#invite","text":"Field Type Description     id string    code string    created string    accepted string    expires string     <p></p>","title":"Invite"},{"location":"reference/proto/#inviterequest","text":"Field Type Description     participant ParticipantType Type of participant being invited (individual/organization)   description string Description of invitation   details services.account.v1.AccountDetails Account details of invitee    <p></p>","title":"InviteRequest"},{"location":"reference/proto/#inviterequestdidcomminvitation","text":"<p></p>","title":"InviteRequest.DidCommInvitation"},{"location":"reference/proto/#inviteresponse","text":"Field Type Description     invitation_id string ID of created invitation   invitation_code string Invitation Code that must be passed with the account 'SignIn' request to correlate this user with the invitation sent.    <p></p>","title":"InviteResponse"},{"location":"reference/proto/#updateecosystemrequest","text":"<p>Request to update an ecosystem</p>    Field Type Description     description string Description of the ecosystem   uri string External URL associated with the organization or ecosystem entity    <p></p>","title":"UpdateEcosystemRequest"},{"location":"reference/proto/#updateecosystemresponse","text":"<p>Response to <code>UpdateEcosystemRequest</code></p>    Field Type Description     Ecosystem Ecosystem     <p></p>","title":"UpdateEcosystemResponse"},{"location":"reference/proto/#webhookconfig","text":"Field Type Description     id string UUID of the webhook   destination_url string Destination to post webhook calls to   events string[] Events the webhook is subscribed to   status string Whether we are able to sucessfully send events to the webhook     <p></p>","title":"WebhookConfig"},{"location":"reference/proto/#invitationstatusresponsestatus","text":"Name Number Description     Error 0 Onboarding resulted in error   InvitationSent 1 The participant has been invited   Completed 2 The participant has been onboarded   Expired 3 The invite has expired    <p></p>","title":"InvitationStatusResponse.Status"},{"location":"reference/proto/#participanttype","text":"Name Number Description     participant_type_individual 0    participant_type_organization 1       <p></p> <p>Top</p>","title":"ParticipantType"},{"location":"reference/proto/#servicesoptionsfield-optionsproto","text":"<p></p>","title":"services/options/field-options.proto"},{"location":"reference/proto/#file-level-extensions","text":"Extension Type Base Number Description     optional bool .google.protobuf.FieldOptions 60000 Whether field is optional in Trinsic's backend. This is not the same as an <code>optional</code> protobuf label; it only impacts documentation generation for the field.     <p></p> <p>Top</p>","title":"File-level Extensions"},{"location":"reference/proto/#servicestrust-registryv1trust-registryproto","text":"<p></p>","title":"services/trust-registry/v1/trust-registry.proto"},{"location":"reference/proto/#service-trustregistry","text":"Method Name Request Type Response Type Description     AddFramework AddFrameworkRequest AddFrameworkResponse Adds a trust registry defintion to the ecosystem   RemoveFramework RemoveFrameworkRequest RemoveFrameworkResponse    SearchRegistry SearchRegistryRequest SearchRegistryResponse    RegisterMember RegisterMemberRequest RegisterMemberResponse Registers an authoritative issuer with a credential template   UnregisterMember UnregisterMemberRequest UnregisterMemberResponse Removes an authoritative issuer with a credential template from the trust registry   GetMembershipStatus GetMembershipStatusRequest GetMembershipStatusResponse    FetchData FetchDataRequest FetchDataResponse stream      <p></p>","title":"Service - TrustRegistry"},{"location":"reference/proto/#addframeworkrequest","text":"<p>Register new ecosystem governance framework</p>    Field Type Description     governance_framework_uri string    name string    description string     <p></p>","title":"AddFrameworkRequest"},{"location":"reference/proto/#addframeworkresponse","text":"Field Type Description     id string Unique framework identifier   governing_authority string    trust_registry string     <p></p>","title":"AddFrameworkResponse"},{"location":"reference/proto/#fetchdatarequest","text":"Field Type Description     governance_framework_uri string    query string     <p></p>","title":"FetchDataRequest"},{"location":"reference/proto/#fetchdataresponse","text":"Field Type Description     response_json string    has_more_results bool    continuation_token string     <p></p>","title":"FetchDataResponse"},{"location":"reference/proto/#getmembershipstatusrequest","text":"Field Type Description     governance_framework_uri string    did_uri string    x509_cert string    schema_uri string     <p></p>","title":"GetMembershipStatusRequest"},{"location":"reference/proto/#getmembershipstatusresponse","text":"Field Type Description     status RegistrationStatus     <p></p>","title":"GetMembershipStatusResponse"},{"location":"reference/proto/#governanceframework","text":"Field Type Description     governance_framework_uri string    trust_registry_uri string    description string     <p></p>","title":"GovernanceFramework"},{"location":"reference/proto/#registermemberrequest","text":"Field Type Description     did_uri string    wallet_id string    email string    schema_uri string    valid_from_utc uint64    valid_until_utc uint64    framework_id string the id of the governance framework    <p></p>","title":"RegisterMemberRequest"},{"location":"reference/proto/#registermemberresponse","text":"<p></p>","title":"RegisterMemberResponse"},{"location":"reference/proto/#removeframeworkrequest","text":"Field Type Description     id string     <p></p>","title":"RemoveFrameworkRequest"},{"location":"reference/proto/#removeframeworkresponse","text":"<p></p>","title":"RemoveFrameworkResponse"},{"location":"reference/proto/#searchregistryrequest","text":"Field Type Description     query string SELECT c from c where c.type == 'GovernanceFramework'   continuation_token string     <p></p>","title":"SearchRegistryRequest"},{"location":"reference/proto/#searchregistryresponse","text":"Field Type Description     items_json string    has_more bool    continuation_token string     <p></p>","title":"SearchRegistryResponse"},{"location":"reference/proto/#unregistermemberrequest","text":"Field Type Description     did_uri string    wallet_id string    email string    schema_uri string    framework_id string     <p></p>","title":"UnregisterMemberRequest"},{"location":"reference/proto/#unregistermemberresponse","text":"<p></p>","title":"UnregisterMemberResponse"},{"location":"reference/proto/#registrationstatus","text":"Name Number Description     CURRENT 0 - the entity is currently authorized, as of time of the query.   EXPIRED 1 - entity rights have expired.   TERMINATED 2 - entity has voluntarily ceased Issuer role under the specific EGF.   REVOKED 3 - entity authority under specific EGF was terminated by the governing authority.   NOT_FOUND 10       <p></p> <p>Top</p>","title":"RegistrationStatus"},{"location":"reference/proto/#servicesuniversal-walletv1universal-walletproto","text":"<p></p>","title":"services/universal-wallet/v1/universal-wallet.proto"},{"location":"reference/proto/#service-universalwallet","text":"Method Name Request Type Response Type Description     GetItem GetItemRequest GetItemResponse Retrieve an item from the wallet with a given item identifier   Search SearchRequest SearchResponse Search the wallet using a SQL-like syntax   InsertItem InsertItemRequest InsertItemResponse Insert an item into the wallet   UpdateItem UpdateItemRequest UpdateItemResponse Update an item in the wallet   DeleteItem DeleteItemRequest DeleteItemResponse Delete an item from the wallet permanently     <p></p>","title":"Service - UniversalWallet"},{"location":"reference/proto/#deleteitemrequest","text":"<p>Request to delete an item in a wallet</p>    Field Type Description     item_id string ID of item to delete    <p></p>","title":"DeleteItemRequest"},{"location":"reference/proto/#deleteitemresponse","text":"<p>Response to <code>DeleteItemRequest</code></p> <p></p>","title":"DeleteItemResponse"},{"location":"reference/proto/#getitemrequest","text":"<p>Request to fetch an item from wallet</p>    Field Type Description     item_id string ID of item in wallet    <p></p>","title":"GetItemRequest"},{"location":"reference/proto/#getitemresponse","text":"<p>Response to <code>GetItemRequest</code></p>    Field Type Description     item_json string Item data as a JSON string   item_type string Type of item specified when item was inserted into wallet    <p></p>","title":"GetItemResponse"},{"location":"reference/proto/#insertitemrequest","text":"<p>Request to insert a JSON document into a wallet</p>    Field Type Description     item_json string Document to insert; must be stringified JSON   item_type string Item type (ex. \"VerifiableCredential\")    <p></p>","title":"InsertItemRequest"},{"location":"reference/proto/#insertitemresponse","text":"<p>Response to <code>InsertItemRequest</code></p>    Field Type Description     item_id string ID of item inserted into wallet    <p></p>","title":"InsertItemResponse"},{"location":"reference/proto/#searchrequest","text":"<p>Request to search items in wallet</p>    Field Type Description     query string SQL Query to execute against items in wallet   continuation_token string Token provided by previous <code>SearchResponse</code> if more data is available for query    <p></p>","title":"SearchRequest"},{"location":"reference/proto/#searchresponse","text":"<p>Response to <code>SearchRequest</code></p>    Field Type Description     items string[] Array of query results, as JSON strings   has_more bool Whether more results are available for this query via <code>continuation_token</code>   continuation_token string Token to fetch next set of results via <code>SearchRequest</code>    <p></p>","title":"SearchResponse"},{"location":"reference/proto/#updateitemrequest","text":"<p>Request to update item in wallet</p>    Field Type Description     item_id string ID of item in wallet   item_type string Item type (ex. \"VerifiableCredential\")    <p></p>","title":"UpdateItemRequest"},{"location":"reference/proto/#updateitemresponse","text":"<p>Response to <code>UpdateItemRequest</code></p>    <p></p> <p>Top</p>","title":"UpdateItemResponse"},{"location":"reference/proto/#servicesaccountv1accountproto","text":"<p></p>","title":"services/account/v1/account.proto"},{"location":"reference/proto/#service-account","text":"Method Name Request Type Response Type Description     SignIn SignInRequest SignInResponse Sign in to an already existing account   Login LoginRequest LoginResponse Login to account. If account doesn't exist, new will be created   LoginConfirm LoginConfirmRequest LoginConfirmResponse Confirm login step by responding to the challenge request   Info AccountInfoRequest AccountInfoResponse Get account information   ListDevices ListDevicesRequest ListDevicesResponse List all connected devices   RevokeDevice RevokeDeviceRequest RevokeDeviceResponse Revoke device access to the account's cloud wallet   AuthorizeWebhook AuthorizeWebhookRequest AuthorizeWebhookResponse Authorize Ecosystem to receive webhook events     <p></p>","title":"Service - Account"},{"location":"reference/proto/#accountdetails","text":"<p>Account registration details</p>    Field Type Description     name string Account name   email string Email account   sms string SMS number including country code    <p></p>","title":"AccountDetails"},{"location":"reference/proto/#accountecosystem","text":"Field Type Description     id string    name string    description string    uri string     <p></p>","title":"AccountEcosystem"},{"location":"reference/proto/#accountinforequest","text":"<p>Request for information about the account used to make the request</p> <p></p>","title":"AccountInfoRequest"},{"location":"reference/proto/#accountinforesponse","text":"<p>Information about the account used to make the request</p>    Field Type Description     details AccountDetails The account details associated with the calling request context   ecosystems AccountEcosystem[] Deprecated. Use <code>ecosystem_id</code> instead   wallet_id string The wallet ID associated with this account   device_id string The device ID associated with this account session   ecosystem_id string The ecosystem ID within which this account resides   public_did string The public DID associated with this account. This DID is used as \"issuer\" when signing verifiable credentials   authorized_webhooks string[] Webhook events if any this wallet has authorized    <p></p>","title":"AccountInfoResponse"},{"location":"reference/proto/#accountprofile","text":"<p>Device profile containing sensitive authentication data. This information should be stored securely</p>    Field Type Description     profile_type string The type of profile, used to differentiate between protocol schemes or versions   auth_data bytes Auth data containg information about the current device access   auth_token bytes Secure token issued by server used to generate zero-knowledge proofs   protection TokenProtection Token security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.    <p></p>","title":"AccountProfile"},{"location":"reference/proto/#authorizewebhookrequest","text":"<p>Authorize ecosystem to receive wallet events</p>    Field Type Description     events string[] Events to authorize access to. Default is \"*\" (all events)    <p></p>","title":"AuthorizeWebhookRequest"},{"location":"reference/proto/#authorizewebhookresponse","text":"<p>Response to <code>AuthorizeWebhookRequest</code></p> <p></p>","title":"AuthorizeWebhookResponse"},{"location":"reference/proto/#listdevicesrequest","text":"<p></p>","title":"ListDevicesRequest"},{"location":"reference/proto/#listdevicesresponse","text":"<p></p>","title":"ListDevicesResponse"},{"location":"reference/proto/#loginconfirmrequest","text":"Field Type Description     challenge bytes Login challenge received during the Login call   confirmation_code_hashed bytes Confirmation code received in email or SMS hashed using Blake3    <p></p>","title":"LoginConfirmRequest"},{"location":"reference/proto/#loginconfirmresponse","text":"Field Type Description     profile AccountProfile Profile response. This profile may be protected and require unblinding/unprotection using the raw hashed code    <p></p>","title":"LoginConfirmResponse"},{"location":"reference/proto/#loginrequest","text":"Field Type Description     email string Email account to associate with the login request   invitation_code string Invitation code associated with this registration   ecosystem_id string ID of Ecosystem to sign into. Ignored if <code>invitation_code</code> is passed    <p></p>","title":"LoginRequest"},{"location":"reference/proto/#loginresponse","text":"Field Type Description     challenge bytes Challenge response. Random byte sequence unique for this login request   profile AccountProfile Profile response. The login isn't challenged and the token is returned in this call. Does not require confirmation step    <p></p>","title":"LoginResponse"},{"location":"reference/proto/#revokedevicerequest","text":"<p></p>","title":"RevokeDeviceRequest"},{"location":"reference/proto/#revokedeviceresponse","text":"<p></p>","title":"RevokeDeviceResponse"},{"location":"reference/proto/#signinrequest","text":"<p>Request for creating or signing into an account</p>    Field Type Description     details AccountDetails Account registration details   invitation_code string Invitation code associated with this registration   ecosystem_id string ID of Ecosystem to use Ignored if <code>invitation_code</code> is passed    <p></p>","title":"SignInRequest"},{"location":"reference/proto/#signinresponse","text":"<p>Response for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc.</p>    Field Type Description     confirmation_method ConfirmationMethod Indicates if confirmation of account is required. This settings is configured globally by the server administrator.   profile AccountProfile Contains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data.    <p></p>","title":"SignInResponse"},{"location":"reference/proto/#tokenprotection","text":"<p>Token protection info</p>    Field Type Description     enabled bool Indicates if token is protected using a PIN, security code, HSM secret, etc.   method ConfirmationMethod The method used to protect the token     <p></p>","title":"TokenProtection"},{"location":"reference/proto/#confirmationmethod","text":"<p>Confirmation method type for two-factor workflows</p>    Name Number Description     None 0 No confirmation required   Email 1 Email confirmation required   Sms 2 SMS confirmation required   ConnectedDevice 3 Confirmation from a connected device is required   Other 10 Indicates third-party method of confirmation is required      <p></p> <p>Top</p>","title":"ConfirmationMethod"},{"location":"reference/proto/#servicesverifiable-credentialsv1verifiable-credentialsproto","text":"<p></p>","title":"services/verifiable-credentials/v1/verifiable-credentials.proto"},{"location":"reference/proto/#service-verifiablecredential","text":"Method Name Request Type Response Type Description     Issue IssueRequest IssueResponse Sign and issue a verifiable credential from a submitted document. The document must be a valid JSON-LD document.   IssueFromTemplate IssueFromTemplateRequest IssueFromTemplateResponse Sign and issue a verifiable credential from a pre-defined template. This process will also add schema validation and revocation registry entry in the credential.   CheckStatus CheckStatusRequest CheckStatusResponse Check credential status in the revocation registry   UpdateStatus UpdateStatusRequest UpdateStatusResponse Update credential status by setting the revocation value   CreateProof CreateProofRequest CreateProofResponse Create a proof from a signed document that is a valid verifiable credential and contains a signature from which a proof can be derived.   VerifyProof VerifyProofRequest VerifyProofResponse Verifies a proof by checking the signature value, and if possible schema validation, revocation status, and issuer status against a trust registry   Send SendRequest SendResponse Sends a document directly to a user's email within the given ecosystem     <p></p>","title":"Service - VerifiableCredential"},{"location":"reference/proto/#checkstatusrequest","text":"<p>Request to check a credential's revocation status</p>    Field Type Description     credential_status_id string Credential Status ID to check    <p></p>","title":"CheckStatusRequest"},{"location":"reference/proto/#checkstatusresponse","text":"<p>Response to <code>CheckStatusRequest</code></p>    Field Type Description     revoked bool The credential's revocation status    <p></p>","title":"CheckStatusResponse"},{"location":"reference/proto/#createproofrequest","text":"<p>Request to create a proof for a Verifiable Credential using public key tied to caller. Either <code>item_id</code> or <code>document_json</code> may be provided, not both.</p>    Field Type Description     reveal_document_json string A valid JSON-LD frame describing which fields should be revealed in the generated proof. If unspecified, all fields in the document will be revealed   item_id string ID of wallet item stored in a Trinsic cloud wallet   document_json string A valid JSON-LD Verifiable Credential document string with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet.    <p></p>","title":"CreateProofRequest"},{"location":"reference/proto/#createproofresponse","text":"<p>Response to <code>CreateProofRequest</code></p>    Field Type Description     proof_document_json string Valid JSON-LD proof for the specified credential    <p></p>","title":"CreateProofResponse"},{"location":"reference/proto/#issuefromtemplaterequest","text":"<p>Request to create and sign a JSON-LD Verifiable Credential from a template using public key tied to caller</p>    Field Type Description     template_id string ID of template to use   values_json string JSON document string with keys corresponding to the fields of the template referenced by <code>template_id</code>   framework_id string Governance framework ID to use with issuance of this credential. If specified, the issued credential will contain extended issuer metadata with membership info for the given ecosystem governance framework (EGF)    <p></p>","title":"IssueFromTemplateRequest"},{"location":"reference/proto/#issuefromtemplateresponse","text":"<p>Response to <code>IssueFromTemplateRequest</code></p>    Field Type Description     document_json string Verifiable Credential document, in JSON-LD form, constructed from the specified template and values; signed with public key tied to caller of <code>IssueFromTemplateRequest</code>    <p></p>","title":"IssueFromTemplateResponse"},{"location":"reference/proto/#issuerequest","text":"<p>Request to sign a JSON-LD Credential using public key tied to caller</p>    Field Type Description     document_json string Valid JSON-LD Credential document to be signed, in string form    <p></p>","title":"IssueRequest"},{"location":"reference/proto/#issueresponse","text":"<p>Response to <code>IssueRequest</code></p>    Field Type Description     signed_document_json string Verifiable Credential document, signed with public key tied to caller of <code>IssueRequest</code>    <p></p>","title":"IssueResponse"},{"location":"reference/proto/#sendrequest","text":"<p>Request to send a document to another user's wallet</p>    Field Type Description     email string Email address of user to send item to   did_uri string DID of recipient (presently unsupported)   didcomm_invitation_json string DIDComm out-of-band invitation JSON (presently unsupported)   document_json string JSON document to send to recipient    <p></p>","title":"SendRequest"},{"location":"reference/proto/#sendresponse","text":"<p>Response to <code>SendRequest</code></p> <p></p>","title":"SendResponse"},{"location":"reference/proto/#updatestatusrequest","text":"<p>Request to update a credential's revocation status</p>    Field Type Description     credential_status_id string Credential Status ID to update   revoked bool New revocation status of credential    <p></p>","title":"UpdateStatusRequest"},{"location":"reference/proto/#updatestatusresponse","text":"<p>Response to <code>UpdateStatusRequest</code></p> <p></p>","title":"UpdateStatusResponse"},{"location":"reference/proto/#validationmessage","text":"<p>Result of a validation check on a proof</p>    Field Type Description     is_valid bool Whether or not this validation check passed   messages string[] If validation failed, contains messages explaining why    <p></p>","title":"ValidationMessage"},{"location":"reference/proto/#verifyproofrequest","text":"<p>Request to verify a proof</p>    Field Type Description     proof_document_json string JSON-LD proof document string to verify    <p></p>","title":"VerifyProofRequest"},{"location":"reference/proto/#verifyproofresponse","text":"<p>Response to <code>VerifyProofRequest</code></p>    Field Type Description     is_valid bool Whether or not all validations in <code>validation_results</code> passed   validation_messages string[] Deprecated. Use <code>validation_results</code> instead   validation_results VerifyProofResponse.ValidationResultsEntry[] Results of each validation check performed, such as schema conformance, revocation status, signature, etc. Detailed results are provided for failed validations.    <p></p>","title":"VerifyProofResponse"},{"location":"reference/proto/#verifyproofresponsevalidationresultsentry","text":"Field Type Description     key string    value ValidationMessage        <p></p> <p>Top</p>","title":"VerifyProofResponse.ValidationResultsEntry"},{"location":"reference/proto/#servicesverifiable-credentialstemplatesv1templatesproto","text":"<p></p>","title":"services/verifiable-credentials/templates/v1/templates.proto"},{"location":"reference/proto/#service-credentialtemplates","text":"Method Name Request Type Response Type Description     Create CreateCredentialTemplateRequest CreateCredentialTemplateResponse    Get GetCredentialTemplateRequest GetCredentialTemplateResponse    List ListCredentialTemplatesRequest ListCredentialTemplatesResponse    Search SearchCredentialTemplatesRequest SearchCredentialTemplatesResponse    Delete DeleteCredentialTemplateRequest DeleteCredentialTemplateResponse      <p></p>","title":"Service - CredentialTemplates"},{"location":"reference/proto/#createcredentialtemplaterequest","text":"<p>Request to create a new template</p>    Field Type Description     name string Name of new template   fields CreateCredentialTemplateRequest.FieldsEntry[] Fields which compose the template   allow_additional_fields bool Whether credentials may be issued against this template which have fields not specified in <code>fields</code>    <p></p>","title":"CreateCredentialTemplateRequest"},{"location":"reference/proto/#createcredentialtemplaterequestfieldsentry","text":"Field Type Description     key string    value TemplateField     <p></p>","title":"CreateCredentialTemplateRequest.FieldsEntry"},{"location":"reference/proto/#createcredentialtemplateresponse","text":"<p>Response to <code>CreateCredentialTemplateRequest</code></p>    Field Type Description     data TemplateData Created template    <p></p>","title":"CreateCredentialTemplateResponse"},{"location":"reference/proto/#deletecredentialtemplaterequest","text":"<p>Request to delete a template by ID</p>    Field Type Description     id string ID of template to delete    <p></p>","title":"DeleteCredentialTemplateRequest"},{"location":"reference/proto/#deletecredentialtemplateresponse","text":"<p>Response to <code>DeleteCredentialTemplateRequest</code></p> <p></p>","title":"DeleteCredentialTemplateResponse"},{"location":"reference/proto/#getcredentialtemplaterequest","text":"<p>Request to fetch a template by ID</p>    Field Type Description     id string ID of template to fetch    <p></p>","title":"GetCredentialTemplateRequest"},{"location":"reference/proto/#getcredentialtemplateresponse","text":"<p>Response to <code>GetCredentialTemplateRequest</code></p>    Field Type Description     template TemplateData Template fetched by ID    <p></p>","title":"GetCredentialTemplateResponse"},{"location":"reference/proto/#gettemplaterequest","text":"<p>Unused</p>    Field Type Description     id string     <p></p>","title":"GetTemplateRequest"},{"location":"reference/proto/#gettemplateresponse","text":"<p>Unused</p>    Field Type Description     data TemplateData     <p></p>","title":"GetTemplateResponse"},{"location":"reference/proto/#listcredentialtemplatesrequest","text":"<p>Request to list templates using a SQL query</p>    Field Type Description     query string SQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code>   continuation_token string Token provided by previous <code>ListCredentialTemplatesResponse</code> if more data is available for query    <p></p>","title":"ListCredentialTemplatesRequest"},{"location":"reference/proto/#listcredentialtemplatesresponse","text":"<p>Response to <code>ListCredentialTemplatesRequest</code></p>    Field Type Description     templates TemplateData[] Templates found by query   has_more_results bool Whether more results are available for this query via <code>continuation_token</code>   continuation_token string Token to fetch next set of resuts via <code>ListCredentialTemplatesRequest</code>    <p></p>","title":"ListCredentialTemplatesResponse"},{"location":"reference/proto/#listtemplatesrequest","text":"<p>Unused</p> <p></p>","title":"ListTemplatesRequest"},{"location":"reference/proto/#listtemplatesresponse","text":"<p>Unused</p>    Field Type Description     templates TemplateData[]     <p></p>","title":"ListTemplatesResponse"},{"location":"reference/proto/#searchcredentialtemplatesrequest","text":"<p>Request to search templates using a SQL query</p>    Field Type Description     query string SQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code>   continuation_token string Token provided by previous <code>SearchCredentialTemplatesResponse</code> if more data is available for query    <p></p>","title":"SearchCredentialTemplatesRequest"},{"location":"reference/proto/#searchcredentialtemplatesresponse","text":"<p>Response to <code>SearchCredentialTemplatesRequest</code></p>    Field Type Description     items_json string Raw JSON data returned from query   has_more bool Whether more results are available for this query via <code>continuation_token</code>   continuation_token string Count of items in <code>items_json</code> int32 count = 3; unpopulated and unused Token to fetch next set of results via <code>SearchCredentialTemplatesRequest</code>    <p></p>","title":"SearchCredentialTemplatesResponse"},{"location":"reference/proto/#templatedata","text":"<p>Credential Template</p>    Field Type Description     id string Template ID   name string Template name   version int32 Template version number   fields TemplateData.FieldsEntry[] Fields defined for the template   allow_additional_fields bool Whether credentials issued against this template may contain fields not defined by template   schema_uri string URI pointing to template JSON schema document   context_uri string URI pointing to template JSON-LD context document   ecosystem_id string ID of ecosystem in which template resides   type string Template type (<code>VerifiableCredential</code>)   created_by string ID of template creator    <p></p>","title":"TemplateData"},{"location":"reference/proto/#templatedatafieldsentry","text":"Field Type Description     key string    value TemplateField     <p></p>","title":"TemplateData.FieldsEntry"},{"location":"reference/proto/#templatefield","text":"<p>A field defined in a template</p>    Field Type Description     description string Human-readable description of the field   optional bool Whether this field may be omitted when a credential is issued against the template   type FieldType The type of the field     <p></p>","title":"TemplateField"},{"location":"reference/proto/#fieldtype","text":"<p>Valid types for credential fields</p>    Name Number Description     STRING 0    NUMBER 1    BOOL 2    DATETIME 4       <p></p> <p>Top</p>","title":"FieldType"},{"location":"reference/proto/#servicesdebugv1debugproto","text":"<p></p>","title":"services/debug/v1/debug.proto"},{"location":"reference/proto/#service-debugging","text":"Method Name Request Type Response Type Description     CallEmpty .google.protobuf.Empty .google.protobuf.Empty    CallEmptyAuth .google.protobuf.Empty .google.protobuf.Empty","title":"Service - Debugging"},{"location":"reference/proto/#scalar-value-types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby      double  double double float float64 double float Float    float  float float float float32 float float Float    int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)    int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum    uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)    uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)    sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)    sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum    fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)    fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum    sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)    sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum    bool  bool boolean boolean bool bool boolean TrueClass/FalseClass    string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)    bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Scalar Value Types"},{"location":"reference/services/account-service/","text":"<p>The Account Service allows you to create and sign in to accounts.</p>  <p>Wallets vs Accounts</p> <p>Wallets and accounts are related and often interchangeable -- each account has an associated wallet, and operations on a wallet are performed using an account's access token.</p> <p>Every account has exactly one wallet. </p>   <p>Authentication Tokens</p> <p>When you create or sign in to an account, the response is an authentication token string.</p> <p>This string is an encoded form of your account profile, as well as an access key to perform calls using the account.</p> <p>These are effectively API keys; they should be kept safe and never published.</p>","title":"Account Service"},{"location":"reference/services/account-service/#sign-in","text":"<p>Sign in to an existing account, or create a new one.</p> <p>If no account details are passed to this method, an anonymous account will be created.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic account login --email &lt;PROFILE_EMAIL&gt; --name &lt;PROFILE_NAME&gt;\n</code></pre>   <pre><code>const allison = (await accountService.signIn()).getProfile();\n</code></pre>   <pre><code>var myProfile = await myAccountService.SignInAsync(new());\n</code></pre>   <pre><code>my_profile = await account_service.sign_in()\n</code></pre>   <pre><code>profile, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var myProfile = accountService.signIn().get();\n</code></pre>   <pre><code>allison = account_service.sign_in(nil).profile\n</code></pre>      <p>SignInRequestRequest for creating or signing into an accountdetails AccountDetailsAccount registration detailsShow child attributesdetails.name optional stringAccount namedetails.email stringEmail accountdetails.sms optional stringSMS number including country codeinvitation_code optional stringInvitation code associated with this registrationecosystem_id optional stringID of Ecosystem to use Ignored if <code>invitation_code</code> is passed</p>   <p>SignInResponseResponse for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc.confirmation_method ConfirmationMethodIndicates if confirmation of account is required. This settings is configured globally by the server administrator.Show enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Indicates third-party method of confirmation is requiredprofile AccountProfileContains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data.Show child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Indicates third-party method of confirmation is required</p>    <p>This operation, if successful, returns an authentication token string.</p>  <p>Protected Authentication Tokens</p> <p>If you are attempting to login to a non-anonymous account (by specifying an email address or phone number), the authentication token returned will be protected, and cannot be used until it has been unprotected.</p> <p>Trinsic will have sent a security code to the account's email address or phone number; this security code must be used with the Unprotect call to receive a usable authentication token.</p> <p>In the future, we will provide an SDK call to determine if an authentication token is protected.</p>","title":"Sign In"},{"location":"reference/services/account-service/#get-account-info","text":"<p>Returns the account information (name, email address, phone number, etc.) used to create the currently-active account profile.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic account info\n</code></pre>   <pre><code>const info = await accountService.info();\n</code></pre>   <pre><code>var output = await myAccountService.GetInfoAsync();\n</code></pre>   <pre><code>info = await account_service.get_info()\n</code></pre>   <pre><code>info2, err2 := accountService.GetInfo(context.Background())\n</code></pre>   <pre><code>var info = accountService.getInfo().get();\n</code></pre>   <pre><code>info = account_service.get_info()\n</code></pre>      <p>AccountInfoRequestRequest for information about the account used to make the requestThis message has no fields</p>   <p>AccountInfoResponseInformation about the account used to make the requestdetails AccountDetailsThe account details associated with the calling request contextShow child attributesdetails.name optional stringAccount namedetails.email stringEmail accountdetails.sms optional stringSMS number including country codeecosystems AccountEcosystem[]Use <code>ecosystem_id</code> insteadShow child attributesecosystems.id stringecosystems.name stringecosystems.description stringecosystems.uri stringwallet_id stringThe wallet ID associated with this accountdevice_id stringThe device ID associated with this account sessionecosystem_id stringThe ecosystem ID within which this account residespublic_did stringThe public DID associated with this account. This DID is used as \"issuer\" when signing verifiable credentialsauthorized_webhooks string[]Webhook events if any this wallet has authorized</p>     <p>Note</p> <p>This call returns the information associated with the authentication token used to create the request; therefore, it is not possible to pass a different authentication token to this call. Otherwise, Trinsic's zero-knowledge proof authentication scheme would be violated.</p> <p>When using the CLI, this will return information for the account most recently logged in to.</p> <p>When using the SDK, this will return information for the authentication token stored in the <code>AccountService</code> instance's <code>ServiceOptions.AuthToken</code> field, which will be the account most recently logged in to, unless you have manually set this value yourself.</p>","title":"Get Account Info"},{"location":"reference/services/account-service/#protect-account-profile","text":"<p>Protects the specified account profile with a security code. It is not possible to execute this call using the CLI.</p> TypeScriptC#PythonGoJavaRuby   <pre><code>const protectedProfile = await accountService.protect(accountProfile, \"1234\");\n</code></pre>   <pre><code>var securityCode = \"1234\";\nvar myProtectedProfile = AccountService.Protect(myProfile, securityCode);\nvar myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n</code></pre>   <pre><code>code = b\"1234\"\nmy_protected_profile = account_service.protect(\n    profile=my_profile, security_code=code\n)\nmy_unprotected_profile = account_service.unprotect(\n    profile=my_protected_profile, security_code=code\n)\n</code></pre>   <pre><code>securityCode := \"1234\"\nprotectedProfile, err := accountService.Protect(profile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\nunprotectedProfile, err := accountService.Unprotect(protectedProfile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var code = \"1234\";\nvar myProtectedProfile = AccountService.protect(myProfile, code);\nvar myUnprotectedProfile = AccountService.unprotect(myProtectedProfile, code);\n</code></pre>   <pre><code>protected_profile = account_service.protect(account_profile, '1234')\n</code></pre>     <p>Info</p> <p>In this context, \"protection\" refers to a cryptographic operation on the authorization token for an account.</p> <p>Protecting an account profile with code <code>c</code> returns a new access token which is unusable until it is unprotected with the same code <code>c</code>. It is not possible to reverse the protection process without the original protection code.</p> <p>You will receive a protected account profile from Trinsic if you attempt to sign in to an account via email, SMS, or any other method which requires authentication. Trinsic will send a security code to the email or phone number associated with the account, which can be used to unprotect the account profile.</p> <p>Specifically, Trinsic is using Oberon to handle access tokens; protection and unprotection is handled using the blinding/unblinding features of Oberon.</p>","title":"Protect Account Profile"},{"location":"reference/services/account-service/#unprotect-account-profile","text":"<p>Unprotects the specified account profile using the given code. It is not possible to execute this call using the CLI.</p> <p>The profile must have been previously protected using the same code that is being used to unprotect it. Profiles can be protected using any arbitrary code via the Protect method.</p> <p>Most commonly, this method is used on a protected profile received from the Sign In method. The code to unprotect it will have been sent to the account owner via email or SMS.</p> TypeScriptC#PythonGoJavaRuby   <pre><code>const accountProfile = await accountService.unprotect(protectedProfile, \"1234\");\n</code></pre>   <pre><code>var securityCode = \"1234\";\nvar myProtectedProfile = AccountService.Protect(myProfile, securityCode);\nvar myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n</code></pre>   <pre><code>code = b\"1234\"\nmy_protected_profile = account_service.protect(\n    profile=my_profile, security_code=code\n)\nmy_unprotected_profile = account_service.unprotect(\n    profile=my_protected_profile, security_code=code\n)\n</code></pre>   <pre><code>securityCode := \"1234\"\nprotectedProfile, err := accountService.Protect(profile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\nunprotectedProfile, err := accountService.Unprotect(protectedProfile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var code = \"1234\";\nvar myProtectedProfile = AccountService.protect(myProfile, code);\nvar myUnprotectedProfile = AccountService.unprotect(myProtectedProfile, code);\n</code></pre>   <pre><code>account_profile = account_service.unprotect(protected_profile, '1234')\n</code></pre>","title":"Unprotect Account Profile"},{"location":"reference/services/credential-service/","text":"<p>The Credential Service exposes functionality for issuance, proof generation, verification, and revocation of Verifiable Credentials.</p>  <p>Signature Format</p> <p>The Credential service currently supports BBS+ Signatures , which enable selective disclosure of credential fields during proof generation.</p> <p>Credentials are signed, and proofs are created, using a key pair unique to the signing / holding wallet. This key pair is created and managed by Trinsic upon account creation.</p>","title":"Credential Service"},{"location":"reference/services/credential-service/#issue-credential","text":"<p>Issues a credential from a valid JSON-LD document. Issued credentials are not automatically stored in any wallet.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic vc issue --document &lt;JSONLD_FILE&gt; --out &lt;OUTPUT_FILE&gt;\n</code></pre>   <pre><code>const issueResponse = await credentialService.issueCredential(\n  IssueRequest.fromPartial({ documentJson: credentialJSON })\n);\n</code></pre>   <pre><code>var credential = await credentialsService.IssueCredentialAsync(new() {DocumentJson = credentialJson});\n_testOutputHelper.WriteLine($\"Credential:\\n{credential.SignedDocumentJson}\");\n</code></pre>   <pre><code>issue_response = await credentials_service.issue_credential(\n    request=IssueRequest(document_json=credential_json)\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/trinsic-id/sdk/go/proto/sdk/options/v1/options\"\n    \"github.com/trinsic-id/sdk/go/proto/services/account/v1/account\"\n    \"github.com/trinsic-id/sdk/go/proto/services/provider/v1/provider\"\n    \"github.com/trinsic-id/sdk/go/proto/services/trustregistry/v1/trustregistry\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var issueResult =\n    credentialService\n        .issueCredential(\n            VerifiableCredentials.IssueRequest.newBuilder()\n                .setDocumentJson(unsignedCredential)\n                .build())\n        .get();\n\nvar signedCredentialJson = issueResult.getSignedDocumentJson();\n</code></pre>      <p>IssueRequestRequest to sign a JSON-LD Credential using public key tied to callerdocument_json stringValid JSON-LD Credential document to be signed, in string form</p>   <p>IssueResponseResponse to <code>IssueRequest</code>signed_document_json stringVerifiable Credential document, signed with public key tied to caller of <code>IssueRequest</code></p>     <p>Warning</p> <p><code>IssueCredential</code> requires a valid JSON-LD document to be provided. Do not confuse this operation with Issue Credential From Template.</p> <p>When provided a valid credential, this endpoint creates and appends the <code>proof</code> object, using a key pair tied to the issuing Trinsic account.</p> <p>You can learn more about how to create these documents, and about VC data models in general, from W3C: VC Data Model v1.1. </p>","title":"Issue Credential"},{"location":"reference/services/credential-service/#issue-credential-from-template","text":"<p>Issues a credential from a previously-defined template.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic vc issue-from-template [OPTIONS] --template-id &lt;ID&gt;\n\n# OPTIONS\n# --out &lt;OUTPUT_FILE&gt;     (Optional) Output file to store the issued credential\n# --values-data &lt;JSON&gt;    The JSON values of the credential subject\n# --values-file &lt;FILE&gt;    The file with JSON values of the credential subject\n</code></pre>   <pre><code>let request = IssueFromTemplateRequest.fromPartial({\n  templateId: templateResponse?.data?.id ?? \"\",\n  valuesJson: JSON.stringify({\n    name: \"Alice\",\n    numberOfBags: 2,\n    dateOfBirth: new Date(\"1/1/2000\").toISOString(),\n    vaccinated: true,\n  }),\n});\n\nlet response = await service.issueFromTemplate(request);\n</code></pre>   <pre><code>var credentialJson = await credentialService.IssueFromTemplateAsync(new() {\n    TemplateId = template.Data.Id,\n    ValuesJson = values\n});\n</code></pre>   <pre><code>values = json.dumps({\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"age\": \"42\"})\nissue_response = await credential_service.issue_from_template(\n    request=IssueFromTemplateRequest(\n        template_id=template.data.id, values_json=values\n    )\n)\n</code></pre>   <pre><code>credentialJSON, err := credentialService.IssueFromTemplate(context.Background(), &amp;credential.IssueFromTemplateRequest{\n    TemplateId: templateResponse.Data.Id,\n    ValuesJson: string(valuesString),\n})\n</code></pre>   <pre><code>var valuesMap = new HashMap&lt;String, Object&gt;();\nvaluesMap.put(\"firstName\", \"Jane\");\nvaluesMap.put(\"lastName\", \"Doe\");\nvaluesMap.put(\"age\", 42);\nvar valuesJson = new Gson().toJson(valuesMap);\nvar issueResponse =\n    credentialService\n        .issueCredentialFromTemplate(\n            VerifiableCredentials.IssueFromTemplateRequest.newBuilder()\n                .setTemplateId(template.getData().getId())\n                .setValuesJson(valuesJson)\n                .build())\n        .get();\n</code></pre>      <p>IssueFromTemplateRequestRequest to create and sign a JSON-LD Verifiable Credential from a template using public key tied to callertemplate_id stringID of template to usevalues_json stringJSON document string with keys corresponding to the fields of the template referenced by <code>template_id</code>framework_id optional stringGovernance framework ID to use with issuance of this credential. If specified, the issued credential will contain extended issuer metadata with membership info for the given ecosystem governance framework (EGF)</p>   <p>IssueFromTemplateResponseResponse to <code>IssueFromTemplateRequest</code>document_json stringVerifiable Credential document, in JSON-LD form, constructed from the specified template and values; signed with public key tied to caller of <code>IssueFromTemplateRequest</code></p>","title":"Issue Credential from Template"},{"location":"reference/services/credential-service/#check-revocation-status","text":"<p>Checks a credential's revocation status by its <code>credential_status_id</code>.</p> <p>A <code>credential_status_id</code> can be found in a credential's <code>credentialStatus.id</code> field, if present.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic vc get-status --credential-status-id &lt;ID&gt;\n</code></pre>   <pre><code>var checkResponse = await credentialService.CheckStatusAsync(new() {CredentialStatusId = \"\"});\n</code></pre>   <pre><code>#     check_response = await credential_service.check_status(\n#         request=CheckStatusRequest(credential_status_id=\"\")\n#     )\n</code></pre>   <pre><code>status, err := credentialService.CheckStatus(context.Background(), &amp;credential.CheckStatusRequest{CredentialStatusId: \"\"})\n</code></pre>   <pre><code>var checkStatusResponse =\n    credentialService\n        .checkStatus(VerifiableCredentials.CheckStatusRequest.newBuilder().build())\n        .get();\n</code></pre>      <p>CheckStatusRequestRequest to check a credential's revocation statuscredential_status_id stringCredential Status ID to check</p>   <p>CheckStatusResponseResponse to <code>CheckStatusRequest</code>revoked boolThe credential's revocation status</p>","title":"Check Revocation Status"},{"location":"reference/services/credential-service/#update-revocation-status","text":"<p>Updates the revocation status of a credential (revoke or unrevoke).</p> <p>A <code>credential_status_id</code> can be found in a credential's <code>credentialStatus.id</code> field, if present.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code># Revoke a credential\ntrinsic vc update-status --revoked --credential-status-id &lt;ID&gt;\n\n# Unrevoke a credential\ntrinsic vc update-status --unrevoked --credential-status-id &lt;ID&gt;\n</code></pre>   <pre><code>await credentialService.UpdateStatusAsync(new() {CredentialStatusId = \"\", Revoked = true});\n</code></pre>   <pre><code>#     update_response = await credential_service.update_status(\n#         request=UpdateStatusRequest(credential_status_id=\"\", revoked=True)\n#     )\n</code></pre>   <pre><code>updateResponse, err := credentialService.UpdateStatus(context.Background(), &amp;credential.UpdateStatusRequest{CredentialStatusId: \"\", Revoked: true})\n</code></pre>   <pre><code>credentialService.updateStatus(\n    VerifiableCredentials.UpdateStatusRequest.newBuilder().build());\n</code></pre>      <p>UpdateStatusRequestRequest to update a credential's revocation statuscredential_status_id stringCredential Status ID to updaterevoked boolNew revocation status of credential</p>   <p>UpdateStatusResponseResponse to <code>UpdateStatusRequest</code>This message has no fields</p>","title":"Update Revocation Status"},{"location":"reference/services/credential-service/#create-proof","text":"<p>Creates and signs a proof for a valid JSON-LD credential, using the BBS+ Signature Suite.</p> <p>If the credential is stored in a Trinsic cloud wallet, pass its <code>item_id</code>; otherwise, pass the raw JSON-LD credential via <code>document_json</code>.</p> <p>If <code>reveal_document_json</code> is passed, a proof will be generated for only the fields specified.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic vc create-proof --document-id &lt;STRING&gt; --out &lt;OUTPUT_FILE&gt; --reveal-document &lt;JSONLD_FRAME_FILE&gt;\n</code></pre>   <pre><code>let proof = await credentialService.createProof(\n  CreateProofRequest.fromPartial({\n    itemId: insertItemResponse.itemId,\n    revealDocumentJson: getVaccineCertFrameJSON(),\n  })\n);\n</code></pre>   <pre><code>var proof = await credentialService.CreateProofAsync(new() {\n    DocumentJson = credentialJson.DocumentJson,\n    RevealDocumentJson = frame.ToString(Formatting.None)\n});\n</code></pre>   <pre><code>proof_response = await credentials_service.create_proof(\n    request=CreateProofRequest(\n        reveal_document_json=proof_request_json, document_json=credential_json\n    )\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/trinsic-id/sdk/go/proto/sdk/options/v1/options\"\n    \"github.com/trinsic-id/sdk/go/proto/services/account/v1/account\"\n    \"github.com/trinsic-id/sdk/go/proto/services/provider/v1/provider\"\n    \"github.com/trinsic-id/sdk/go/proto/services/trustregistry/v1/trustregistry\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var createProofResponse =\n    credentialService\n        .createProof(\n            VerifiableCredentials.CreateProofRequest.newBuilder()\n                .setDocumentJson(signedCredentialJson)\n                .setRevealDocumentJson(proofRequestJson)\n                .build())\n        .get();\n\nvar credentialProof = createProofResponse.getProofDocumentJson();\n</code></pre>      <p>CreateProofRequestRequest to create a proof for a Verifiable Credential using public key tied to caller. Either <code>item_id</code> or <code>document_json</code> may be provided, not both.reveal_document_json stringA valid JSON-LD frame describing which fields should be revealed in the generated proof.  If unspecified, all fields in the document will be revealeditem_id stringID of wallet item stored in a Trinsic cloud walletdocument_json stringA valid JSON-LD Verifiable Credential document string  with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet.</p>   <p>CreateProofResponseResponse to <code>CreateProofRequest</code>proof_document_json stringValid JSON-LD proof for the specified credential</p>     <p>Selective Disclosure</p> <p>BBS+ Signatures support the ability to generate a proof for a subset of a credential's fields, instead of every field.</p> <p>This enables increased user privacy: fields which aren't included in <code>reveal_document_json</code> will not be present in the generated proof.</p> <p>We are working on documentation for the expected structure of <code>reveal_document_json</code> and will make it available soon.</p>","title":"Create Proof"},{"location":"reference/services/credential-service/#verify-proof","text":"<p>Verifies a proof for validity and authenticity. Only supports BBS+ Signatures at present.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code># The JSONLD_FILE refers to the proof document obtained from a CreateProofResponse\ntrinsic vc issuer verify-proof --proof-document &lt;JSONLD_FILE&gt;\n</code></pre>   <pre><code>let verifyResponse = await credentialService.verifyProof({\n  proofDocumentJson: proof.proofDocumentJson,\n});\n</code></pre>   <pre><code>var valid = await credentialService.VerifyProofAsync(new() {ProofDocumentJson = proof.ProofDocumentJson});\n</code></pre>   <pre><code>import asyncio\nimport json\n\nfrom trinsic.account_service import AccountService\nfrom trinsic.credential_service import CredentialService\nfrom trinsic.template_service import TemplateService\nfrom trinsic.proto.services.universalwallet.v1 import InsertItemRequest\nfrom trinsic.proto.services.verifiablecredentials.templates.v1 import (\n    CreateCredentialTemplateRequest,\n    TemplateData,\n    TemplateField,\n    FieldType,\n)\nfrom trinsic.proto.services.verifiablecredentials.v1 import (\n    IssueFromTemplateRequest,\n    CreateProofRequest,\n    VerifyProofRequest,\n    SendRequest,\n)\nfrom trinsic.provider_service import ProviderService\nfrom trinsic.trinsic_util import trinsic_config\nfrom trinsic.wallet_service import WalletService\n\n\nasync def vaccine_demo():\n    config = trinsic_config()\n\n    account_service = AccountService(server_config=config)\n    provider_service = ProviderService(server_config=config)\n\n    # createEcosystem() {\n    ecosystem = await provider_service.create_ecosystem()\n    ecosystem_id = ecosystem.ecosystem.id\n    # }\n\n    # Set service default ecosystem\n    provider_service.service_options.default_ecosystem = (\n        account_service.service_options.default_ecosystem\n    ) = ecosystem_id\n    config.default_ecosystem = ecosystem_id\n\n    wallet_service = WalletService(server_config=config)\n    credential_service = CredentialService(server_config=config)\n    template_service = TemplateService(server_config=config)\n\n    # setupActors() {\n    # Create an account for each participant in the scenario\n    allison = await account_service.sign_in()\n    airline = await account_service.sign_in()\n    clinic = await account_service.sign_in()\n    # }\n\n    account_service.service_options.auth_token = clinic\n    info = await account_service.get_info()\n    print(f\"Account info={info}\")\n\n    # Create a template\n    template_service.service_options.auth_token = clinic\n    template = await do_template(template_service)\n\n    # Create template values\n\n    # issueCredential() {\n    # Prepare values for credential\n    values = json.dumps(\n        {\n            \"firstName\": \"Allison\",\n            \"lastName\": \"Allisonne\",\n            \"batchNumber\": \"123454321\",\n            \"countryOfVaccination\": \"US\",\n        }\n    )\n\n    # Issue credential\n    issue_response = await credential_service.issue_from_template(\n        request=IssueFromTemplateRequest(template_id=template.id, values_json=values)\n    )\n\n    credential = issue_response.document_json\n    # }\n\n    print(f\"Credential: {credential}\")\n\n    try:\n        # sendCredential() {\n        send_response = await credential_service.send(\n            request=SendRequest(document_json=credential, email=\"example@trinsic.id\")\n        )\n        # }\n    except:\n        pass\n\n    # storeCredential() {\n    # Allison stores the credential in her cloud wallet\n    wallet_service.service_options.auth_token = allison\n\n    insert_response = await wallet_service.insert_item(\n        request=InsertItemRequest(item_json=credential)\n    )\n\n    item_id = insert_response.item_id\n    # }\n    print(f\"item id = {item_id}\")\n\n    # shareCredential() {\n    # Allison shares the credential with the airline\n    credential_service.service_options.auth_token = allison\n\n    proof_response = await credential_service.create_proof(\n        request=CreateProofRequest(item_id=item_id)\n    )\n\n    credential_proof = proof_response.proof_document_json\n    # }\n\n    print(f\"Proof: {credential_proof}\")\n\n    # verifyCredential() {\n    # The airline verifies the credential\n    credential_service.service_options.auth_token = airline\n\n    verify_result = await credential_service.verify_proof(\n        request=VerifyProofRequest(proof_document_json=credential_proof)\n    )\n\n    valid = verify_result.is_valid\n    # }\n\n    print(f\"Verification result: {valid}\")\n    assert valid is True\n\n    # revokeCredential() {\n    # update_status_response = await credential_service.update_status(credential_status_id=status_id, revoked=True)\n    # print(f\"UpdateStatusResponse: {update_status_response}\")\n    # credential_status = await credential_service.check_status(credential_status_id=status_id)\n    # print(f\"Credential_status: {credential_status}\")\n    # assert credential_status.revoked is True\n    # }\n    credential_service.close()\n    wallet_service.close()\n    account_service.close()\n    provider_service.close()\n\n\nasync def do_template(template_service: TemplateService) -&gt; TemplateData:\n    # createTemplate() {\n    template = await template_service.create(\n        request=CreateCredentialTemplateRequest(\n            name=\"VaccinationCertificate\",\n            allow_additional_fields=False,\n            fields={\n                \"firstName\": TemplateField(\n                    description=\"First name of vaccine recipient\"\n                ),\n                \"lastName\": TemplateField(description=\"Last name of vaccine recipient\"),\n                \"batchNumber\": TemplateField(\n                    description=\"Batch number of vaccine\", type=FieldType.STRING\n                ),\n                \"countryOfVaccination\": TemplateField(\n                    description=\"Country in which the subject was vaccinated\"\n                ),\n            },\n        )\n    )\n\n    template_id = template.data.id\n    # }\n\n    assert template_id is not None\n    assert template.data.schema_uri is not None\n\n    return template.data\n\n\nif __name__ == \"__main__\":\n    asyncio.run(vaccine_demo())\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/trinsic-id/sdk/go/proto/sdk/options/v1/options\"\n    \"github.com/trinsic-id/sdk/go/proto/services/account/v1/account\"\n    \"github.com/trinsic-id/sdk/go/proto/services/provider/v1/provider\"\n    \"github.com/trinsic-id/sdk/go/proto/services/trustregistry/v1/trustregistry\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var verifyProofResponse =\n    credentialService\n        .verifyProof(\n            VerifiableCredentials.VerifyProofRequest.newBuilder()\n                .setProofDocumentJson(credentialProof)\n                .build())\n        .get();\n\nboolean isValid = verifyProofResponse.getIsValid();\n</code></pre>       <p>VerifyProofRequestRequest to verify a proofproof_document_json stringJSON-LD proof document string to verify</p>   <p>VerifyProofResponseResponse to <code>VerifyProofRequest</code>is_valid boolWhether or not all validations in <code>validation_results</code> passedvalidation_messages string[]Use <code>validation_results</code> insteadvalidation_results ValidationResultsEntry[]Results of each validation check performed,  such as schema conformance, revocation status, signature, etc. Detailed results are provided for failed validations.Show child attributesvalidation_results.key stringvalidation_results.value ValidationMessageShow child attributesvalidation_results.value.is_valid boolWhether or not this validation check passedvalidation_results.value.messages string[]If validation failed, contains messages explaining why</p>     Validation Results <p>The verification process performs a number of validations, each of which may fail independently of the others.</p> <p>For example, a credential may be expired or revoked, but otherwise perfectly valid.</p> <p><code>validation_results</code> contains an entry for each of the following verification steps:</p>    Name Description     <code>SignatureVerification</code> Cryptographic signature validity of proof   <code>CredentialStatus</code> (if supported by credential) Checks if credential has been revoked*   <code>SchemaConformance</code> Ensures credential conforms with its schema   <code>TrustRegistryMembership</code> (if relevant) Verifies that credential issuer is an authorized member of the credential's governing Trust Registry","title":"Verify Proof"},{"location":"reference/services/credential-service/#exchange-credentials","text":"","title":"Exchange Credentials"},{"location":"reference/services/credential-service/#send-via-email","text":"<p>Sends a credential to a user via email.</p> <p>The specified email address must be tied to an existing account in the same ecosystem.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic vc send --email &lt;EMAIL_ADDRESS&gt; --item &lt;FILE&gt;\n</code></pre>   <pre><code>await credentialService.send(document, \"admin@example.com\");\n</code></pre>   <pre><code>await credentialsService.SendAsync(new() {Email = \"example@trinsic.id\"});\n</code></pre>   <pre><code>send_response = await credentials_service.send(\n    request=SendRequest(\n        document_json=credential_json, email=\"example@trinsic.id\"\n    )\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/trinsic-id/sdk/go/proto/sdk/options/v1/options\"\n    \"github.com/trinsic-id/sdk/go/proto/services/account/v1/account\"\n    \"github.com/trinsic-id/sdk/go/proto/services/provider/v1/provider\"\n    \"github.com/trinsic-id/sdk/go/proto/services/trustregistry/v1/trustregistry\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>credentialService.send(\n    VerifiableCredentials.SendRequest.newBuilder()\n        .setDocumentJson(signedCredentialJson)\n        .setEmail(recipientEmail)\n        .build());\n</code></pre>      <p>SendRequestRequest to send a document to another user's walletemail stringEmail address of user to send item todid_uri stringDID of recipient (presently unsupported)didcomm_invitation_json stringDIDComm out-of-band invitation JSON (presently unsupported)document_json stringJSON document to send to recipient</p>   <p>SendResponseResponse to <code>SendRequest</code>This message has no fields</p>     <p>Alternative Exchange Protocols</p> <p>During this beta period, credentials may only be sent to a wallet via email address or with the InsertItem call.</p> <p>There are a number of ongoing industry efforts to standardize exchange protocols, such as:</p> <ul> <li>DIDComm Messaging </li> <li>Wallet And Credential Interactions </li> <li>OpenID Connect Credential Provider </li> </ul> <p>We aim to provide support for these methods as they mature.</p>","title":"Send via Email"},{"location":"reference/services/provider-service/","text":"<p>The Provider Service enables the creation and management of ecosystems and webhooks.</p>  <p>Named / Production Ecosystems</p> <p>During the beta period, anyone may create an ecosystem with any name. As we move toward general availability of the platform, we will restrict the creation of named / production ecosystems.</p> <p>Once this shift occurs, named ecosystems (suitable for production) will be created for you by Trinsic as part of your onboarding process.</p> <p>Ecosystems with auto-generated names may be created by anyone for testing purposes, but these may not be used in production -- doing so is an unauthorized use of Trinsic's platform.</p>","title":"Provider Service"},{"location":"reference/services/provider-service/#create-ecosystem","text":"<p>Creates a new ecosystem, along with a root controlling account.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic provider create-ecosystem --name &lt;ECOSYSTEM_NAME&gt; --email &lt;OWNER_EMAIL&gt;\n</code></pre>   <pre><code>let actualCreate = await providerService.createEcosystem(\n  CreateEcosystemRequest.fromPartial({\n    description: \"Test ecosystem from Node\",\n    uri: \"https://example.com\",\n  })\n);\n</code></pre>   <pre><code>var (actualCreate, _) = await service.CreateEcosystemAsync(new() {\n    Description = \"My ecosystem\",\n    Uri = \"https://example.com\"\n});\n</code></pre>   <pre><code>actual_create = await provider_service.create_ecosystem(\n    request=CreateEcosystemRequest(\n        description=\"My ecosystem\", uri=\"https://example.com\"\n    )\n)\n</code></pre>   <pre><code>actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n    Description: \"My ecosystem\",\n    Uri:         \"https://example.com\",\n})\n</code></pre>   <pre><code>var response =\n    service\n        .createEcosystem(\n            ProviderOuterClass.CreateEcosystemRequest.newBuilder()\n                .setDescription(\"My ecosystem\")\n                .setUri(\"https://example.com\")\n                .build())\n        .get();\n</code></pre>      <p>CreateEcosystemRequestname stringGlobally unique name for the Ecosystem. This name will be part of the ecosystem specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen.description optional stringEcosystem descriptionuri optional stringExternal URL associated with your organization or ecosystem entitydetails AccountDetailsThe account details of the owner of the ecosystemShow child attributesdetails.name optional stringAccount namedetails.email stringEmail accountdetails.sms optional stringSMS number including country code</p>   <p>CreateEcosystemResponseecosystem EcosystemDetails of the created ecosystemShow child attributesecosystem.id stringURN of the ecosystemecosystem.name stringGlobally unique name for the ecosystemecosystem.description stringEcosystem descriptionecosystem.uri stringExternal URL associated with the organization or ecosystem entityecosystem.webhooks WebhookConfig[]Configured webhooks, if anyShow child attributesecosystem.webhooks.id stringUUID of the webhookecosystem.webhooks.destination_url stringDestination to post webhook calls toecosystem.webhooks.events string[]Events the webhook is subscribed toecosystem.webhooks.status stringWhether we are able to sucessfully send events to the webhookprofile AccountProfileAccount profile for auth of the owner of the ecosystemShow child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Indicates third-party method of confirmation is requiredconfirmation_method ConfirmationMethodIndicates if confirmation of account is required. This setting is configured globally by the server administrator.Show enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Indicates third-party method of confirmation is required</p>","title":"Create Ecosystem"},{"location":"reference/services/template-service/","text":"<p>The Template Service allows you to manage and search Credential Templates.</p>  <p>Templates are optional</p> <p>Templates are designed to be a helpful abstraction over the complexities of producing valid JSON-LD Verifiable Credentials.</p> <p>You aren't required to use templates; if you produce valid JSON-LD VCs yourself, they can be issued through Trinsic.</p>","title":"Template Service"},{"location":"reference/services/template-service/#create-template","text":"<p>Creates a new credential template.</p> <p>In the background, Trinsic will also generate and save a valid JSON-LD Context and schema for your template.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic template create --name 'My Credential' --fields-data '{\\\"field1\\\":{}}'\n</code></pre>   <pre><code>const credentialTemplateName = `My First Credential Template-${uuid()}`;\nconst nameField = TemplateField.fromPartial({\n  description: \"The name of the person\",\n  type: FieldType.STRING,\n  optional: false,\n});\n\nconst numberOfBags = TemplateField.fromPartial({\n  type: FieldType.NUMBER,\n  description: \"The number of bags the person is taking on the trip\",\n  optional: false,\n});\n\nconst dateOfBirth = TemplateField.fromPartial({\n  type: FieldType.DATETIME,\n  description: \"The date of birth of the person\",\n  optional: false,\n});\n\nconst isVaccinated = TemplateField.fromPartial({\n  type: FieldType.BOOL,\n  description: \"Whether or not the person has been vaccinated\",\n  optional: false,\n});\n</code></pre>   <pre><code>CreateCredentialTemplateRequest templateRequest = new() {\n    Name = \"An Example Credential\",\n    AllowAdditionalFields = false\n};\ntemplateRequest.Fields.Add(\"firstName\", new() {Description = \"Given name\"});\ntemplateRequest.Fields.Add(\"lastName\", new());\ntemplateRequest.Fields.Add(\"age\", new() {Optional = true}); // TODO - use FieldType.NUMBER once schema validation is fixed.\n\nvar template = await templateService.CreateAsync(templateRequest);\n</code></pre>   <pre><code>template = await template_service.create(\n    request=CreateCredentialTemplateRequest(\n        name=f\"An Example Credential: {uuid.uuid4()}\",\n        allow_additional_fields=False,\n        fields={\n            \"firstName\": TemplateField(description=\"Given name\"),\n            \"lastName\": TemplateField(),\n            \"age\": TemplateField(optional=True, type=FieldType.NUMBER),\n        },\n    )\n)\n</code></pre>   <pre><code>templateRequest := &amp;template.CreateCredentialTemplateRequest{Name: fmt.Sprintf(\"Example Template - %s\", uuid.New()), AllowAdditionalFields: false, Fields: make(map[string]*template.TemplateField)}\ntemplateRequest.Fields[\"firstName\"] = &amp;template.TemplateField{Description: \"Given name\"}\ntemplateRequest.Fields[\"lastName\"] = &amp;template.TemplateField{}\ntemplateRequest.Fields[\"age\"] = &amp;template.TemplateField{Type: template.FieldType_NUMBER, Optional: true}\n\ntemplateResponse, err := templateService.Create(context.Background(), templateRequest)\n</code></pre>   <pre><code>var fields = new HashMap&lt;String, Templates.TemplateField&gt;();\nfields.put(\n    \"firstName\", Templates.TemplateField.newBuilder().setDescription(\"Given name\").build());\nfields.put(\"lastName\", Templates.TemplateField.newBuilder().build());\nfields.put(\n    \"age\",\n    Templates.TemplateField.newBuilder()\n        .setType(Templates.FieldType.NUMBER)\n        .setOptional(true)\n        .build());\nvar templateRequest =\n    Templates.CreateCredentialTemplateRequest.newBuilder()\n        .setName(\"My Example Credential-\" + UUID.randomUUID())\n        .setAllowAdditionalFields(false)\n        .putAllFields(fields)\n        .build();\nvar template = templateService.create(templateRequest).get();\n</code></pre>      <p>CreateCredentialTemplateRequestRequest to create a new templatename stringName of new templatefields FieldsEntry[]Fields which compose the templateShow child attributesfields.key stringfields.value TemplateFieldShow child attributesfields.value.description stringHuman-readable description of the fieldfields.value.optional boolWhether this field may be omitted when a credential is issued against the templatefields.value.type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4allow_additional_fields boolWhether credentials may be issued against this template which have fields not specified in <code>fields</code></p>   <p>CreateCredentialTemplateResponseResponse to <code>CreateCredentialTemplateRequest</code>data TemplateDataCreated templateShow child attributesdata.id stringTemplate IDdata.name stringTemplate namedata.version int32Template version numberdata.fields FieldsEntry[]Fields defined for the templateShow child attributesdata.fields.key stringdata.fields.value TemplateFieldShow child attributesdata.fields.value.description stringHuman-readable description of the fielddata.fields.value.optional boolWhether this field may be omitted when a credential is issued against the templatedata.fields.value.type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4data.allow_additional_fields boolWhether credentials issued against this template may  contain fields not defined by templatedata.schema_uri stringURI pointing to template JSON schema documentdata.context_uri stringURI pointing to template JSON-LD context documentdata.ecosystem_id stringID of ecosystem in which template residesdata.type stringTemplate type (<code>VerifiableCredential</code>)data.created_by stringID of template creator</p>","title":"Create Template"},{"location":"reference/services/template-service/#get-template","text":"<p>Fetches a template definition by <code>id</code>.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic template get --id &lt;TEMPLATE_ID&gt;\n</code></pre>   <pre><code>var getTemplateResponse = await templateService.GetAsync(new() {Id = template.Data.Id});\n</code></pre>   <pre><code>get_template_response = await template_service.get(\n    request=GetCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre>   <pre><code>getResponse, err := templateService.Get(context.Background(), &amp;template.GetCredentialTemplateRequest{Id: templateResponse.Data.Id})\n</code></pre>   <pre><code>var getResponse =\n    templateService\n        .get(Templates.GetCredentialTemplateRequest.newBuilder().setId(id).build())\n        .get();\n</code></pre>      <p>GetCredentialTemplateRequestRequest to fetch a template by IDid stringID of template to fetch</p>   <p>GetCredentialTemplateResponseResponse to <code>GetCredentialTemplateRequest</code>template TemplateDataTemplate fetched by IDShow child attributestemplate.id stringTemplate IDtemplate.name stringTemplate nametemplate.version int32Template version numbertemplate.fields FieldsEntry[]Fields defined for the templateShow child attributestemplate.fields.key stringtemplate.fields.value TemplateFieldShow child attributestemplate.fields.value.description stringHuman-readable description of the fieldtemplate.fields.value.optional boolWhether this field may be omitted when a credential is issued against the templatetemplate.fields.value.type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4template.allow_additional_fields boolWhether credentials issued against this template may  contain fields not defined by templatetemplate.schema_uri stringURI pointing to template JSON schema documenttemplate.context_uri stringURI pointing to template JSON-LD context documenttemplate.ecosystem_id stringID of ecosystem in which template residestemplate.type stringTemplate type (<code>VerifiableCredential</code>)template.created_by stringID of template creator</p>","title":"Get Template"},{"location":"reference/services/template-service/#delete-template","text":"<p>Deletes a credential template by <code>id</code>.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic tamplate delete --id &lt;TEMPLATE_ID&gt;\n</code></pre>   <pre><code>var deleteTemplateResponse = await templateService.DeleteAsync(new() {Id = template.Data.Id});\n</code></pre>   <pre><code>delete_template_response = await template_service.delete(\n    request=DeleteCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre>   <pre><code>deleteResponse, err := templateService.Delete(context.Background(), &amp;template.DeleteCredentialTemplateRequest{Id: templateResponse.Data.Id})\n</code></pre>   <pre><code>var deleteResponse =\n    templateService\n        .delete(Templates.DeleteCredentialTemplateRequest.newBuilder().setId(id).build())\n        .get();\n</code></pre>      <p>DeleteCredentialTemplateRequestRequest to delete a template by IDid stringID of template to delete</p>   <p>DeleteCredentialTemplateResponseResponse to <code>DeleteCredentialTemplateRequest</code>This message has no fields</p>","title":"Delete Template"},{"location":"reference/services/template-service/#search-templates","text":"<p>Searches all templates defined in the current ecosystem, and a <code>continuation_token</code> to paginate large result sets.</p> <p>If no <code>query</code> is specified, this call by default returns the first 100 templates.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic wallet search \\\n    --query \"SELECT * FROM c\"\n</code></pre>   <pre><code>var searchTemplateResponse = await templateService.SearchAsync(new() {Query = \"SELECT * FROM c\"});\n</code></pre>   <pre><code>search_template_response = await template_service.search(\n    request=SearchCredentialTemplatesRequest(query=\"SELECT * FROM c\")\n)\n</code></pre>   <pre><code>searchResponse, err := templateService.Search(context.Background(), &amp;template.SearchCredentialTemplatesRequest{Query: \"SELECT * FROM c\"})\n</code></pre>   <pre><code>var searchResponse =\n    templateService\n        .search(\n            Templates.SearchCredentialTemplatesRequest.newBuilder()\n                .setQuery(\"SELECT * FROM c WHERE c.id = '\" + id + \"'\")\n                .build())\n        .get();\n</code></pre>      <p>SearchCredentialTemplatesRequestRequest to search templates using a SQL queryquery stringSQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code>continuation_token optional stringToken provided by previous <code>SearchCredentialTemplatesResponse</code> if more data is available for query</p>   <p>SearchCredentialTemplatesResponseResponse to <code>SearchCredentialTemplatesRequest</code>items_json stringRaw JSON data returned from queryhas_more boolWhether more results are available for this query via <code>continuation_token</code>continuation_token stringCount of items in <code>items_json</code> int32 count = 3; unpopulated and unused Token to fetch next set of results via <code>SearchCredentialTemplatesRequest</code></p>","title":"Search Templates"},{"location":"reference/services/template-service/#advanced-search","text":"<p>The Search endpoint supports SQL queries through the <code>query</code> parameter.</p> <p>This allows for arbitrary query predicates, as well as more advanced functionality -- such as modifying the output format.</p>","title":"Advanced Search"},{"location":"reference/services/template-service/#schema","text":"<p>Any table name may be used in your query (we use <code>c</code> here) -- it doesn't matter what it is.</p>    Name Type Description     id string Corresponds to the <code>id</code> returned when template was created   type string Always <code>VerifiableCredential</code>   ecosystemId string ID of ecosystem in which template resides   createdBy string ID of account which defined the template   name string Name provided during template creation   schemaUri string HTTPS URL pointing to JSON Schema generated by Trinsic for this template   contextUri string HTTPS URL pointing to JSON-LD Context generated by Trinsic for this template   version int Version of template; increments whenever template is modified.   fields object JSON Object representing the template's fields    <p>Note that <code>fields</code> is an object, not a string; thus, any of its sub-fields may be queried against.</p>  <p>More Info</p> <p>This endpoint works very similarly to querying Wallet items; please see Wallet Service &gt; Search for more information.</p>","title":"Schema"},{"location":"reference/services/trust-registry-service/","text":"<p>The Trust Registry Service exposes functionality for managing Trust Registries -- lists of authorized issuers for the various credential types within an ecosystem.</p>  <p>Under Construction</p> <p>This section -- and the underlying API -- is under active development.</p> <p>We are working to define exactly how Trust Registries will be implemented within our platform; this page and API may change as we do so.</p>","title":"Trust Registry Service"},{"location":"reference/services/trust-registry-service/#create-governance-framework","text":"<p>Creates a Governance Framework and attaches it to the current ecosystem.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry register-efg\n</code></pre>   <pre><code>var schemaUri = \"https://schema.org/Card\";\nvar frameworkUri = \"https://example.com\";\nvar registerFrameworkResponse = await service.AddFrameworkAsync(new() {\n    Name = $\"Demo framework-{Guid.NewGuid()}\",\n    GovernanceFrameworkUri = frameworkUri,\n    Description = schemaUri\n});\n</code></pre>   <pre><code>register_framework_response = await service.add_framework(\n    request=AddFrameworkRequest(\n        governance_framework_uri=https_example_com,\n        description=\"Demo framework\",\n        name=framework_name,\n    )\n)\n</code></pre>   <pre><code>newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n    GovernanceFrameworkUri: frameworkURI,\n    Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n})\n</code></pre>   <pre><code>package trinsic;\n\nimport java.io.IOException;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutionException;\nimport org.junit.jupiter.api.Assertions;\nimport trinsic.okapi.DidException;\nimport trinsic.services.AccountService;\nimport trinsic.services.TrustRegistryService;\nimport trinsic.services.trustregistry.v1.TrustRegistryOuterClass;\n\npublic class TrustRegistryDemo {\n  public static void main(String[] args)\n      throws IOException, DidException, ExecutionException, InterruptedException {\n    run();\n  }\n\n  public static void run()\n      throws IOException, DidException, ExecutionException, InterruptedException {\n    var accountService = new AccountService(TrinsicUtilities.getTrinsicServiceOptions());\n    var account = accountService.signIn().get();\n    var service = new TrustRegistryService(TrinsicUtilities.getTrinsicServiceOptions(account));\n\n    final String didUri = \"did:example:test\";\n    final String frameworkUri = \"https://example.com/\" + UUID.randomUUID();\n    final String typeUri = \"https://schema.org/Card\";\n\n    // addFramework() {\n    var frameworkResponse =\n        service\n            .addFramework(\n                TrustRegistryOuterClass.AddFrameworkRequest.newBuilder()\n                    .setGovernanceFrameworkUri(frameworkUri)\n                    .setName(\"Example Framework\" + UUID.randomUUID())\n                    .build())\n            .get();\n    // }\n\n    // registerIssuerSample() {\n    service.registerMember(\n        TrustRegistryOuterClass.RegisterMemberRequest.newBuilder()\n            .setDidUri(didUri)\n            .setFrameworkId(frameworkResponse.getId())\n            .setSchemaUri(typeUri)\n            .build());\n    // }\n    // checkIssuerStatus() {\n    var issuerStatus =\n        service\n            .checkIssuerStatus(\n                TrustRegistryOuterClass.GetMembershipStatusRequest.newBuilder()\n                    .setDidUri(didUri)\n                    .setGovernanceFrameworkUri(frameworkUri)\n                    .setSchemaUri(typeUri)\n                    .build())\n            .get();\n    // }\n    Assertions.assertEquals(\n        TrustRegistryOuterClass.RegistrationStatus.CURRENT, issuerStatus.getStatus());\n\n    // searchTrustRegistry() {\n    var searchResult = service.searchRegistry().get();\n    // }\n    Assertions.assertNotNull(searchResult);\n    Assertions.assertNotNull(searchResult.getItemsJson());\n    Assertions.assertTrue(searchResult.getItemsJson().length() &gt; 0);\n\n    // unregisterIssuer() {\n    service.unregisterIssuer(\n        TrustRegistryOuterClass.UnregisterMemberRequest.newBuilder()\n            .setFrameworkId(frameworkResponse.getId())\n            .setDidUri(didUri)\n            .setSchemaUri(typeUri)\n            .build());\n    // }\n  }\n}\n</code></pre>      <p>AddFrameworkRequestRegister new ecosystem governance frameworkgovernance_framework_uri stringname stringdescription string</p>   <p>AddFrameworkResponseid stringUnique framework identifiergoverning_authority stringtrust_registry string</p>","title":"Create Governance Framework"},{"location":"reference/services/trust-registry-service/#register-issuer","text":"<p>Registers an authorized issuer for a specific credential type (identified by its <code>schema_uri</code>).</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry register-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>var didUri = \"did:example:test\";\nvar registerMemberResponse = await service.RegisterMemberAsync(new() {\n    DidUri = didUri,\n    FrameworkId = registerFrameworkResponse.Id,\n    SchemaUri = schemaUri\n});\n</code></pre>   <pre><code>await service.register_member(\n    request=RegisterMemberRequest(\n        did_uri=did_example_test,\n        framework_id=register_framework_response.id,\n        schema_uri=https_schema_org,\n    )\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/trinsic-id/sdk/go/proto/sdk/options/v1/options\"\n    \"github.com/trinsic-id/sdk/go/proto/services/account/v1/account\"\n    \"github.com/trinsic-id/sdk/go/proto/services/provider/v1/provider\"\n    \"github.com/trinsic-id/sdk/go/proto/services/trustregistry/v1/trustregistry\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>service.registerMember(\n    TrustRegistryOuterClass.RegisterMemberRequest.newBuilder()\n        .setDidUri(didUri)\n        .setFrameworkId(frameworkResponse.getId())\n        .setSchemaUri(typeUri)\n        .build());\n</code></pre>      <p>RegisterMemberRequestdid_uri stringwallet_id stringemail stringschema_uri stringvalid_from_utc uint64valid_until_utc uint64framework_id stringthe id of the governance framework</p>   <p>RegisterMemberResponseThis message has no fields</p>","title":"Register Issuer"},{"location":"reference/services/trust-registry-service/#unregister-issuer","text":"<p>Unregisters an issuer for a specific credential type (identified by its <code>schema_uri</code>).</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry unregister-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>await service.UnregisterMemberAsync(new() {\n    DidUri = didUri,\n    FrameworkId = registerFrameworkResponse.Id,\n    SchemaUri = schemaUri\n});\n</code></pre>   <pre><code>unregister_issuer_response = await service.unregister_member(\n    request=UnregisterMemberRequest(\n        framework_id=register_framework_response.id,\n        schema_uri=https_schema_org,\n        did_uri=did_example_test,\n    )\n)\n</code></pre>   <pre><code>unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n    SchemaUri:   schemaURI,\n    FrameworkId: newFramework.Id,\n})\n</code></pre>   <pre><code>service.unregisterIssuer(\n    TrustRegistryOuterClass.UnregisterMemberRequest.newBuilder()\n        .setFrameworkId(frameworkResponse.getId())\n        .setDidUri(didUri)\n        .setSchemaUri(typeUri)\n        .build());\n</code></pre>      <p>UnregisterMemberRequestdid_uri stringwallet_id stringemail stringschema_uri stringframework_id string</p>   <p>UnregisterMemberResponseThis message has no fields</p>","title":"Unregister Issuer"},{"location":"reference/services/trust-registry-service/#check-issuer-status","text":"<p>Check the status of an issuer for a specific credential type.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry check-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>var issuerStatus = await service.GetMembershipStatusAsync(new() {\n    DidUri = didUri,\n    GovernanceFrameworkUri = frameworkUri,\n    SchemaUri = schemaUri\n});\n</code></pre>   <pre><code>check_response = await service.get_membership_status(\n    request=GetMembershipStatusRequest(\n        did_uri=did_example_test,\n        governance_framework_uri=https_example_com,\n        schema_uri=https_schema_org,\n    )\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/trinsic-id/sdk/go/proto/sdk/options/v1/options\"\n    \"github.com/trinsic-id/sdk/go/proto/services/account/v1/account\"\n    \"github.com/trinsic-id/sdk/go/proto/services/provider/v1/provider\"\n    \"github.com/trinsic-id/sdk/go/proto/services/trustregistry/v1/trustregistry\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var issuerStatus =\n    service\n        .checkIssuerStatus(\n            TrustRegistryOuterClass.GetMembershipStatusRequest.newBuilder()\n                .setDidUri(didUri)\n                .setGovernanceFrameworkUri(frameworkUri)\n                .setSchemaUri(typeUri)\n                .build())\n        .get();\n</code></pre>      <p>GetMembershipStatusRequestgovernance_framework_uri stringdid_uri stringx509_cert stringschema_uri string</p>   <p>GetMembershipStatusResponsestatus RegistrationStatusShow enum valuesRegistrationStatus.CURRENT  = 0- the entity is currently authorized, as of time of the query.RegistrationStatus.EXPIRED  = 1- entity rights have expired.RegistrationStatus.TERMINATED  = 2- entity has voluntarily ceased Issuer role under the specific EGF.RegistrationStatus.REVOKED  = 3- entity authority under specific EGF was terminated by the governing authority.RegistrationStatus.NOT_FOUND  = 10</p>","title":"Check Issuer Status"},{"location":"reference/services/trust-registry-service/#search","text":"<p>Search the registry for registered issuers using a SQL query.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry search --query &lt;SQL query&gt;\n</code></pre>   <pre><code>var searchResult = await service.SearchRegistryAsync(new());\n</code></pre>   <pre><code>search_result = await service.search_registry()\n</code></pre>   <pre><code>ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n</code></pre>   <pre><code>var searchResult = service.searchRegistry().get();\n</code></pre>      <p>SearchRegistryRequestquery stringSELECT c from c where c.type == 'GovernanceFramework'continuation_token string</p>   <p>SearchRegistryResponseitems_json stringhas_more boolcontinuation_token string</p>","title":"Search"},{"location":"reference/services/trust-registry-service/#cache-offline-registry-file","text":"Trinsic CLI   <pre><code>trinsic trust-registry download \n</code></pre>","title":"Cache Offline Registry File"},{"location":"reference/services/wallet-service/","text":"<p>The wallet service is the main interface for interacting with a cloud wallet. </p>  <p>Wallets vs Accounts</p> <p>Wallets and accounts are related and often interchangeable -- each account has an associated wallet, and operations on a wallet are performed using an account's access token.</p> <p>Every account has exactly one wallet. </p>   <p>Wallet Standard</p> <p>This service is designed to follow the recommendations of the Universal Wallet 2020  specification by the W3C Community Credentials Group.</p>","title":"Wallet Service"},{"location":"reference/services/wallet-service/#create-wallet","text":"<p>A wallet is created whenever an account is created.</p> <p>Therefore, to create a wallet, you'll need to create a new account.</p>","title":"Create Wallet"},{"location":"reference/services/wallet-service/#insert-item","text":"<p>Stores a credential (or any other JSON object) in a wallet.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic wallet insert-item --item &lt;INPUT_JSON_FILE&gt;\n</code></pre>   <pre><code>let insertItemResponse = await walletService.insertItem(\n  InsertItemRequest.fromPartial({\n    itemJson: issueResponse.signedDocumentJson,\n  })\n);\n</code></pre>   <pre><code>var insertItemResponse = await walletService.InsertItemAsync(new() {ItemJson = credentialJson.DocumentJson});\n</code></pre>   <pre><code>insert_response = await wallet_service.insert_item(\n    request=InsertItemRequest(\n        item_json=credential, item_type=\"VerifiableCredential\"\n    )\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/trinsic-id/sdk/go/proto/sdk/options/v1/options\"\n    \"github.com/trinsic-id/sdk/go/proto/services/account/v1/account\"\n    \"github.com/trinsic-id/sdk/go/proto/services/provider/v1/provider\"\n    \"github.com/trinsic-id/sdk/go/proto/services/trustregistry/v1/trustregistry\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var insertResponse =\n    walletService\n        .insertItem(\n            UniversalWalletOuterClass.InsertItemRequest.newBuilder()\n                .setItemJson(credentialJson)\n                .setItemType(\"VerifiableCredential\")\n                .build())\n        .get();\n</code></pre>      <p>InsertItemRequestRequest to insert a JSON document into a walletitem_json stringDocument to insert; must be stringified JSONitem_type optional stringItem type (ex. \"VerifiableCredential\")</p>   <p>InsertItemResponseResponse to <code>InsertItemRequest</code>item_id stringID of item inserted into wallet</p>     <p>What can be stored in a wallet?</p> <p>Wallets are mainly intended to hold Verifiable Credentials, but can technically store any JSON blob.</p> <p>If you store a Verifiable Credential in a Wallet, ensure that its <code>item_type</code> is <code>VerifiableCredential</code>.</p> <p>Otherwise, ensure its <code>item_type</code> is not <code>VerifiableCredential</code>.</p>","title":"Insert Item"},{"location":"reference/services/wallet-service/#search-wallet","text":"<p>Searches a wallet, returning all matching items, and a <code>continuation_token</code> to paginate large result sets.</p> <p>If no <code>query</code> is specified, this call by default returns the first 100 items in the wallet.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic wallet search\n</code></pre>   <pre><code>let items = await walletService.search();\n</code></pre>   <pre><code>var walletItems = await walletService.SearchAsync(new());\n</code></pre>   <pre><code>wallet_items = await wallet_service.search()\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/trinsic-id/sdk/go/proto/sdk/options/v1/options\"\n    \"github.com/trinsic-id/sdk/go/proto/services/account/v1/account\"\n    \"github.com/trinsic-id/sdk/go/proto/services/provider/v1/provider\"\n    \"github.com/trinsic-id/sdk/go/proto/services/trustregistry/v1/trustregistry\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var walletItems = walletService.search().get();\n</code></pre>       <p>SearchRequestRequest to search items in walletquery stringSQL Query to execute against items in walletcontinuation_token optional stringToken provided by previous <code>SearchResponse</code> if more data is available for query</p>   <p>SearchResponseResponse to <code>SearchRequest</code>items string[]Array of query results, as JSON stringshas_more boolWhether more results are available for this query via <code>continuation_token</code>continuation_token stringToken to fetch next set of results via <code>SearchRequest</code></p>     <p>Verifiable Presentation Request Spec</p> <p>In the future, this endpoint will support the Verifiable Presentation Request Spec .</p>","title":"Search Wallet"},{"location":"reference/services/wallet-service/#advanced-search","text":"<p>The Search endpoint supports SQL queries through the <code>query</code> parameter.</p> <p>This allows for arbitrary query predicates, as well as more advanced functionality -- such as modifying the output format.</p>","title":"Advanced Search"},{"location":"reference/services/wallet-service/#schema","text":"<p>Any table name may be used in your query (we use <code>c</code> here) -- it doesn't matter what it is.</p>    Name Type Description     id string Corresponds to the <code>item_id</code> returned when item was inserted into wallet   type string Specified via <code>item_type</code> when item was inserted into wallet   data object The JSON object passed via <code>item_json</code> when item was inserted into wallet    <p>Note that <code>data</code> is an object, not a string; thus, any of its sub-fields may be queried against.</p> <p>For example, <code>SELECT * FROM c WHERE c.data.someField = 'Hello, World!'</code> would match against the following JSON object inserted via InsertItem:</p> <pre><code>{ \n    \"someField\": \"Hello, World!\"\n}\n</code></pre>","title":"Schema"},{"location":"reference/services/wallet-service/#common-sql-queries","text":"","title":"Common SQL Queries"},{"location":"reference/services/wallet-service/#paging","text":"<p>Paging uses the <code>OFFSET</code> clause that takes in a value indicating how many records should be skipped in the returned query. To specify the size of the result set (page size) use the <code>LIMIT</code> clause.</p> <pre><code>SELECT * FROM c OFFSET 10 LIMIT 5\n</code></pre>","title":"Paging"},{"location":"reference/services/wallet-service/#sorting","text":"<p>The optional <code>ORDER BY</code> clause specifies the sorting order for results returned by the query. To control sorting order, specify <code>ASC</code> or <code>DESC</code> at the end; if not specified ascending order is used by default.</p> <pre><code>SELECT * FROM c ORDER BY c.credential.issued DESC\n</code></pre>","title":"Sorting"},{"location":"reference/services/wallet-service/#filtering","text":"<p>The optional WHERE clause (<code>WHERE &lt;filter_condition&gt;</code>) specifies condition(s) that the source JSON items must satisfy for the query to include them in results. A JSON item must evaluate the specified conditions to true to be considered for the result. The index layer uses the <code>WHERE</code> clause to determine the smallest subset of source items that can be part of the result.</p> <pre><code>SELECT * FROM c WHERE c.name = 'Trinsic' AND c.dateCreated &gt;= \"2020-09-30T23:14:25.7251173Z\"\n</code></pre>","title":"Filtering"},{"location":"reference/services/wallet-service/#grouping","text":"<p>The <code>GROUP BY</code> clause divides the query's results according to the values of one or more specified properties. Examples and detailed description on working with grouped results can be found here </p>","title":"Grouping"},{"location":"reference/services/wallet-service/#additional-resources","text":"<p>You can read the full documentation on working with SQL queries on the Azure Cosmos DB website .</p>","title":"Additional Resources"},{"location":"ruby/","text":"<p>The Trinsic Ruby SDK makes it easy to interact with the Trinsic API from any Ruby application. The most recent version of the library can be found on RubyGems. You can find the SDKs source on Github.</p>","title":"The Trinsic Ruby SDK"},{"location":"ruby/#installation-and-configuration","text":"<ul> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>RUBY_DLL_PATH</code> on windows. <code>LD_LIBRARY_PATH</code> for Ruby on Mac/Linux <pre><code>gem install trinsic-services\n</code></pre></li> <li>Test installation by running the following Ruby script: <pre><code>require 'trinsic_services'\n\naccount_service = Trinsic::AccountService.new(nil, Trinsic::trinsic_prod_server)\naccount_profile = account_service.sign_in(nil).profile\nputs account_profile\n</code></pre></li> <li>Output should look something like this: <pre><code>&lt;Services::Account::V1::AccountProfile: profile_type: \"https://trinsic.id/security/v1/oberon\", auth_data: \")urn:trinsic:wallets:bbBEp9EmV1NNWMadBhit2$19ac25ae-2fd0-44d1-9ef7-73cc668e8f7d\", auth_token: \"\u2592\", protection: &lt;Services::Account::V1::TokenProtection: enabled: false, method: :None&gt;&gt;\n</code></pre></li> </ul>","title":"Installation and Configuration"},{"location":"ruby/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API </p>","title":"Next Steps"},{"location":"walkthroughs/vaccination/","text":"<p>This walkthrough demonstrates how a vaccination card can be issued, held, and shared using Verifiable Credentials with Trinsic.</p>","title":"Walkthrough: Build a Vaccine Card"},{"location":"walkthroughs/vaccination/#meet-allison","text":"<p>We'll follow Allison as she obtains a vaccine certificate, stores it in her digital wallet, and presents it to board an airplane.</p> <p>In most credential exchange scenarios, there are three primary roles: Issuer, Holder, and Verifier.</p> <p>Holder: Stores credentials received from issuers, and presents them to verifiers. (Said credentials are often, but not always, attesting information about the holder)</p> <p>Issuer: Signs and issues credentials which attest information about a credential subject.</p> <p>Verifier: Verifies credentials presented by holders.</p> <p>In this case, Allison will be the holder, a vaccination clinic will be the issuer, and an airline will be the verifier. </p>","title":"Meet Allison"},{"location":"walkthroughs/vaccination/#our-sdks","text":"<p>You can follow along using one of our SDKs, or use the Trinsic CLI, which implements full platform functionality.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>Click here for installation instructions for the Trinsic CLI.</p>    <p>Click here for installation instructions for the Node/Browser SDK.</p>   <p>Click here for installation instructions for the .NET SDK.</p>   <p>Click here for installation instructions for the Python SDK.</p>   <p>Click here for installation instructions for the Java SDK.</p>   <p>Click here for installation instructions for the Go SDK.</p>   <p>Click here for installation instructions for the Ruby   SDK.</p>","title":"Our SDKs"},{"location":"walkthroughs/vaccination/#create-an-ecosystem","text":"<p>The first step is to create an ecosystem, within which everything else (wallets, templates, and credentials) will live.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic provider create-ecosystem\n</code></pre>   <pre><code>const ecosystem = await providerService.createEcosystem(\n  CreateEcosystemRequest.fromPartial({})\n);\nconst ecosystemId = ecosystem.ecosystem!.id;\n</code></pre>   <pre><code>var providerService = new ProviderService(_options);\n\nvar (ecosystem, _) = await providerService.CreateEcosystemAsync(new());\nvar ecosystemId = ecosystem?.Id;\n</code></pre>   <pre><code>ecosystem = await provider_service.create_ecosystem()\necosystem_id = ecosystem.ecosystem.id\n</code></pre>   <pre><code>var ecosystemResponse =\n    providerService\n        .createEcosystem(ProviderOuterClass.CreateEcosystemRequest.getDefaultInstance())\n        .get();\n\nvar ecosystemId = ecosystemResponse.getEcosystem().getId();\n</code></pre>   <pre><code>ecosystem, _ := providerService.CreateEcosystem(context.Background(), nil)\necosystemId := ecosystem.Ecosystem.Id\n</code></pre>   <pre><code>ecosystem = provider_service.create_ecosystem\necosystem_id = ecosystem.ecosystem.id\n</code></pre>    <p>The response to this call contains the name and ID of your newly-created ecosystem; copy either of these down.</p>","title":"Create an Ecosystem"},{"location":"walkthroughs/vaccination/#configure-sdk-for-created-ecosystem","text":"<p>Once we've created our ecosystem, we need to configure our SDK client (or CLI) to use it as the default ecosystem for all service calls in the rest of the walkthrough.</p> Trinsic CLITypescriptC#PythonJavaGo   <pre><code>trinsic config --default-ecosystem \"{ECOSYSTEM_NAME_OR_ID}\"\n</code></pre>   <pre><code>// Either configure defaultEcosystem during instantiation of an SDK service...\nconst options = ServiceOptions.fromPartial({\n    defaultEcosystem: \"{ECOSYSTEM_NAME_OR_ID}\"\n});\n\nconst providerService = new ProviderService(options); \n\n//...or after instantiation\nproviderService.options.defaultEcosystem = \"{ECOSYSTEM_NAME_OR_ID}\";\n</code></pre>   <pre><code>// Either configure DefaultEcosystem during instantiation of an SDK service...\nvar providerService = new ProviderService(new()\n{\n    DefaultEcosystem = \"{ECOSYSTEM_NAME_OR_ID}\"\n});\n\n//...or after instantiation\nproviderService.Options.DefaultEcosystem = \"{ECOSYSTEM_NAME_OR_ID}\";\n</code></pre>   <pre><code>from trinsic.trinsic_util import trinsic_config\n\n# Either configure default_ecosystem during instantiation of an SDK service...\nconfig = trinsic_config()\nconfig.default_ecosystem = \"{ECOSYSTEM_NAME_OR_ID}\"\nprovider_service = ProviderService(server_config=config)\n\n# ...or after instantiation\nprovider_service.service_options.default_ecosystem = \"{ECOSYSTEM_NAME_OR_ID}\"\n</code></pre>   <pre><code>var options = TrinsicUtilities.getTrinsicServiceOptions();\noptions = options\n          .toBuilder()\n          .setDefaultEcosystem(\"ECOSYSTEM_ID_OR_NAME\")\n          .build();\nvar accountService = new AccountService(options);\n</code></pre>   <pre><code>///Either configure DefaultEcosystem during instantiation of an SDK service...\nopts, _ := sdk.NewServiceOptions()\nproviderService, _ := sdk.NewProviderService(opts)\n\n//...or after instantiation\nproviderService.options.ServiceOptions.DefaultEcosystem = \"{ECOSYSTEM_NAME_OR_ID}\"\n</code></pre>     <p>Further Reading: Ecosystems</p> <ul> <li>Learn more about Ecosystems</li> <li>Browse the Provider API reference</li> </ul>","title":"Configure SDK for Created Ecosystem"},{"location":"walkthroughs/vaccination/#create-accounts","text":"<p>We need to create Trinsic accounts for the participants in this credential exchange. Accounts and wallets can be considered interchangeably; all accounts have exactly one associated wallet.</p> <p>Accounts can be created with a single call; they're designed to minimize onboarding friction for your users.</p> <p>The clinic's account will issue the credential, Allison's account will hold it, and the airline's account will verify its contents.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>The CLI makes it easy to create wallets. For demo purposes, we'll create all three on the same machine.</p> <p>When using the CLI, the authentication token of the most recently used account is saved in <code>~/.trinsic</code>. In a real-world scenario, you should back this token up securely.</p> <pre><code>trinsic account login --name \"Allison\"\n# Save auth token in `allison.txt` before continuing\n\ntrinsic account login --name \"Airline\"\n# Save auth token in `airline.txt` before continuing\n\ntrinsic account login --name \"Vaccination Clinic\"\n# Save auth token in `clinic.txt` before continuing\n</code></pre>   <pre><code>// Create 3 different profiles for each participant in the scenario\nconst allison = await accountService.signIn();\nconst clinic = await accountService.signIn();\nconst airline = await accountService.signIn();\n</code></pre> <p>If you would like to save the account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code>var accountService = new AccountService(_options);\n\nvar allison = await accountService.SignInAsync(new() { EcosystemId = ecosystemId });\nvar clinic = await accountService.SignInAsync(new() { EcosystemId = ecosystemId });\nvar airline = await accountService.SignInAsync(new() { EcosystemId = ecosystemId });\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code># Create an account for each participant in the scenario\nallison = await account_service.sign_in()\nairline = await account_service.sign_in()\nclinic = await account_service.sign_in()\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code>// Create an account for each participant in the scenario\nvar allison = accountService.signIn().get();\nvar clinic = accountService.signIn().get();\nvar airline = accountService.signIn().get();\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code>// Create an account for each participant in the scenario\nallison, _, _ := accountService.SignIn(context.Background(), nil)\nairline, _, _ := accountService.SignIn(context.Background(), nil)\nclinic, _, _ := accountService.SignIn(context.Background(), nil)\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code># Create an account for each participant in the scenario\nallison = account_service.sign_in\nclinic = account_service.sign_in\nairline = account_service.sign_in\n</code></pre>     <p>Production Usage</p> <p>In this example, we've created anonymous accounts; the only way to access them is by saving the authentication token generated on account creation.</p> <p>In a production scenario, you may want to create accounts tied to a user's email address or phone number. This allows users to securely access their Trinsic cloud wallets at any time.</p> <p>Note that accounts are tied to their ecosystem. If you create an account tied to <code>bob@example.com</code> in the <code>example1</code> ecosystem, it will not be visible in any other ecosystem. The same email address can be used to create accounts in multiple ecosystems.</p>   <p>Further Reading: Accounts and Wallets</p> <ul> <li>Learn more about Wallets</li> <li>Browse the Account API reference</li> <li>Read about authentication tokens and security</li> </ul>","title":"Create Accounts"},{"location":"walkthroughs/vaccination/#define-a-template","text":"<p>Before we can issue a credential, we need to create a Template for it. </p> <p>Templates are simply a list of the fields that a credential can have.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>First, prepare a JSON file which describes your template:</p> templateData.json     <pre><code>{\n    \"firstName\": {\n        \"type\": \"string\",\n        \"description\": \"First name of vaccine recipient\"\n    },\n    \"lastName\": {\n        \"type\": \"string\",\n        \"description\": \"Last name of vaccine recipient\"\n    },\n    \"batchNumber\":{\n        \"type\": \"string\",\n        \"description\": \"Batch number of vaccine\"\n    },\n    \"countryOfVaccination\":{\n        \"type\": \"string\",\n        \"description\": \"Country in which the subject was vaccinated\"\n    }\n}\n</code></pre> <p>Then create the template:</p> <pre><code>trinsic template create -n \"VaccinationCertificate\" --fields-file templateData.json \n</code></pre> <p>The output of this command will include a template ID; copy this down for later use.</p>   <pre><code>//Define all fields\nconst firstNameField = TemplateField.fromPartial({\n  description: \"First name of vaccine recipient\",\n  type: FieldType.STRING,\n});\n\nconst lastNameField = TemplateField.fromPartial({\n  type: FieldType.STRING,\n  description: \"Last name of vaccine recipient\",\n});\n\nconst batchNumberField = TemplateField.fromPartial({\n  type: FieldType.STRING,\n  description: \"Batch number of vaccine\",\n});\n\nconst countryOfVaccinationField = TemplateField.fromPartial({\n  type: FieldType.STRING,\n  description: \"Country in which the subject was vaccinated\",\n});\n\n//Create request\nlet request = CreateCredentialTemplateRequest.fromPartial({\n  name: \"VaccinationCertificate\",\n  fields: {\n    firstName: firstNameField,\n    lastName: lastNameField,\n    batchNumber: batchNumberField,\n    countryOfVaccination: countryOfVaccinationField,\n  },\n});\n\n//Create template\nconst response = await templateService.createCredentialTemplate(request);\nconst template = response.data;\n</code></pre>   <pre><code>// Create a TemplateService instance\nvar templateService = new TemplateService(_options);\n\n// Prepare request to create template\nCreateCredentialTemplateRequest templateRequest = new() {\n    Name = \"VaccinationCertificate\",\n    AllowAdditionalFields = false\n};\n\ntemplateRequest.Fields.Add(\"firstName\", new() { Description = \"First name of vaccine recipient\" });\ntemplateRequest.Fields.Add(\"lastName\", new() { Description = \"Last name of vaccine recipient\" });\ntemplateRequest.Fields.Add(\"batchNumber\", new() { Description = \"Batch number of vaccine\", Type = FieldType.String });\ntemplateRequest.Fields.Add(\"countryOfVaccination\", new() { Description = \"Country in which the subject was vaccinated\" });\n\n// Create template\nvar template = await templateService.CreateAsync(templateRequest);\nvar templateId = template?.Data?.Id;\n</code></pre>   <pre><code>template = await template_service.create(\n    request=CreateCredentialTemplateRequest(\n        name=\"VaccinationCertificate\",\n        allow_additional_fields=False,\n        fields={\n            \"firstName\": TemplateField(\n                description=\"First name of vaccine recipient\"\n            ),\n            \"lastName\": TemplateField(description=\"Last name of vaccine recipient\"),\n            \"batchNumber\": TemplateField(\n                description=\"Batch number of vaccine\", type=FieldType.STRING\n            ),\n            \"countryOfVaccination\": TemplateField(\n                description=\"Country in which the subject was vaccinated\"\n            ),\n        },\n    )\n)\n\ntemplate_id = template.data.id\n</code></pre>   <pre><code>// Set active profile to 'clinic'\ntemplateService.setProfile(clinic);\n\n// Define fields for template\nvar fields = new HashMap&lt;String, Templates.TemplateField&gt;();\nfields.put(\n    \"firstName\",\n    Templates.TemplateField.newBuilder()\n        .setDescription(\"First name of vaccine recipient\")\n        .build());\nfields.put(\n    \"lastName\",\n    Templates.TemplateField.newBuilder()\n        .setDescription(\"Last name of vaccine recipient\")\n        .build());\nfields.put(\n    \"batchNumber\",\n    Templates.TemplateField.newBuilder()\n        .setType(Templates.FieldType.STRING)\n        .setDescription(\"Batch number of vaccine\")\n        .build());\nfields.put(\n    \"countryOfVaccination\",\n    Templates.TemplateField.newBuilder()\n        .setDescription(\"Country in which the subject was vaccinated\")\n        .build());\n\n// Create template request\nvar templateRequest =\n    Templates.CreateCredentialTemplateRequest.newBuilder()\n        .setName(\"VaccinationCertificate\")\n        .setAllowAdditionalFields(false)\n        .putAllFields(fields)\n        .build();\n\n// Execute template creation\nvar template = templateService.create(templateRequest).get();\nvar templateId = template.getData().getId();\n</code></pre>   <pre><code>templateRequest := &amp;template.CreateCredentialTemplateRequest{Name: \"VaccinationCertificate\", AllowAdditionalFields: false, Fields: make(map[string]*template.TemplateField)}\ntemplateRequest.Fields[\"firstName\"] = &amp;template.TemplateField{Description: \"First name of vaccine recipient\"}\ntemplateRequest.Fields[\"lastName\"] = &amp;template.TemplateField{Description: \"Last name of vaccine recipient\"}\ntemplateRequest.Fields[\"batchNumber\"] = &amp;template.TemplateField{Description: \"Batch number of vaccine\", Type: template.FieldType_STRING}\ntemplateRequest.Fields[\"countryOfVaccination\"] = &amp;template.TemplateField{Description: \"Country in which the subject was vaccinated\"}\n\ncreatedTemplate, _ := templateService.Create(context.Background(), templateRequest)\n\ntemplateId := createdTemplate.Data.Id\n</code></pre>   <pre><code>request = Trinsic::Template::CreateCredentialTemplateRequest.new(name: 'VaccinationCertificate',\n                                                                    allow_additional_fields: false)\nrequest.fields['firstName'] = Trinsic::Template::TemplateField.new(description: 'First name of vaccine recipient')\nrequest.fields['lastName'] = Trinsic::Template::TemplateField.new(description: 'Last name of vaccine recipient')\nrequest.fields['batchNumber'] =\n  Trinsic::Template::TemplateField.new(description: 'Batch number of vaccine',\n                                          type: Trinsic::Template::FieldType::STRING)\nrequest.fields['countryOfVaccination'] =\n  Trinsic::Template::TemplateField.new(description: 'Country in which the subject was vaccinated')\n\ntemplate = template_service.create(request)\ntemplate_id = template.data.id\n</code></pre>     <p>Templates are Optional</p> <p>Templates are an optional helpful abstraction which removes the need to work directly with complex data formats such as JSON-LD.</p> <p>When a template is used to issue a credential, the result is a valid, interoperable JSON-LD Verifiable Credential.</p> <p>Trinsic's SDKs support issuing JSON-LD credentials that you create yourself, should you choose not to use templates.</p>   <p>Further Reading: Templates</p> <ul> <li>Learn more about Templates</li> <li>Browse the Template API reference</li> </ul>","title":"Define a Template"},{"location":"walkthroughs/vaccination/#issue-a-credential","text":"<p>Upon receiving her vaccine, the clinic issues Allison a Verifiable Credential, which proves that she was given the vaccine by the clinic.</p> <p>A credential is a JSON document that has been cryptographically signed; this signature enables verifiers to trust that the data comes a trusted source, and has not been tampered with.</p> <p>To issue a vaccine certificate, we'll use the template we created in the last step.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>First, prepare a file named <code>values.json</code> with the following content:</p> values.json     <pre><code>{\n    \"firstName\": \"Allison\",\n    \"lastName\": \"Allisonne\",\n    \"batchNumber\": \"123454321\",\n    \"countryOfVaccination\": \"US\"\n}\n</code></pre> <p>Then issue the credential:</p> <pre><code>trinsic config --auth-token $(cat clinic.txt)\ntrinsic vc issue-from-template --template-id {TEMPLATE_ID} --values-file values.json --out credential.json\n</code></pre> <p>The output of this command will contain a signed JSON document, which has been saved to <code>credential.json</code>.</p>   <pre><code>// Prepare the credential values JSON document\nconst credentialValues = JSON.stringify({\n  firstName: \"Allison\",\n  lastName: \"Allisonne\",\n  batchNumber: \"123454321\",\n  countryOfVaccination: \"US\",\n});\n\n// Sign a credential as the clinic and send it to Allison\ncredentialService.options.authToken = clinic;\nconst issueResponse = await credentialService.issueFromTemplate(\n  IssueFromTemplateRequest.fromPartial({\n    templateId: template.id,\n    valuesJson: credentialValues,\n  })\n);\n</code></pre>   <pre><code>var credentialService = new CredentialService(_options);\n\n// Set active profile to 'clinic' so we can issue credential signed\n// with the clinic's signing keys\ncredentialService.Options.AuthToken = clinic;\n\n// Prepare credential values\nvar credentialValues = new Dictionary&lt;string, string&gt;() {\n    { \"firstName\", \"Allison\" },\n    { \"lastName\", \"Allisonne\" },\n    { \"batchNumber\", \"123454321\" },\n    { \"countryOfVaccination\", \"US\" }\n};\n\n// Issue credential\nvar issueResponse = await credentialService.IssueFromTemplateAsync(new() {\n    TemplateId = templateId,\n    ValuesJson = JsonSerializer.Serialize(credentialValues)\n});\n\nvar signedCredential = issueResponse?.DocumentJson;\n</code></pre>   <pre><code># Prepare values for credential\nvalues = json.dumps(\n    {\n        \"firstName\": \"Allison\",\n        \"lastName\": \"Allisonne\",\n        \"batchNumber\": \"123454321\",\n        \"countryOfVaccination\": \"US\",\n    }\n)\n\n# Issue credential\nissue_response = await credential_service.issue_from_template(\n    request=IssueFromTemplateRequest(template_id=template.id, values_json=values)\n)\n\ncredential = issue_response.document_json\n</code></pre>   <pre><code>// Set active profile to 'clinic' so we can issue credential signed\n// with the clinic's signing keys\ncredentialService.setProfile(clinic);\n\n// Prepare credential values\nvar valuesMap = new HashMap&lt;String, Object&gt;();\nvaluesMap.put(\"firstName\", \"Allison\");\nvaluesMap.put(\"lastName\", \"Allissonne\");\nvaluesMap.put(\"batchNumber\", \"123454321\");\nvaluesMap.put(\"countryOfVaccination\", \"US\");\n\n// Serialize values to JSON\nvar valuesJson = new Gson().toJson(valuesMap);\n\n// Issue credential\nvar issueResponse =\n    credentialService\n        .issueCredentialFromTemplate(\n            VerifiableCredentials.IssueFromTemplateRequest.newBuilder()\n                .setTemplateId(templateId)\n                .setValuesJson(valuesJson)\n                .build())\n        .get();\n\nvar credential = issueResponse.getDocumentJson();\n</code></pre>   <pre><code>// Prepare values for credential\nvaluesStruct := struct {\n    FirstName            string\n    LastName             string\n    batchNumber          string\n    countryOfVaccination string\n}{\n    FirstName:            \"Allison\",\n    LastName:             \"Allisonne\",\n    batchNumber:          \"123454321\",\n    countryOfVaccination: \"US\",\n}\nvalues, _ := json.Marshal(valuesStruct)\n\n// Issue credential\nissueResponse, _ := credentialService.IssueFromTemplate(context.Background(), &amp;credential.IssueFromTemplateRequest{\n    TemplateId: createdTemplate.Id,\n    ValuesJson: string(values),\n})\n\nissuedCredential := issueResponse.DocumentJson\n</code></pre>   <pre><code># Prepares values for credential\nvalues = JSON.generate({ firstName: 'Allison', lastName: 'Allisonne', batchNumber: '123454321',\n                         countryOfVaccination: 'US' })\n\n# Issue credential\nissue_response = credential_service.issue_from_template(Trinsic::Credentials::IssueFromTemplateRequest.new(\n                                                          template_id: template.id, values_json: values\n                                                        ))\ncredential = issue_response.document_json\n</code></pre>     <p>Further Reading: Issuance and Credentials</p> <ul> <li>Learn more about Verifiable Credentials</li> <li>Browse the Credential API reference</li> </ul>","title":"Issue a Credential"},{"location":"walkthroughs/vaccination/#send-credential-to-allison","text":"<p>Now that the clinic has a signed credential, it must be securely transmitted to Allison, so she can store it in her wallet.</p> <p>Because it's just a JSON string, it could be delivered in many ways -- for example, in the response to an HTTPS request which triggered the issuance process.</p>  <p>Send via Trinsic</p> <p>In the future, we will offer the ability to send a credential directly to a Trinsic user's wallet.</p> <p>Click here to learn more about this feature.</p>","title":"Send Credential to Allison"},{"location":"walkthroughs/vaccination/#store-credential-in-wallet","text":"<p>Once Allison receives the credential, it must be stored in her wallet.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic config --auth-token $(cat allison.txt)\ntrinsic wallet insert-item --item credential.json\n</code></pre>   <pre><code>// Alice stores the credential in her cloud wallet.\nwalletService.options.authToken = allison;\nconst insertResponse = await walletService.insertItem(\n  InsertItemRequest.fromPartial({\n    itemJson: issueResponse.documentJson,\n  })\n);\n</code></pre>   <pre><code>var walletService = new WalletService(_options);\n\n// Set active profile to 'allison' so we can manage her cloud wallet\nwalletService.Options.AuthToken = allison;\n\n// Insert credential into Allison's wallet\nvar insertItemResponse = await walletService.InsertItemAsync(new() {\n    ItemJson = signedCredential\n});\n\nvar itemId = insertItemResponse?.ItemId;\n</code></pre>   <pre><code># Allison stores the credential in her cloud wallet\nwallet_service.service_options.auth_token = allison\n\ninsert_response = await wallet_service.insert_item(\n    request=InsertItemRequest(item_json=credential)\n)\n\nitem_id = insert_response.item_id\n</code></pre>   <pre><code>// Set active profile to 'allison' so we can manage her cloud wallet\nwalletService.setProfile(allison);\n\n// Allison stores the credential in her cloud wallet.\nvar insertItemResponse =\n    walletService\n        .insertItem(\n            UniversalWalletOuterClass.InsertItemRequest.newBuilder()\n                .setItemJson(credential)\n                .build())\n        .get();\n\nfinal var itemId = insertItemResponse.getItemId();\n</code></pre>   <pre><code>// Allison stores the credential in her cloud wallet\nwalletService.SetToken(allison)\ninsertResponse, _ := walletService.InsertItem(context.Background(), &amp;wallet.InsertItemRequest{ItemJson: issuedCredential})\n\nitemId := insertResponse.ItemId\n</code></pre>   <pre><code># Allison stores the credential in her cloud wallet\nwallet_service.auth_token = allison\ninsert_response = wallet_service.insert_item(Trinsic::Wallet::InsertItemRequest.new(item_json: credential))\nitem_id = insert_response.item_id\n</code></pre>    <p>The response to this call contains an Item ID; copy this down.</p>  <p>Further Reading: Wallets</p> <ul> <li>Learn more about Wallets</li> <li>Browse the Wallet API reference</li> </ul>","title":"Store Credential in Wallet"},{"location":"walkthroughs/vaccination/#create-a-proof-of-vaccination","text":"<p>Before boarding, the airline requests proof of vaccination from Allison. Specifically, they want to see proof that she holds a <code>VaccinationCertificate</code> credential.</p> <p>Let's use the CreateProof call to build a proof for Allison's held credential.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic config --auth-token $(cat allison.txt)\ntrinsic vc create-proof --item-id \"{ITEM_ID}\" --out proof.json\n</code></pre>   <pre><code>// Allison shares the credential with the venue.\ncredentialService.options.authToken = allison;\nconst proofResponse = await credentialService.createProof(\n  CreateProofRequest.fromPartial({\n    itemId: insertResponse.itemId,\n  })\n);\n</code></pre>   <pre><code>// Set active profile to 'allison' so we can create a proof using her key\ncredentialService.Options.AuthToken = allison;\n\n// Build a proof for the signed credential\nvar proofResponse = await credentialService.CreateProofAsync(new() {\n    ItemId = itemId\n});\n\nvar proofJSON = proofResponse?.ProofDocumentJson;\n</code></pre>   <pre><code># Allison shares the credential with the airline\ncredential_service.service_options.auth_token = allison\n\nproof_response = await credential_service.create_proof(\n    request=CreateProofRequest(item_id=item_id)\n)\n\ncredential_proof = proof_response.proof_document_json\n</code></pre>   <pre><code>// Set active profile to 'allison' so we can create a proof using her key\ncredentialService.setProfile(allison);\n\n// Allison shares the credential with the venue\nvar createProofResponse =\n    credentialService\n        .createProof(\n            VerifiableCredentials.CreateProofRequest.newBuilder().setItemId(itemId).build())\n        .get();\n\nvar credentialProof = createProofResponse.getProofDocumentJson();\n</code></pre>   <pre><code>// Allison shares the credential with the airline\ncredentialService.SetToken(allison)\nproofResponse, _ := credentialService.CreateProof(context.Background(), &amp;credential.CreateProofRequest{\n    Proof: &amp;credential.CreateProofRequest_ItemId{ItemId: itemId},\n})\n\ncredentialProof := proofResponse.ProofDocumentJson\n</code></pre>   <pre><code># Allison shares the credential with the airline\ncredential_service.auth_token = allison\nproof_response = credential_service.create_proof(Trinsic::Credentials::CreateProofRequest.new(item_id: item_id))\ncredential_proof = proof_response.proof_document_json\n</code></pre>    <p>Allison sends this proof to the airline for them to verify.</p>  <p>Partial Proofs</p> <p>In this example, the proof is being created over the entire credential; all of its fields are revealed to the verifier.</p> <p>It is possible for the airline to send Allison a frame which requests only certain fields of the credential. The airline would not be able to see other fields of the credential, but cryptographic guarantees would still hold over the revealed fields.</p> <p>See the CreateProof reference for more information.</p>   <p>OpenID Connect for Presentation</p> <p>Trinsic offers an OpenID Connect service as an alternative flow for the exchange of a credential between a holder and a verifier.</p> <p>In this flow, a holder simply clicks a link (or scans a QR code), logs into their Trinsic cloud wallet, and selects a credential to share. </p>","title":"Create a Proof of Vaccination"},{"location":"walkthroughs/vaccination/#verify-proof","text":"<p>Once the airline receives the proof, they can use the VerifyProof call to ensure its authenticity.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic config --auth-token $(cat airline.txt)\ntrinsic vc verify-proof --proof-document proof.json\n</code></pre>   <pre><code>// The airline verifies the credential\ncredentialService.options.authToken = airline;\nconst verifyResponse = await credentialService.verifyProof(\n  VerifyProofRequest.fromPartial({\n    proofDocumentJson: proofResponse.proofDocumentJson,\n  })\n);\n</code></pre>   <pre><code>// Verify that Allison has provided a valid proof\nvar verifyResponse = await credentialService.VerifyProofAsync(new() {\n    ProofDocumentJson = proofJSON\n});\n\nbool credentialValid = verifyResponse?.IsValid ?? false;\n</code></pre>   <pre><code># The airline verifies the credential\ncredential_service.service_options.auth_token = airline\n\nverify_result = await credential_service.verify_proof(\n    request=VerifyProofRequest(proof_document_json=credential_proof)\n)\n\nvalid = verify_result.is_valid\n</code></pre>   <pre><code>credentialService.setProfile(airline);\n\n// Verify that Allison has provided a valid proof\nvar verifyProofResponse =\n    credentialService\n        .verifyProof(\n            VerifiableCredentials.VerifyProofRequest.newBuilder()\n                .setProofDocumentJson(credentialProof)\n                .build())\n        .get();\n\nboolean isValid = verifyProofResponse.getIsValid();\n</code></pre>   <pre><code>// The airline verifies the credential\ncredentialService.SetToken(airline)\nverifyResult, _ := credentialService.VerifyProof(context.Background(), &amp;credential.VerifyProofRequest{ProofDocumentJson: credentialProof})\nvalid := verifyResult.IsValid\n</code></pre>   <pre><code># The airline verifies the credential\ncredential_service.auth_token = airline\n\nverify_result = credential_service.verify_proof(\n  Trinsic::Credentials::VerifyProofRequest.new(proof_document_json: credential_proof)\n)\n\nvalid = verify_result.is_valid\n</code></pre>     <p>Interoperability</p> <p>The Verifiable Credentials and Proofs that Trinsic's platform produces are based on open standards.</p> <p>Although we use the VerifyProof call in this example, the proof could be verified using any standards-compliant software.</p>","title":"Verify Proof"},{"location":"walkthroughs/vaccination/#full-source-code","text":"TypescriptC#PythonJavaGoRuby   <p>This sample is available as <code>VaccineDemoShared.ts</code> in our SDK repository.</p>   <p>This sample is available as <code>VaccineWalkthroughTests.cs</code> in our SDK repository.</p>   <p>This sample is available as <code>vaccine_demo.py</code> in our SDK repository.</p>   <p>This sample is available as <code>VaccineDemo.java</code> in our SDK repository.</p>   <p>This sample is available as <code>vaccine_test.go</code> in our SDK repository.</p>   <p>This sample is available as <code>vaccine_demo.rb</code> in our SDK repository.</p>","title":"Full Source Code"},{"location":"walkthroughs/vaccination/#next-steps","text":"<p>Congratulations! If you've completed all the steps of this walkthrough, you've just created a mini ecosystem of issuers, verifiers, and holders all exchanging credentials. Depending on your goals, there are a couple of possible next steps to take. </p> <ul> <li>Try out a sample app</li> <li>Browse the Service Reference</li> <li>Read more about the key concepts and technologies at play</li> </ul>","title":"Next Steps"},{"location":"web/","text":"<p>The Trinsic Web SDK makes it easy to interact with the Trinsic API from any client-side web application. You can find the SDKs source on Github.</p>","title":"The Trinsic Javascript / Web SDK"},{"location":"web/#installation","text":"<p>Install the package for Node or Browser from npmjs.com </p> Install   <pre><code>npm i @trinsic/trinsic\n</code></pre>","title":"Installation"},{"location":"web/#create-new-project","text":"<p>Let's create a new console app that we will use to add our sample code</p> <pre><code>mkdir web-sample &amp;&amp; cd web-sample &amp;&amp; npm init\n</code></pre> <p>You can select all the defaults for the node project.</p> <p>Add the required dependencies</p> <pre><code>npm i @trinsic/trinsic-web\n</code></pre> <pre><code>npm i --save-dev http-server webpack webpack-cli\n</code></pre>","title":"Create new project"},{"location":"web/#configure-webpack","text":"<p>After installing the dependencies you'll need a configuration file for webpack. Create a file called webpack.config.js at the root of your project and then copy and paste this into that file <pre><code>const path = require('path');\n\nmodule.exports = {\n  mode: 'development',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, './src'),\n    filename: 'bundle.js',\n  }\n};\n</code></pre></p>","title":"Configure Webpack"},{"location":"web/#configure-webpack-for-react","text":"<p>If using React you may need to start your project with craco</p> <p>Install Craco <pre><code>npm i @craco/craco\n</code></pre></p> <p>Next change your react scripts in your package.json file <pre><code>\"scripts\": {\n-   \"start\": \"react-scripts start\",\n+   \"start\": \"craco start\",\n-   \"build\": \"react-scripts build\",\n+   \"build\": \"craco build\"\n-   \"test\": \"react-scripts test\",\n+   \"test\": \"craco test\"\n}\n</code></pre> Finally you will need to add a craco configuration file called <code>craco.config.js</code> and add the following:</p> <pre><code>// craco.config.js\n\nconst { addBeforeLoader, loaderByName } = require('@craco/craco');\n\nmodule.exports = {\n  webpack: {\n    configure: (webpackConfig) =&gt; {\n      const wasmExtensionRegExp = /\\.wasm$/;\n      webpackConfig.resolve.extensions.push('.wasm');\n\n      webpackConfig.module.rules.forEach((rule) =&gt; {\n        (rule.oneOf || []).forEach((oneOf) =&gt; {\n          if (oneOf.loader &amp;&amp; oneOf.loader.indexOf('file-loader') &gt;= 0) {\n            oneOf.exclude.push(wasmExtensionRegExp);\n          }\n        });\n      });\n\n      const wasmLoader = {\n        test: /\\.wasm$/,\n        exclude: /node_modules/,\n        loaders: ['wasm-loader'],\n      };\n\n      addBeforeLoader(webpackConfig, loaderByName('file-loader'), wasmLoader);\n\n      return webpackConfig;\n    }\n  }\n}\n</code></pre> <p>This allows react loaders to properly load in some of our needed .wasm files.</p>","title":"Configure Webpack for React"},{"location":"web/#set-up-website","text":"<p>Create a simple html page with a script tag referencing the webpack bundle that will be built after completing the sample code. Note that you will not have the bundle.js file yet because it will be generated from the index.js file you create.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;title&gt;Web Sample&lt;/title&gt;\n  &lt;meta charset=\"UTF-8\" /&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n  &lt;meta name=\"description\" content=\"\" /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Web Sample&lt;/h1&gt;\n  &lt;div id=\"wallet\"&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;script src=\"../bundle.js\"&gt;&lt;/script&gt;\n&lt;/html&gt;\n</code></pre> <p>Your file structure should look like this</p> <pre><code>web-sample\n    src\n        index.html\n        index.js\n    package.json\n    webpack.config.js\n</code></pre>","title":"Set up Website"},{"location":"web/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"}]}