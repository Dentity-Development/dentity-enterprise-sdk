{"config":{"indexing":"full","jieba_dict":null,"jieba_dict_user":null,"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Introduction"},{"location":"#issue-and-verify-universally-accepted-digital-credentials","text":"<p>Trinsic is the proof of anything platform. We make it easy for people and organizations to prove things about themselves with technology instead of paper documents. Our software is based on Decentralized Identifiers (DIDs) and Verifiable Credentials (VCs), a new digital identity standard. </p> <p>Using Trinsic, organizations and their customers share data between each other in a trustworthy, standardized, and privacy-preserving way without requiring a centralized server or database. </p> <p>We make all of this possible by signing, sharing and storing verifiable data within identity wallets owned by individuals. People can easily share them with others to prove things about themselves anywhere.</p> <p>Learn how to issue and verify universally-accepted digital credentials so that anywhere people go online or in-person, they can simply tap their phone, prove who they are, and get what they need.</p>","title":"Issue and verify universally-accepted digital credentials."},{"location":"#our-products","text":"","title":"Our Products"},{"location":"#trinsic-core","text":"<p>Trinsic Core is infrastructure for digital trust. It's our set of APIs for sending verifiable data between digital identity wallets. Core gives people and organizations the ability to easily and securely prove things about themselves with digital credentials.</p> <p>With Core, you can transform credentials, licenses, passes, and certificates into a W3C standard format that can be exchanged digitally and verified instantly by anyone called a \"verifiable credential\".</p>","title":"Trinsic Core"},{"location":"#trinsic-ecosystems","text":"<p>A layer built on top of Core, Trinsic Ecosystems is a product for organizations that want to build an ecosystem of different issuers, holders, and verifiers of credentials. By ecosystem, we mean a network of companies and consumers that need to be able to securely share and instantly verify data. </p> <p>At Trinsic, we call the organizations that bring together these ecosystems of companies and customers \"providers\", since they are providing digital trust to the ecosystem through Trinsic's infrastructure.</p>  <p>Get Started in 15 Minutes</p> <p>Want to get started using digital credentials quickly? Try our tutorial to get a conceptual walkthrough of a common use case.</p>","title":"Trinsic Ecosystems"},{"location":"early-adopter/","text":"<p>For development teams ready to integrate verifiable credentials for a specific industry or use case, Trinsic Ecosystems has been built specifically for you. We're currently in beta with a small group of customers.</p> <p>If you'd like to join the beta for Trinsic Ecosystems, please reach out! Simply fill out the form below, and we'll get in touch.</p> <p>Sign Up</p>","title":"Introducing Trinsic Ecosystems"},{"location":"roadmap/","text":"","title":"Roadmap"},{"location":"roadmap/#sdks","text":"","title":"SDKs"},{"location":"roadmap/#available-sdks","text":"<ul> <li> .NET</li> <li> Node</li> <li> Python</li> <li>:fontawesome-brands-js-square: Web</li> <li> Java</li> </ul>","title":"Available SDKs"},{"location":"roadmap/#coming-soon","text":"<ul> <li> Android</li> <li> iOS</li> <li> Go</li> <li> Ruby</li> </ul>","title":"Coming Soon"},{"location":"support/","text":"<p>Normally, the best way to ask quick questions is through the Trinsic Community slack channel.</p> <p>If you have a bug to report, please report it on the Github issues on our SDK. Contributions and additions to this docs site are always welcome.</p> <p>Finally, if you're interested in getting in touch with the team for any other reason, contact us at support@trinsic.id. We treat any feedback as gold.</p>","title":"Have a Question?"},{"location":"android/","text":"<p>The Trinsic Android sample application makes it easy to interact with the Trinsic API. The sample application is located here</p>","title":"Android Sample Application"},{"location":"android/#installation","text":"<ol> <li>Clone the <code>sdk-examples</code> repository</li> <li>Open the folder <code>sdk-examples/android</code> in Android Studio</li> <li>Run gradle build for the first time, it will take a while, but it should pull down all the required <code>.jar</code> files</li> <li>You should be able to build and run the android application.</li> <li>There is an <code>sdk-examples/android-controller</code> application written in Python which allows you to issue credentials/verify proofs outside of the android application for demonstration purposes.</li> </ol>  <p>Note</p> <p>If you want to included the two required Trinsic <code>.jar</code> files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p>  <pre><code>def urlFile = { url, name -&gt;\n    File file = new File(\"$buildDir/download/${name}.jar\")\n    file.parentFile.mkdirs()\n    if (!file.exists()) {\n        new URL(url).withInputStream { downloadStream -&gt;\n            file.withOutputStream { fileOut -&gt;\n                fileOut &lt;&lt; downloadStream\n            }\n        }\n    }\n    files(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\n    // other dependencies\n    implementation urlFile('https://github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0')\n    implementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1')\n}\n</code></pre>","title":"Installation"},{"location":"android/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Java API Reference</p>","title":"Next Steps"},{"location":"cli/","text":"<p>The Trinsic CLI makes it easy to interact with the Trinsic API from your terminal. You can get the CLI on homebrew or build the CLI from source on Github. It contains all the commands of Trinsic's SDKs and makes them interactive. </p>","title":"The Trinsic CLI"},{"location":"cli/#installation","text":"MacOS and LinuxWindowsFrom source   <p>We use homebrew to distribute the CLI packages for MacOS and Linux. Install Homebrew</p> <p>Then run these commands to install the Trinsic CLI <pre><code>brew tap trinsic-id/tap\nbrew install trinsic-cli\n</code></pre></p>   <p>The CLI can be installed using Winget <pre><code>winget install trinsic.okapi\nwinget install trinsic.cli\n</code></pre></p>   <p>The CLI can also be built from source.</p> <p>This requires the Rustup toolchain  installed on your system.</p> <p>Once installed, run this command in terminal:</p> <pre><code>cargo +nightly install --git https://github.com/trinsic-id/sdk trinsic\n</code></pre> <p>To verify that the CLI has been installed successfully, try running:</p> <pre><code>trinsic --help\n</code></pre>","title":"Installation"},{"location":"cli/#next-steps","text":"<p>Once the CLI is installed, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference. For more information about the CLI, read the configuration guide</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"},{"location":"cli/config/","text":"<p>The CLI stores its configuration in the user's home directory in <code>~/.trinsic/</code>. This directory contains the main configuration file <code>config.toml</code> and all the profile data.</p>","title":"Configuration"},{"location":"cli/config/#show-configuration","text":"<p>To print the current configuration file in the terminal use:</p> <pre><code>trinsic config --show\n</code></pre> <p>Typical configuration file may look like this:</p> <pre><code>[server]\naddress = \"https://prod.trinsic.cloud\"\n\n[profile]\ndefault = \"my_profile\"\n</code></pre>","title":"Show Configuration"},{"location":"cli/config/#update-configuration-entry","text":"<p>To change the configuration values, use the <code>config</code> subcommand with the attribute and its value.</p> <pre><code>trinsic config &lt;attribute_name&gt; &lt;attribute_value&gt;\n</code></pre> <p>The following attributes are currently supported:</p>  <code>server-address</code>  <p>Updates the default server address the CLI communicates</p> <pre><code>trinsic config --server-address https://example.com/\n</code></pre>  <code>profile-default</code>  <p>Updates the default profile used with the CLI</p> <pre><code>trinsic config --profile-default alice\n</code></pre>","title":"Update Configuration Entry"},{"location":"cli/demo/","text":"","title":"Trinsic CLI Demo"},{"location":"cli/demo/#steps-to-run","text":"<ul> <li>Click the green Run button</li> <li>Follow walkthrough</li> <li>Note: If you resize this window, make sure to reload the page. If not, the CLI will have display problems.</li> </ul>","title":"Steps to Run"},{"location":"dotnet/","text":"<p>The Trinsic C# / .NET SDK makes it easy to interact with the Trinsic API from your .NET application. The most recent version of the library can be found on NuGet. The Trinsic SDK supports .NET applications written in C#, VB.NET, and F# that utilize any supported version of .NET Core. You can also find the SDKs source on Github.</p>  <p>Supported runtimes</p> <p>.NET targets for iOS, Android, and Blazor are fully supported using the same package dependencies via .NET 6.</p>","title":"The Trinsic C# / .NET SDK"},{"location":"dotnet/#installation-in-a-new-project","text":"<p>Add the required dependencies from Nuget.org </p> Package Manager.NET CLIPackageReference   <pre><code>PM&gt; Install-Package Trinsic\n</code></pre>   <pre><code>dotnet add package Trinsic\n</code></pre>   <pre><code>&lt;PackageReference Include=\"Trinsic\" /&gt;\n</code></pre>","title":"Installation in a new project"},{"location":"dotnet/#configuration","text":"<pre><code>// trinsicServiceConstructor() {\nvar trinsic = new TrinsicService(_options);\n// }\n// accountServiceSignIn() {\nvar myProfile = await trinsic.Account.SignInAsync(new());\n// }\ntrinsic.SetAuthToken(myProfile);\n// accountServiceGetInfo() {\nvar info = await trinsic.Account.GetInfoAsync();\n// }\n</code></pre>","title":"Configuration"},{"location":"dotnet/#next-steps","text":"<p>Once the .NET SDK package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API C# API Reference</p>","title":"Next Steps"},{"location":"go/","text":"<p>The Trinsic Go SDK makes it easy to interact with the Trinsic API from any Go application. The most recent version of the library can be found on ____. You can find the SDKs source on Github.</p>","title":"The Trinsic Go SDK"},{"location":"go/#installation-and-configuration","text":"<ul> <li>NOTE: Windows installation is possible, but requires jumping through a few hoops. More details to come later.</li> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>You need to have CGO configured for the okapi native binary link</li> <li>Issue the following command: <pre><code>go install github.com/trinsic-id/sdk/go@latest\n</code></pre></li> <li>To test the installation, try the following go code:</li> </ul> <pre><code>trinsicService, err := sdk.NewTrinsic()\nif err != nil {\n    panic(\"Account service not created\")\n}\n\nprofile, err := trinsicService.Account().LoginAnonymous(context.Background())\nif err != nil {\n    panic(\"Sign in failed!\")\n}\nfmt.Printf(\"%v\\n\", profile)\n</code></pre>","title":"Installation and Configuration"},{"location":"go/#next-steps","text":"<p>Once the go package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Go API Reference</p>","title":"Next Steps"},{"location":"ios/","text":"<p>The Trinsic Swift SDK makes it easy to interact with the Trinsic API from any application built for iOS, MacCatalyst, or MacOS. The SDK is available for Swift Package Manager and can be added in your dependency section in <code>Package.swift</code> as follows:</p> <pre><code>dependencies: [\n    .package(name: \"Trinsic\", url: \"https://github.com/trinsic-id/sdk-swift\", branch: \"main\")\n],\n</code></pre> <p>You can find more details, source code, and tests for the Swift SDK at trinsic-id/sdk-swift.</p>","title":"The Trinsic Swift SDK"},{"location":"java/","text":"<p>The Trinsic Java SDK makes it easy to interact with the Trinsic API from any Java application. The most recent version of the package is found on the Github Release. You can find the SDKs source on Github.</p>","title":"The Trinsic Java SDK"},{"location":"java/#installation","text":"<ol> <li>Add the <code>urlFile</code> code shown below to your <code>build.gradle</code>.</li> <li>Add the implementations as shown below to your <code>build.gradle</code>.</li> <li>Run <code>gradle build</code> to download the required jar files. This can take some time.</li> </ol>","title":"Installation"},{"location":"java/#configuration","text":"<ol> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>LD_LIBRARY_PATH</code>, even on Windows.</li> </ol>  <p>Note</p> <p>If you want to included the two required Trinsic <code>.jar</code> files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p>  <pre><code>def urlFile = { url, name -&gt;\n    File file = new File(\"$buildDir/download/${name}.jar\")\n    file.parentFile.mkdirs()\n    if (!file.exists()) {\n        new URL(url).withInputStream { downloadStream -&gt;\n            file.withOutputStream { fileOut -&gt;\n                fileOut &lt;&lt; downloadStream\n            }\n        }\n    }\n    files(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\n    // other dependencies\n    implementation urlFile('https://github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0')\n    implementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1')\n}\n</code></pre>","title":"Configuration"},{"location":"java/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Java API Reference</p>","title":"Next Steps"},{"location":"learn/","text":"<p>Understand the key concepts of self-sovereign identity, learn about the specifics of working with the Trinsic platform, or work through our tutorials to learn how to build out specific functionality.</p>","title":"Learn"},{"location":"learn/migrate/","text":"<p>This document outlines the differences between our existing platform based on Hyperledger Aries and our next-gen identity infrastructure known as Ecosystems. The intended audience of this document is technical business decision makers or solution architects who are looking to migrate their existing integration. For everyone else, this can also be a good source of information with comparsion between the two platforms. Please feel free to reach out to us or ask any questions in our Slack Community channels.</p>","title":"Migration Guidelines"},{"location":"learn/migrate/#motivations-to-build-the-new-platform","text":"<p>Open standards and protocols \u2014 One of the critical decisions to create our new platform was the ability to use standardized data models. The Verifiable Credentials Data Model was an important milestone that standardized the data exchange format. The use of Decentralized Identifiers was another important step in building solutions that will work with community supported specifications. The tight coupling of Anoncreds with the wallet, communication, and ledger layers proved to be very challenging to iterate on. While projects like Anoncreds and DIDComm that started in Indy are now on a standards track, the success of our customers in production required prioritizing existing W3C, OIDC, and other standards first.</p> <p>Cryptographic suites performance and extensibility \u2014 To provide developers the best experience possible, we needed to be able to introduce different cryptographic schemes with a standardized model in order to support different data workflows. The Data Integrity and JOSE proof formats work well with the VC model and allow extensibility and use of different cryptographic suites.</p> <p>Scalability concerns and technology lock-in \u2014 Through rigorous testing, including with customers in production, we encountered concerning scalability issues with ledger throughput for Indy Node and the indy-sdk. The complexity introduced by requiring certain artifacts to be written to a specific ledger exasperated the problem. In addition, the inflexibility of the architecture of the open source implementations made it difficult to extend our platform or build customized experiences, and we found the efforts by the open source community to address these problems lacking.</p> <p>Ledger costs and transaction fees \u2014 The high costs to write data to production Indy ledgers, and the difficulty in forecasting those costs, was a significant barrier for many developers going to production. In addition, we found the centralized governance of existing production Indy ledgers to result in \"rug-pulls\", \"single points of failure\", and sustainability concerns that introduced additional risks for developers in building a business on those networks.</p> <p>Customized wallet experience \u2014 The developers in our community consistently wanted something the Aries-based platform couldn't provide--a platform for building a customized wallet experience for their end-users, whether in a standalone wallet product or embedded into an existing product. Strong wallet products need features like cross-device synchronization, multi-language SDK support, small SDK size, offline support, all while keeping the highest security standards. See our documentation on Wallets for more.</p>","title":"Motivations to build the new platform"},{"location":"learn/migrate/#who-should-consider-migration","text":"<ul> <li>Teams looking to manage their own identity data in the ecosystem</li> <li>Your solution requires support for ecosystem governance</li> <li>You are looking to use open standard and need interoperability with VC, JWT, or OIDC</li> <li>Teams looking to reduce transaction costs of writing to decentralized ledgers</li> <li>Developers looking to provide custom wallet experience or customized integration</li> </ul>","title":"Who should consider migration?"},{"location":"learn/migrate/#concepts-comparison","text":"<p>Direct comparsions of technical details between the two platforms may be enclosed in colored blocks as shown below:</p>  <p>Description of concepts as found in our existing platform</p>   <p>Description of concepts as found in our new platform</p>  <p>Let's take a deeper look of how different problems and concepts map between the existing and new platform.</p> <ul> <li>Organizations and Tenants</li> <li>Identity Wallets</li> <li>Ledgers and Decentralized Infrastructure</li> <li>Credential Formats</li> <li>Anoncreds vs BBS</li> <li>Revocation Registries</li> <li>Verification Workflows</li> </ul>","title":"Concepts Comparison"},{"location":"learn/migrate/#organizations-and-tenants","text":"<p>The concept of an organization (or tenant) as a top level scope of identity network is now represented as a more expanded concept of an ecosystem. Ecosystems represent your enterprise network as an established model of relationships between different entities. Providers define the contracts of how verifiable data can be exchanged and governed in an ecosystem. Individual holders of credentials will be assigned a wallet within the scope of an ecosystem.</p>  <p>Managed through Provider API endpoints</p>   <p>Managed through Provider Service SDK</p>","title":"Organizations and Tenants"},{"location":"learn/migrate/#identity-wallets","text":"<p>In our existing platform, our customers needed to choose between requiring end-users to download a standalone wallet to self-manage their credentials and keys on their mobile device, or use our Wallet API to create a purely custodial service. The former had the security advantage of all private material being stored on the user's device, but comes with the cost of backup &amp; recovery questions, inability to access data from secondary devices/browers, and difficulty embedding into existing applications. The latter afforded a fantastic developer experience (indeed, 95% of developers chose this option to ship products quickly) but introduced a less-than-ideal security profile, and was inaccessible in an offline setting.</p> <p>Our new platform uses hyrbid wallets with cloud-hosted credential storage and edge-managed access security through our SDK. Wallet data is accessed through our new API which allows developers to take advantage of a great experience building their own wallet-enabled products as a web app, mobile app, etc.  without compromising on security or offline usage. Custodial wallets also allow us to support more standards and interoperability profiles, leading to better products for our customers.</p>  <p>Future considerations</p> <p>We are actively working to improve the features of our hybrid wallet experience with things like encrypted query/search and the ability to export wallet data to remove lock-in for users.</p>","title":"Identity Wallets"},{"location":"learn/migrate/#ledgers-and-decentralized-infrastructure","text":"<p>Our existing platform uses decentralized ledgers based on Indy Node to store credential artifacts in a public network. These artifacts include DIDs, Schemas, Credential Definitions and Revocation Registries. The instances of Indy networks we supported includes Sovrin, Indicio and BCovrin, for production and test workloads.</p> <p>The new platform uses decentralized ledgers or blockchains for DIDs only. Schemas and revocation registries use web infrastructure and are published at a well known URL address. The need for credential definitions is removed thanks to improved credential signature schemes. The new platform is built independent of a single network, thus being truly ledger agnostic. Currently supported networks for DIDs are Bitcoin (using layer 2 protocol Sidetree), Indy, EBSI, with more to come. </p>  <ul> <li>Indy Node based</li> <li>Supported networks: Sovrin, Indicio, BCovrin</li> </ul>   <ul> <li>Self-asserting identifiers</li> <li>Bitcoin layer 2 using Sidetree</li> <li>Indy Node based</li> <li>EBSI</li> </ul>","title":"Ledgers and Decentralized Infrastructure"},{"location":"learn/migrate/#credential-formats","text":"<p>Credential formats were generally represented as a collection of attributes defined with a schema and version. The schemas were represented with a schema ID like <code>Gs6cQcvrtWoZKsbBhD3dQJ:2:Certificate of Attendance:2.0</code>. This schema contains attributes and is associated with a transaction on the ledger. The flat schemas do not support any heirarchy, severely limiting the use cases they are suited for.</p> <p>Under the new model, schemas are part of a credential template and are represented as a standard JSON schema where each attribute can be defined with a specific data type and extended properties. Additionally, templates reference a JSON-LD vocabulary which adds semantic definition of each attribute under the Linked Data guidelines. This vocabulary is used during the process of issuance and verification of credentials, technically known as data canonicalization. The schemas are not written on a ledger, they are instead published as a web resource with a static URL.</p>  <ul> <li>Schemas are represented as JSON array of attribute names</li> </ul> <pre><code>{\n    \"name\": \"Identity Card\",\n    \"version\": \"1.0\",\n    \"attr_names\": [\n        \"firstName\",\n        \"lastName\",\n        \"dateOfBirth\"\n    ]\n}\n</code></pre> <ul> <li>Credential definitions are required and their value must be written on the ledger</li> <li>Data structure supports flat hierarchy</li> <li>Schema ID is identifier <code>Gs6cQcvrtWoZKsbBhD3dQJ:2:Certificate of Attendance:2.0</code></li> </ul>   <ul> <li>Schemas are JSON objects</li> </ul> <pre><code>{\n    \"id\": \"https://schema.trinsic.cloud/default/identity-card\",\n    \"properties\": {\n        \"firstName\": { \"type\": \"string\", \"description\": \"First or given name\" },\n        \"lastName\": { \"type\": \"string\", \"description\": \"Last or family name\" },\n        \"dateOfBirth\": { \"type\": \"datetime\", \"description\": \"Date of birth\" },\n    }\n}\n</code></pre> <ul> <li>No credential definition required</li> <li>Data structure can be any complex JSON graph</li> <li>Schema ID is URL <code>https://schema.trinsic.cloud/default/identity-card</code></li> </ul>","title":"Credential Formats"},{"location":"learn/migrate/#anoncreds-vs-bbs","text":"<p>Our existing platform uses the cryptographic suite Anoncreds to provide different credential exchange solutions. In our new platform, we introduced BBS signatures, as a replacement for Anoncreds. The main motivating factors for this are:</p> <ul> <li>Standardized data models for the signature suites using JSON Schema and Verifiable Credentials</li> <li>Fast and small signature size (cryptographic signatures based on pairing-friendly curves)</li> <li>No setup required (Anoncreds require creating credential definition which is very slow and requires ledger write)</li> <li>Flexible proof format (Data Integrity, JOSE)</li> </ul>","title":"Anoncreds vs BBS"},{"location":"learn/migrate/#revocation-registries","text":"<p>Revocation in our existing platform uses Anoncreds with RSA accumulator. This is a powerful, privacy preserving solution, but cumbersome when it comes to maintaining accumulator states. It requires publishing revocation registry state on the ledger, writing to the ledger whenever credentials are revoked, publishing a tails file on a web resource, and layering workarounds on top to make it all scalable. Even after all of this, the performance of holders creating non-revocation proofs was below an acceptable level for production use. </p> <p>Our new platform uses a more flexible solution based on Status List. This approach is based on a W3C community published specification with a much simpler and flexible approach to revocation, albeit without the same privacy guarantees.</p>  <p>Future considerations</p> <p>At the time of writing this article, we are actively looking to add support for additional revocation solutions, such as one based on accumulators for pairing-friendly curves. These are significant improvements over RSA accumulators with an improvement in data privacy, performance and scalability.</p>","title":"Revocation Registries"},{"location":"learn/migrate/#verification-workflows","text":"<p>In our existing platform we use Aries protocols to exchange data between two parties. To verify a credential, the verifier must prepare a verification request and communicate this to the user via URL (or QR code). The holder then resolves the URL (or scans the code) to respond to the request, most often through use of a mobile app.</p> <p>Our new platform is intended to support a broader set of verification options for developers, including widely-adopted protocols such as OpenID Connect. Today we support an interactive protocol based on OpenID for Verifiable Presentations (OIDC4VP). During verification, the holder is redirected to Trinsic's OIDC provider (which can be customized on a per-ecosystem basis) which allows the user access to their identity wallet to respond to the verification request. We'll continue to support additional verification protocols as they're needed by our customers to succeed in production.</p>  <p>An example verification request payload</p> <pre><code>{\n    \"name\": \"verification-request\",\n    \"version\": \"1.0\",\n    \"attributes\": [{\n        \"policyName\": \"verify-name\",\n        \"attributeNames\": [ \"firstName\" ],\n        \"restrictions\": [{\n            \"issuerID\": \"string\"\n        }]\n    }],\n    \"predicates\": [],\n    \"revocationRequirement\": {\n        \"validNow\": true\n    }\n}\n</code></pre>   <p>Example OIDC request for verifiable presentation</p> <pre><code>GET https://connect.trinsic.cloud/authorize?\n    &amp;response_type=code\n    &amp;scope=openid\n    &amp;client_id=client01\n    &amp;trinsic%3Aecosystem=example\n    &amp;redirect_uri=https://example.com/callback\n    &amp;nonce=n-0S6_WzA2Mj HTTP/1.1\n</code></pre>","title":"Verification Workflows"},{"location":"learn/migrate/#whats-next","text":"<p>If you're looking to do a migration and need help, please drop us a line on Slack or Intercom. Otherwise, feel free to explore our documentation, try the Getting Started guide or watch an introductory video.</p>","title":"What's next?"},{"location":"learn/concepts/credentials/","text":"<p></p> <p>\"Verifiable Credentials\", or \"VCs\" are digital documents that conform to the W3C Verifiable Credential Data Model. VCs provide a standard for digitally issuing, holding, and verifying data about a subject. A verifiable credential is a set of tamper-evident claims and metadata that cryptographically prove who issued it.  https://www.w3.org/TR/vc-data-model/</p> <p>Verifiable credentials are unique from other kinds of digital documents because they enable you to verify the following things: </p> <ol> <li>The original issuing entity (the source of the data) </li> <li>It was issued to the entity presenting it (the subject of the data) </li> <li>It hasn't been tampered with (the veracity of the data)</li> <li>Whether the issuer revoked the credential as of a particular point in time (the status of the data)</li> </ol> <p>trust triangle</p>","title":"What are Verifiable Credentials"},{"location":"learn/concepts/credentials/#components-of-a-credential","text":"<p>To break down the components of a credential, we'll use a digital driver's license as an example.</p>","title":"Components of a Credential"},{"location":"learn/concepts/credentials/#issuer-did","text":"<p>As you can see from the diagram above, a verifier will only accept a credential if they trust its source. For example, in the United States a TSA agent will only let you on an airplane if you present a valid driver's license (or other gov ID); they do this because they trust the DMV or other agency that issued it. In order to validate where a credential came from, verifiers use the issuer's DID.</p> <p>Each new issuer is assigned an issuer DID. The issuer DID acts as a public-facing address or public key. In self-sovereign identity, these DIDs are usually written to a public blockchain, but other locations are possible, too. Each issuer DID has an associated private key which is used to cryptographically \"sign\" each issued credential. In fact, each attribute inside the credential is signed in this manner, allowing the holder of the credential to share only a subset of the attributes when desired. For example, someone could share their name and age from their driver's license without sharing the driver's license number, address, and hair color. Using the issuer DID and straightforward public-private key cryptography, anyone can verify the attributes in the credential were attested to by the issuer. </p>","title":"Issuer DID"},{"location":"learn/concepts/credentials/#schema","text":"<p>Each credential needs a template so the data can be shared and interpreted correctly. That template is called a Schema.</p> <p>Schemas are the general structure of the credential. In our example, they tell us what information must be included on the driver's license in order for it to be valid, like Full name, Address, Eye color, etc. </p> <p>In short, they are the attributes that you want to include in this credential.</p>","title":"Schema"},{"location":"learn/concepts/credentials/#example","text":"<pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"description\": \"Email\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"emailAddress\": {\n            \"type\": \"string\",\n            \"format\": \"email\"\n            }\n        },\n    \"required\": [\"emailAddress\"],\n    \"additionalProperties\": false\n}\n</code></pre> <p>Schemas are nonproprietary; any issuer can view/use the schemas written by any other issuer.</p> <p>We abstract schema creation away into the same action as creation of a credential template. Keep reading to read how to create a schema and credential template. </p>","title":"Example:"},{"location":"learn/concepts/credentials/#verifications","text":"<p>Passes are documents generated from credentials that contain only the information required to be verified. They can be generated in advance or in real-time. Passes minimize the information about you that is shared with third parties.</p> <p>Credentials are signed using BLS keys. These create from the credential fields. </p>","title":"Verifications"},{"location":"learn/concepts/ecosystems/","text":"<p>Exchanging credentials often requires many different participants to all communicate and collaborate. Aligning standards and incentives is challenging. </p> <p>We've made it simple to create an ecosystem of participants to all exchange credentials. </p>","title":"Ecosystems"},{"location":"learn/concepts/ecosystems/#potential-scenarios","text":"<p>Industry groups, enterprises, and startups who are deploying this technology to multi-party ecosystems. Our focus on building for interoperability, hyper-scalability, and ease of use means you can get to market faster with a better product with Trinsic than any other way. </p> <p>Trust ecosystems are networks of participants that can authenticate to and share data with one another. Trust ecosystems exist all around us, but most are analog and disaggregated. The first trust ecosystems to go digital were payments networks. Visa, MasterCard, etc. introduced a standard mechanism to allow consumers to make purchases with any merchant using credit from any bank. Visa created an enduring business while simultaneously unlocking value for all participants involved.</p> <p>Credit card networks represent only one kind of trust ecosystem. A trust ecosystem at a minimum has the following 4 roles.</p> <ul> <li>Provider - provides the tools and rules to the rest of the participants to ensure a healthy ecosystem, generally through a product experience that is sold to the other participants</li> <li>Issuer - is the source of data that is shared throughout an ecosystem</li> <li>Verifier - consumes data in an ecosystem</li> <li>Holder - holds data, and is generally the subject of the data, in an ecosystem</li> </ul>","title":"Potential Scenarios"},{"location":"learn/concepts/ecosystems/#anatomy-of-a-trust-ecosystem","text":"<p>Before diving into the value provided by each participant, it\u2019s helpful to cover how it works at a high level. You may dive deeper into any of these items by clicking into the respective pages. We\u2019ll use the analogy of a payment network to conceptualize the purpose of each component.</p> <p>Wallet - A place to securely store verifiable credentials.</p> <p>Credential - W3C Verifiable Credentials that contain valuable data about a subject. These are signed and issued by an issuer.</p> <p>Pass - A presentation of a verifiable credential that only includes the information required for use case.</p> <p>Underlying Tech - All of the additional standardized technology Trinsic uses to build trust ecosystems.</p>","title":"Anatomy of a Trust Ecosystem"},{"location":"learn/concepts/ecosystems/#value-of-trust-ecosystems-to-participants","text":"<p>The first step to successfully building a trust ecosystem that can scale is to identify the value for each of the participants. Here we will elaborate on the value derived by each actor in an ecosystem and how Trinsic\u2019s platform is optimized to help deliver it.</p>","title":"Value of Trust Ecosystems to Participants"},{"location":"learn/concepts/ecosystems/#providers","text":"<p>Providers typically already have, or are building, a product or platform to sell to the issuers and verifiers with the goal of creating a sustainable business. </p> <p>Visa, for example, isn\u2019t a currency, a bank, or a merchant. They sell the rails for transaction settlement to banks and merchants to enable the seamless transactions we all enjoy. By taking a small interchange fee, they capture value alongside the banks and merchants and have built a sustainable business.</p> <p>Trinsic is the only company to offer a product tailored specifically for providers. That means instead of patching together various open source components meant for issuers or verifiers, Trinsic offers a product built from the ground-up to accommodate the unique needs of providers. Ultimately, that means providers using Trinsic get to market faster with better products.</p>","title":"Providers"},{"location":"learn/concepts/ecosystems/#issuers","text":"<p>Issuers realize value when they extend or augment their existing business operations. By issuing the data they already have in verifiable credential form, they often can increase revenue, reduce verification costs, and improve brand presence. </p> <p>When credit cards were in their infancy, banks began issuing cards because it allowed them to continue their existing business (giving credit) in a new way. Likewise, the issuers that get the most value from verifiable credentials are ones who already have data about people, and simply need to give it to them in a new way (e.g. medical labs who already give paper documents can now give digital form).</p> <p>Trinsic\u2019s platform is optimized to both reduce onboarding costs and add help issuers scale without increasing their costs</p> <ul> <li>Before credit cards banks could offer various consumer loans</li> </ul>","title":"Issuers"},{"location":"learn/concepts/ecosystems/#holders","text":"<p>Holders acquire the most convenient way to prove something about themselves digitally, both in-person and online</p> <ul> <li>Before credit cards, consumers needed to pay with paper. Paying with credit meant bespoke processes with each individual retailer (e.g. opening a tab at a bar, creating a Macy\u2019s account, etc). Likewise today our digital identities are all siloed and separate, resulting in a myriad of problems for consumers.</li> </ul>","title":"Holders"},{"location":"learn/concepts/ecosystems/#verifiers","text":"<p>Verifiers get instant, trusted authentication and verification without needing to maintain their own infrastructure</p> <ul> <li>Before credit card networks like Visa, merchants needed to issue credit and manage collections in-house if they wanted customers who could buy on credit. Likewise, companies in virtually every industry have compliance, risk, and identity departments where they manage this in-house. Just as Visa turned electronic payments into a simple terminal installation for merchants, so too will trust ecosystems unlock the ability for verifiers of all kinds to focus on their true business without compromising on trust and security.</li> </ul> <p>Like the internet itself, trust over IP represents a massive business opportunity for innovators in all industries. And like the internet itself, the vast majority of the value will be created at the application layer.</p>","title":"Verifiers"},{"location":"learn/concepts/standards/","text":"","title":"Underlying Tech"},{"location":"learn/concepts/standards/#linked-data","text":"<p>When we consider credentials getting exchanged online far and wide, a problem starts to occur - how does everyone know what everyone else means when they show a credential? To the rescue comes Linked Data, a format for representing structured data with self-contained descriptors of that data.</p> <p>\"Linked data is to spreadsheets and databases what the web of hypertext documents is to word processor files\" - W3C Wiki on Linked Data</p>","title":"Linked Data"},{"location":"learn/concepts/standards/#decentralized-identifiers","text":"<p>Taken from the Verifiable Credential Data Model, a decentralized identifier is \"a portable URL-based identifier, also known as a DID, associated with an entity. These identifiers are most often used in a verifiable credential and are associated with subjects such that a verifiable credential itself can be easily ported from one repository to another without the need to reissue the credential. An example of a DID is <code>did:example:123456abcdef</code>\"</p>","title":"Decentralized Identifiers"},{"location":"learn/concepts/standards/#zero-knowledge-proofs","text":"<p>One of the most exciting qualities of verifiable credentials are their ability to minimize the data shared about you when you prove who you are. The classic example is showing your driver's license in a bar. While a human bouncer may forget all the revealing information on your driver's license, a computerized bouncer that scans your driver's license never forgets any information. With zero knowledge proofs, you can choose specific information from your credentials to share with verifiers.</p> <p>These are enabled through a BBS+ Signature specification.</p>","title":"Zero Knowledge Proofs"},{"location":"learn/concepts/trust-registries/","text":"<p>In many real-world credential exchange scenarios, a credential holder or verifier has the question \u201cHow do I know the issuer of this credential is trustworthy?\u201d</p> <p>Credential holders may also be uneasy about sharing information with a verifier if trust in the verifier has not been established.</p> <p>These problems can be solved by having a trusted third party vouch for the trustworthiness of a credential exchange participant.</p> <p>A trust registry is a list of authorized issuers and verifiers in the ecosystem and the types of credentials and passes they are authorized to issue and verify.</p>","title":"Trust Registries"},{"location":"learn/concepts/trust-registries/#specification","text":"<p>The Trust over IP Foundation has a specification for an interoperable trust registry. </p> <p>Our implementation is based off of this spec.</p>","title":"Specification"},{"location":"learn/platform/intro/","text":"<p>Trinsic is a hosting provider for identity wallets and an SDK for developers that want to interact with them. You can use Trinsic to give your end-users identity wallets and then share, store, and verify data through them.</p>","title":"What is Trinsic?"},{"location":"learn/platform/intro/#wallets","text":"<p>Identity Wallets are secure, partitioned data stores for information that needs to get verified. This normally is a person, but it can also be an organization or a device. </p> <p>You can use Trinsic's platform to invite end-users to create a cloud-hosted identity wallet that can be accessed on any device using multi-factor passwordless authentication. </p> <p>Once created, applications and organizations can issue data to the identity wallet. Other applications can request to verify information from the wallet. If the end-user accepts the request, a proof of the requested information will be created and sent to the requester. </p> <p>Using identity wallets, you can build powerful products that preserve your end-users' privacy without compromising on convenience.</p> <p>Wallet Service</p>","title":"Wallets"},{"location":"learn/platform/intro/#credentials-proofs","text":"<p>Trinsic's wallets are built to represent verifiable data as credentials. This allows any information sent to the identity wallet to be easily verified using interoperable standards. Because we follow a standardized open data model, identity wallets can bridge software platforms, letting individuals use their data wherever they choose. </p> <p>To minimize the amount of information that is requested from identity wallets, a credential's attributes can be filtered to generate a proof of the credential with only the data required to fulfill a verifier's request.</p> <p>Credential Service</p>","title":"Credentials &amp; Proofs"},{"location":"learn/platform/intro/#templates","text":"<p>Credential templates let you publish a credential format for others to follow. There are often more than one issuer of the same type of credential, and this allows issuers to reuse the same credential format and share the same attribute types. </p> <p>When data models can be reused, more interoperability can be achieved between different systems. This lets data that previously had to be manually entered via form or sent via custom API integration get automatically exchanged and verified without needing human interaction. </p> <p>Template Service</p>","title":"Templates"},{"location":"learn/platform/intro/#trust-registries","text":"<p>A trust registry is a way for a wallet to publish a list of other wallets that it trusts to issue and verifier credentials. </p> <p>This is useful when building trust without a centralized service or database. If you onboard wallets, it is likely that the wallet holders already have a connection with you. You can publish a list of issuers and verifiers that you've also vetted and onboarded and the wallet holders can reference this list before receiving or sharing their information with another wallet.</p> <p>When verifying a credential, a verifier can cross-reference the issuer's identifier within the credential with a trust registry to ensure it was actually issued by an organization that they trust.</p> <p>Trust Registry Service</p>","title":"Trust Registries"},{"location":"learn/platform/intro/#ecosystems","text":"<p>When creating a product that uses identity wallets, it is useful to have the tools to onboard participants that want to either issue, store, or verify credentials. Trinsic Ecosystems is a set of tools built so you can invite participants to an ecosystem and configure their wallets for them. This makes it possible to quickly go live with a proof of concept or pilot without requiring your ecosystem participants to do any setup or integrations themselves.</p> <p>Provider Service</p>","title":"Ecosystems"},{"location":"learn/platform/intro/#open-standards","text":"<p>Trinsic's technology is all based on open web standards. Our goal is to promote a future of applications where identity and personal data is independent from applications. To meet this end, we use decentralized identifiers that can be generated and resolved without needing a centralized database. We also follow the data model for verifiable credentials so that data sent by one application can be presented at another without requiring a specific vendor. </p> <p>Learn More</p>","title":"Open Standards"},{"location":"learn/platform/intro/#security-and-privacy","text":"<p>As a hosting provider of identity wallets, we've recognized the need for strong security and privacy since before we started building. </p> <p>Our identity wallets are secured using zero knowledge authentication. No private keys are stored or processed on our servers. They are all generated locally by our SDKs. We do this using a lightweight zero-knowledge proof protocol. Even if an adversary were to intercept a payload, they would not be able to reuse the token to gain additional access to our system.</p> <p>Learn More</p>","title":"Security and Privacy"},{"location":"learn/platform/security/","text":"","title":"Security Infrastructure"},{"location":"learn/platform/security/#overview","text":"<p>Our cloud services are secured using a novel method of authentication based on zero-knowledge proofs . This approach allows us to introduce passwordless client authentication with improved security and user experience.</p> <p>Compared to traditional security methods that store users' credentials on the server, our approach relies on a one-time client/server negotiation without storing any user secrets on our servers. All secrets are stored with the user client and are entirely in their control. During authentication, users present proof of knowledge of these secret tokens, instead of the actual tokens. This proof is generated with each request and is unique for that request only.</p>","title":"Overview"},{"location":"learn/platform/security/#zero-knowledge-architecture","text":"<p>TODO: Comparison to traditional security models</p>","title":"Zero-knowledge Architecture"},{"location":"learn/platform/security/#oberon-auth-scheme","text":"<p>A succinct ZKP protocol for authentication. It works by using techniques similar to Identity-Based/Attribute-Based signatures.</p> <p>Oberon allows endpoints to issue multi-factor capable tokens to consumers who can prove their validity without disclosing the tokens themselves and without requiring email, SMS, or authenticator apps. Endpoints only need to store a single public key and not any tokens. An attacker that breaks into the server doesn't have any password/token files to steal and only would see a public key. The proof of token validity is only 256 bytes while the token itself is only 48 bytes. The issuing party and verifying servers can be separate entities.</p> <p>Crypto details for Oberon </p>","title":"Oberon Auth Scheme"},{"location":"learn/platform/security/#account-registration","text":"<p>The below diagram illustrates how client and server interact during the registration process and negotiate the data for authentication:</p> <pre><code>sequenceDiagram\n  actor Client\n  Client-&gt;&gt;Server: Register new account or ecosystem\n  Server--&gt;&gt;Client: Generated token\n  Note right of Server: Does not store token\n  opt\n    Note over Client: Apply multi-factor security&lt;br /&gt;using PIN, word phrase, HSM, etc.&lt;br /&gt;by cryptographically blinding&lt;br/&gt;the secret token\n    Client-&gt;&gt;Client: Token protection\n  end\n  Client-&gt;&gt;Client: Save token on client device</code></pre>","title":"Account Registration"},{"location":"learn/platform/security/#api-requests","text":"<p>The process of making authenticated API requests against the server involves generating a proof of knowledge and appending it to the request headers. This proof is:</p> <ul> <li>valid for a limited time only (order of milliseconds)</li> <li>unique and cannot be used twice (replay protection)</li> <li>bound to the current request payload (mitm protection)</li> </ul> <p>The diagram below illustrates the steps involved in generating proof and interacting with the server.</p> <pre><code>sequenceDiagram\n    actor U as Client\n    participant A as Server\n\n    U-&gt;&gt;U: Read Token\n    U-&gt;&gt;U: Generate proof of token\n    U-&gt;&gt;A: Make API Request\n    note right of U: Proof is added in 'Authorization' header\n\n    A-&gt;&gt;A: Check authorization\n\n    alt sucesss\n        A-&gt;&gt;A: Process request\n        A--&gt;&gt;U: Send response\n    else invalid proof\n        A--&gt;&gt;U: 401 Unauthorized\n    end</code></pre>","title":"API Requests"},{"location":"learn/platform/templates/","text":"<p>Trinsic's credential templates make it easy to define types of credentials and publish these types for multiple issuers all to use. Credential templates will create two things to include in a credential: a json schema and a json ld context. Templates remove all of that complexity and let you define a list of attributes along with the attribute types and descriptions. </p> <p>This an example of a list of attributes that would comprise a credential template: </p> <pre><code>{\n    \"name\": {\n        \"type\": \"string\",\n        \"description\": \"Name of the business\",\n    },\n    \"website\": {\n        \"type\": \"string\",\n        \"description\": \"More information about the business\"\n    },\n    \"rating\":{\n        \"type\": \"number\",\n        \"description\": \"rating on scale of 1-10\",\n        \"optional\": false\n    },\n    \"details\":{\n        \"type\": \"string\",\n        \"description\": \"An individual's last name\",\n        \"optional\": false\n    }\n}\n</code></pre> <p>This will create a Template that has the following structure: <pre><code>TemplateData {\n    id: \"urn:template:alices-local-guides:review\",\n    name: \"Review\",\n    version: 1,\n    fields: {\n        \"name\": TemplateField {\n            description: \"Name of the business\",\n            optional: false,\n            r#type: String,\n        },\n        \"rating\": TemplateField {\n            description: \"rating on scale of 1-10\",\n            optional: false,\n            r#type: Number,\n        },\n        \"details\": TemplateField {\n            description: \"An individual's last name\",\n            optional: false,\n            r#type: String,\n        },\n        \"website\": TemplateField {\n            description: \"More information about the business\",\n            optional: false,\n            r#type: String,\n        },\n    },\n    allow_additional_fields: true,\n    schema_uri: \"https://staging-schema.trinsic.cloud/__default/review\",\n    context_uri: \"https://staging-schema.trinsic.cloud/__default/review/context\",\n    ecosystem_id: \"__default\",\n    r#type: \"VerifiableCredential\",\n}\n</code></pre> You can view the <code>schema_uri</code> and the <code>context_uri</code> in the browser as raw json</p>","title":"Credential Templates"},{"location":"learn/platform/wallets/","text":"","title":"Wallets"},{"location":"learn/platform/wallets/#what-are-wallets","text":"<p>A wallet is a secure place to store credentials. You can create a wallet using the Trinsic CLI or SDK and begin using it to store and share credentials.  Wallet storage is scoped to a single person or subject. Each wallet has the capability to store and share credentials and proofs. A provider wallet can also define templates, create an ecosystem governance framework, and invite wallets to their ecosystem. </p> <p>Data wallets are meant to help individuals manage their digital credentials and cryptographic keys. </p>","title":"What are wallets?"},{"location":"learn/platform/wallets/#how-to-use-wallets-in-your-app","text":"<p>Instead of users creating accounts when they sign up for your app, users can instead connect their wallet. Because many users will be first-time wallet holders, if a user is signing up for your app and they don't have a wallet, we make it easy to create new wallets for your users with the <code>invite</code> command. Once you've invited a user to a wallet, they can enter the 2fa code to log in. </p> <p>You can give each of your end-users a wallet tied to their email address or phone number. </p>","title":"How to use wallets in your app"},{"location":"learn/platform/wallets/#wallet-architecture","text":"<p>While wallets are hosted on our server, your client application must connect with the wallet (using device stored keys). Wallet communication is peer to peer. </p> <p>Wallets can be thought of a little like an email inbox. Each wallet can only be accessed by a set of keys stored on devices. </p>","title":"Wallet Architecture"},{"location":"learn/platform/wallets/#commands","text":"<ul> <li>Store Item</li> <li>Search</li> <li>Send</li> </ul>","title":"Commands"},{"location":"learn/platform/webhooks/","text":"","title":"Webhooks"},{"location":"learn/platform/webhooks/#overview","text":"<p>Webhooks enable providers to receive updates whenever an event occurs within the ecosystem they manage.</p>","title":"Overview"},{"location":"learn/platform/webhooks/#configuring-webhooks","text":"<p>Webhooks may be added to an ecosystem using the AddWebhook method; either with the CLI or any of our SDKs. In the future, webhooks will also be configurable through a web dashboard.</p> <p>The value chosen for <code>secret</code> should be a UTF-8 string which is never published anywhere; it is used to verify incoming payloads.</p> <p>The <code>destination_url</code> of a webhook must be an HTTPS URL accessible over the internet.</p>  <p>Event Type Filtering</p> <p>By default, webhooks receive all event types, but can be configured to only trigger on a specific subset of events.</p>","title":"Configuring Webhooks"},{"location":"learn/platform/webhooks/#receiving-webhooks","text":"<p>Webhooks are sent as JSON strings to your specified URL (which must be HTTPS) using the <code>POST</code> method. </p>","title":"Receiving Webhooks"},{"location":"learn/platform/webhooks/#structure","text":"<p>The structure of a webhook payload is shown below. Event-specific information is stored in <code>data</code>; its format is event-specific.</p>    Field Type Description     id <code>string</code> The ID of the event which triggered the webhook   timestamp <code>timestamp</code> The timestamp of the event   type <code>string</code> The type of event contained in <code>data</code>   data <code>object</code> The data of the event itself","title":"Structure"},{"location":"learn/platform/webhooks/#verification","text":"<p>Because webhooks are URLs accessible over the internet, it is necessary to ensure that a webhook comes from Trinsic and not an attacker.    </p> <p>Trinsic hashes payloads using HMAC-SHA256, using the <code>secret</code> you provided during webhook creation as the secret key, and the raw <code>POST</code> body as the message contents.</p> <p>This hash is sent with the request as a header named <code>trinsic-signature-sha256</code>.</p> <p>Your verification code may look like the following pseudocode:</p> Pseudocode   <pre><code>message = http_request.post_body\ntrinsic_hash = http_request.headers[\"trinsic-signature-sha256\"]\n\ncomputed_hash = hmac_sha256(message, stored_secret)\n\nif(trinsic_hash != computed_hash) {\n    // Hash failed verification. This is not a genuine webhook from Trinsic.\n}\n</code></pre>     <p>Use a library</p> <p>It is highly recommended that you use a library to compute and verify HMACs.</p> <p>Many languages have native support for HMAC-SHA256; for those that don't, high-quality open source libraries exist.</p>","title":"Verification"},{"location":"learn/platform/webhooks/#enabling-wallet-events","text":"<p>Events which occur on a wallet will not be sent to your webhooks unless the wallet holder has opted in.</p> <p>To receive webhooks for wallet events, the AuthorizeWebhook method must be called for each wallet which is opting-in to propagate wallet events to the ecosystem provider.</p> <p>This call must be performed using the wallet's authentication token.</p>","title":"Enabling Wallet Events"},{"location":"learn/platform/webhooks/#event-types","text":"<p>For a list of all event types and their structures, see the Events Reference page.</p>","title":"Event Types"},{"location":"node/","text":"<p>The Trinsic Node SDK makes it easy to interact with the Trinsic API from any backend javascript application. The most recent version of the library can be found on npm. You can find the SDKs source on Github.</p>","title":"The Trinsic Javascript / Node SDK"},{"location":"node/#installation","text":"<p>Install the package for Node from npmjs.com </p> Install   <pre><code>npm i @trinsic/trinsic\n</code></pre>","title":"Installation"},{"location":"node/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference.</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"},{"location":"python/","text":"<p>The Trinsic Python SDK makes it easy to interact with the Trinsic API from any Python application. The most recent version of the library can be found on PyPi. You can find the SDKs source on Github.</p>","title":"The Trinsic Python SDK"},{"location":"python/#installation-and-configuration","text":"<ul> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>LD_LIBRARY_PATH</code>, even on Windows.</li> <li>Recommended: Create a virtual environment</li> <li>Install the trinsic package <pre><code>pip install trinsic-sdk\n</code></pre></li> <li> <p>Test installation by running the following shell command: <pre><code># May be \"python\" or \"python3\" depending on your install\npython -m trinsic\n</code></pre></p> </li> <li> <p>The output should look something like this: <pre><code>Package successfully installed. Sample profile below\n</code></pre></p> </li> </ul>","title":"Installation and Configuration"},{"location":"python/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Python API Reference</p>","title":"Next Steps"},{"location":"reference/","text":"<p>This section serves as the reference for the Trinsic API, which can be accessed using any of our SDKs.</p>","title":"Overview"},{"location":"reference/#authentication","text":"","title":"Authentication"},{"location":"reference/#auth-tokens","text":"<p>Authentication with the Trinsic platform uses auth tokens, which are strings that operate similarly to API keys.</p> <p>Unlike API keys, however, Trinsic utilizes zero-knowledge proofs to sign SDK calls using an auth token, without ever transmitting the auth token itself down the wire. This provides increased security compared to API keys, while being more convenient than other auth schemes, such as public/private tokens.</p>","title":"Auth Tokens"},{"location":"reference/#custom-protection-of-auth-tokens","text":"<p>We provide helper methods to protect auth tokens -- enabling you to perform custom security operations. An auth token, once protected with a code, is unusable until unprotected with that same code. Protection and unprotection are performed entirely on-device.</p>","title":"Custom Protection of Auth Tokens"},{"location":"reference/#using-auth-tokens-in-the-sdk","text":"<p>Whenever you perform an SDK call which returns an auth token (signing in to an account, or creating an ecosystem), our SDKs will automatically store the auth token in memory and use it for subsequent calls.</p> <p>You can also manually set the auth token used by the SDK (such as when loading an auth token from storage):</p> Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic config --auth-token {AUTH_TOKEN}\n</code></pre>   <pre><code>trinsic.options.authToken = authToken;\n</code></pre>   <pre><code>trinsic.SetAuthToken(authToken);\n</code></pre>   <pre><code>trinsic.service_options.auth_token = auth_token\n</code></pre>   <pre><code>trinsic.SetAuthToken(authToken)\n</code></pre>   <pre><code>trinsic.setAuthToken(authToken);\n</code></pre>","title":"Using Auth Tokens in the SDK"},{"location":"reference/#services","text":"<p>Our SDK is broken down into the following logical services, each of which is accessible through a single <code>TrinsicService</code> instance:</p> <ul> <li>Account Service</li> <li>Credential Service</li> <li>Provider Service</li> <li>Template Service</li> <li>Trust Registry Service</li> <li>Wallet Service</li> </ul>","title":"Services"},{"location":"reference/#using-an-sdk-service","text":"<p>If you are using one of the Trinsic SDKs, you will need to create an instance of a <code>TrinsicService</code> in order to use it.</p> TypeScriptC#PythonGoJava   <pre><code>const trinsic = new TrinsicService();\n</code></pre>   <pre><code>var trinsic = new TrinsicService(_options);\n</code></pre>   <pre><code>trinsic_service = TrinsicService(server_config=trinsic_config())\n</code></pre>   <pre><code>trinsic, err := NewTrinsic(WithTestEnv())\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var trinsic = new TrinsicService(TrinsicUtilities.getTrinsicServiceOptions());\n</code></pre>    <p>The constructor accepts a ServiceOptions object as an argument, allowing you to specify a default ecosystem and other configuration properties:</p> ServiceOptionsConfiguration for Trinsic SDK Servicesserver_endpoint stringTrinsic API endpoint. Defaults to `prod.trinsic.cloud`server_port int32Trinsic API port; defaults to `443`server_use_tls boolWhether TLS is enabled between SDK and Trinsic API; defaults to `true`auth_token stringAuthentication token for SDK calls; defaults to empty string (unauthenticated)  Default ecosystem ID to use for various SDK calls; defaults to `default` string default_ecosystem = 5; <p>The exact structure of this object will depend on the language you are working with. You can always rely on your editor's intellisense when in doubt. </p>","title":"Using an SDK Service"},{"location":"reference/events/","text":"","title":"Events Reference"},{"location":"reference/events/#overview","text":"<p>This page documents each event type raised by Trinsic's platform.</p> <p>To consume events, set up a webhook.</p>","title":"Overview"},{"location":"reference/events/#events","text":"","title":"Events"},{"location":"reference/events/#ping","text":"PingWebhook test eventid stringUUID of this pingwebhook_id stringUUID of the webhook receiving the pingtimestamp stringTimestamp ping was requested, in ISO 8601 format (ex. `2022-07-07T08:09:10.11Z`)message stringArbitrary message specified when ping was requested","title":"Ping"},{"location":"reference/events/#egfcreated","text":"EGFCreatedEntity Governance Framework created and attached to ecosystemid stringUUID of the governance frameworkecosystem_id stringUUID of the ecosystem that owns this EGFtrust_registry stringTrust registry associated with this EGFgoverning_authority stringWallet ID of the authority for this EGFtype stringType of EGFname stringUser-friendly name for the EGFdescription stringDescription of the EGFgovernance_framework stringURI for the EGF","title":"EGFCreated"},{"location":"reference/events/#templatecreated","text":"TemplateCreatedTemplate created in ecosystemid stringUUID of the templateecosystem_id stringUUID of the ecosystem that owns this templatename stringTemplate nametype stringTemplate typecreated_by stringWalletID that created the template","title":"TemplateCreated"},{"location":"reference/events/#itemreceived","text":"ItemReceivedItem inserted into walletid stringUUID of the new itemreceived stringTimestamp when the item was received, in ISO 8601 format (ex. `2022-07-07T08:09:10.11Z`)","title":"ItemReceived"},{"location":"reference/other/openid/","text":"","title":"OpenID Credential Exchange Service"},{"location":"reference/other/openid/#overview","text":"<p>Trinsic provides an OpenID Connect  (\"OIDC\") service which enables verifiers to request credentials from a user's cloud wallet in a simple and secure way.</p> <p>This service does not require the use of Trinsic's SDKs in the user's browser, and is therefore lightweight and easy to integrate.</p>  <p>Credential Issuance</p> <p>Currently, Trinsic's OpenID Connect service only enables the sharing of a credential between holder and verifier. We plan to support issuance through this service at a later date.</p> <p>In the meantime, use the InsertItem SDK call to store credentials in a holder's wallet.</p>","title":"Overview"},{"location":"reference/other/openid/#integration","text":"","title":"Integration"},{"location":"reference/other/openid/#openid-connect-protocol","text":"<p>Because this is an OpenID Connect service, any compliant library may be used -- as long as it enables you to specify additional custom query parameters on the initial outbound URL.</p>  <p>OIDC Flow Implementation</p> <p>The specifics of the OpenID Connect protocol -- and how to implement it -- are out of scope for this documentation.</p> <p>If you would like to see an example implementation of a verification flow against this service, see the sample below.</p>","title":"OpenID Connect Protocol"},{"location":"reference/other/openid/#configuration","text":"<p>Configure your OIDC library with the following parameters:</p>    Parameter Description     General Parameters    <code>authority</code> <code>https://connect.trinsic.cloud</code>   <code>response_type</code> <code>code</code>   <code>scope</code> <code>openid</code>   <code>client_id</code> Any string which uniquely represents your client application   <code>redirect_uri</code> The URI your user should be redirected to once they have completed (or canceled) the flow   Trinsic-Specific Parameters    <code>trinsic:ecosystem</code> ID of ecosystem user wallet resides in   <code>trinsic:schema</code> (Optional) Comma-separated listed of Schema URLs. Only credentials which match one of these schemas will be returned.   <code>trinsic:issuer</code> (Optional) Comma-separated list of Issuer DIDs. Only credentials issued by one of these issuers will be returned.   <code>trinsic:egf</code> (Optional) Comma-separated list of Entity Governance Framework IDs. Only credentials bound to one of these EGF IDs will be returned.","title":"Configuration"},{"location":"reference/other/openid/#response-data","text":"<p>Once the user has returned to your redirect URL, exchange the authorization code (added to your redirect URI as a query parameter named <code>code</code>) for an identity token using your OIDC library.</p> <p>You will receive a JSON object of the following form:</p> Response JSON<pre><code>{\n    \"id_token\": \"{JWT containing same data as vp_token}\",\n    \"access_token\":\"invalid\",\n    \"token_type\":\"Bearer\",\n    \"vp_token\":{\n        \"@context\":[\n            \"https://www.w3.org/2018/credentials/v1\",\n            \"https://w3id.org/bbs/v1\",\n            ...\n        ],\n        \"id\":\"{UUID of Holder Wallet}\",\n        \"type\":[\n            ...,\n            \"VerifiableCredential\"\n        ],\n        \"credentialSchema\":{\n            ...\n        },\n        \"credentialStatus\":{\n            ...\n        },\n        \"credentialSubject\":{\n            ...\n        },\n        \"issuanceDate\":\"{Issue date of credential}\",\n        \"issuer\":\"{DID of Issuer}\",\n        \"proof\":{\n            ...\n        }\n    }\n}\n</code></pre>  <p>Credential Format</p> <p>Note that the above data has been modified for brevity. </p> <p>The <code>@context</code> and <code>type</code> arrays will contain additional entries which are specific to the credential.</p>","title":"Response Data"},{"location":"reference/other/openid/#verify-the-received-proof","text":"<p><code>vp_token</code> is a Verifiable Proof; before making use of its data, you must verify it. </p> <p>This proof can be verified with any library that supports VC verifications for BBS+ signatures. It can also be verified using Trinsic's SDK; this is as simple as passing the proof to the VerifyProof call.</p>  <p>Always Verify</p> <p>It may be tempting to simply take the data in <code>vp_token</code> and act upon it without first verifying the proof.</p> <p>Always verify the proof before making use of its data. </p> <p>Without verification, the received proof is of no more value than an unsubstantiated claim made by your user.</p>","title":"Verify the Received Proof"},{"location":"reference/other/openid/#sample","text":"<p>We've prepared a sample demonstrating client-side OIDC Verification.</p>  <ul> <li> <p> Interactive Sample</p>  <p>Try out an interactive demo demonstrating client-side verifications</p> </li> <li> <p> Sample Source</p>  <p>The source for this sample is available on GitHub</p> </li> </ul>","title":"Sample"},{"location":"reference/other/openid/#oidc-libraries","text":"<p>Libraries exist enabling OIDC functionality for all major languages.</p> <p>The OpenID Connect website lists a number of certified libraries; we've included links to some of these below.</p>  <ul> <li> TypeScript/JavaScript</li> <li> Python</li> <li> C#</li> <li> Go</li> <li> Java</li> <li> Ruby</li> </ul>","title":"OIDC Libraries"},{"location":"reference/proto/","text":"<p></p> <p>This page documents the Protobuf Services and Messages which compose the Trinsic API.</p> <p></p> <p>Top</p>","title":"Protocol Documentation"},{"location":"reference/proto/#servicescommonv1commonproto","text":"<p></p>","title":"services/common/v1/common.proto"},{"location":"reference/proto/#nonce","text":"<p>Nonce used to generate an oberon proof</p>    Field Type Description     timestamp int64 UTC unix millisecond timestamp the request was made   request_hash bytes blake3256 hash of the request body     <p></p>","title":"Nonce"},{"location":"reference/proto/#responsestatus","text":"Name Number Description     SUCCESS 0    WALLET_ACCESS_DENIED 10    WALLET_EXISTS 11    ITEM_NOT_FOUND 20    SERIALIZATION_ERROR 200    UNKNOWN_ERROR 100       <p></p> <p>Top</p>","title":"ResponseStatus"},{"location":"reference/proto/#servicesuniversal-walletv1universal-walletproto","text":"<p></p>","title":"services/universal-wallet/v1/universal-wallet.proto"},{"location":"reference/proto/#service-universalwallet","text":"Method Name Request Type Response Type Description     GetItem GetItemRequest GetItemResponse Retrieve an item from the wallet with a given item identifier   Search SearchRequest SearchResponse Search the wallet using a SQL syntax   InsertItem InsertItemRequest InsertItemResponse Insert an item into the wallet   UpdateItem UpdateItemRequest UpdateItemResponse Update an item in the wallet   DeleteItem DeleteItemRequest DeleteItemResponse Delete an item from the wallet permanently     <p></p>","title":"Service - UniversalWallet"},{"location":"reference/proto/#deleteitemrequest","text":"<p>Request to delete an item in a wallet</p>    Field Type Description     item_id string ID of item to delete    <p></p>","title":"DeleteItemRequest"},{"location":"reference/proto/#deleteitemresponse","text":"<p>Response to <code>DeleteItemRequest</code></p> <p></p>","title":"DeleteItemResponse"},{"location":"reference/proto/#getitemrequest","text":"<p>Request to fetch an item from wallet</p>    Field Type Description     item_id string ID of item in wallet    <p></p>","title":"GetItemRequest"},{"location":"reference/proto/#getitemresponse","text":"<p>Response to <code>GetItemRequest</code></p>    Field Type Description     item_json string Item data as a JSON string   item_type string Type of item specified when item was inserted into wallet    <p></p>","title":"GetItemResponse"},{"location":"reference/proto/#insertitemrequest","text":"<p>Request to insert a JSON document into a wallet</p>    Field Type Description     item_json string Document to insert; must be stringified JSON   item_type string Item type (ex. \"VerifiableCredential\")    <p></p>","title":"InsertItemRequest"},{"location":"reference/proto/#insertitemresponse","text":"<p>Response to <code>InsertItemRequest</code></p>    Field Type Description     item_id string ID of item inserted into wallet    <p></p>","title":"InsertItemResponse"},{"location":"reference/proto/#searchrequest","text":"<p>Request to search items in wallet</p>    Field Type Description     query string SQL Query to execute against items in wallet   continuation_token string Token provided by previous <code>SearchResponse</code> if more data is available for query    <p></p>","title":"SearchRequest"},{"location":"reference/proto/#searchresponse","text":"<p>Response to <code>SearchRequest</code></p>    Field Type Description     items string[] Array of query results, as JSON strings   has_more bool Whether more results are available for this query via <code>continuation_token</code>   continuation_token string Token to fetch next set of results via <code>SearchRequest</code>    <p></p>","title":"SearchResponse"},{"location":"reference/proto/#updateitemrequest","text":"<p>Request to update item in wallet</p>    Field Type Description     item_id string ID of item in wallet   item_type string Item type (ex. \"VerifiableCredential\")    <p></p>","title":"UpdateItemRequest"},{"location":"reference/proto/#updateitemresponse","text":"<p>Response to <code>UpdateItemRequest</code></p>    <p></p> <p>Top</p>","title":"UpdateItemResponse"},{"location":"reference/proto/#servicesverifiable-credentialstemplatesv1templatesproto","text":"<p></p>","title":"services/verifiable-credentials/templates/v1/templates.proto"},{"location":"reference/proto/#service-credentialtemplates","text":"Method Name Request Type Response Type Description     Create CreateCredentialTemplateRequest CreateCredentialTemplateResponse Create a credential template in the current ecosystem   Get GetCredentialTemplateRequest GetCredentialTemplateResponse Fetch a credential template by ID   List ListCredentialTemplatesRequest ListCredentialTemplatesResponse Search credential templates using SQL, returning strongly-typed template data   Search SearchCredentialTemplatesRequest SearchCredentialTemplatesResponse Search credential templates using SQL, returning raw JSON data   Delete DeleteCredentialTemplateRequest DeleteCredentialTemplateResponse Delete a credential template from the current ecosystem by ID     <p></p>","title":"Service - CredentialTemplates"},{"location":"reference/proto/#createcredentialtemplaterequest","text":"<p>Request to create a new template</p>    Field Type Description     name string Name of new template   fields CreateCredentialTemplateRequest.FieldsEntry[] Fields which compose the template   allow_additional_fields bool Whether credentials may be issued against this template which have fields not specified in <code>fields</code>    <p></p>","title":"CreateCredentialTemplateRequest"},{"location":"reference/proto/#createcredentialtemplaterequestfieldsentry","text":"Field Type Description     key string    value TemplateField     <p></p>","title":"CreateCredentialTemplateRequest.FieldsEntry"},{"location":"reference/proto/#createcredentialtemplateresponse","text":"<p>Response to <code>CreateCredentialTemplateRequest</code></p>    Field Type Description     data TemplateData Created template    <p></p>","title":"CreateCredentialTemplateResponse"},{"location":"reference/proto/#deletecredentialtemplaterequest","text":"<p>Request to delete a template by ID</p>    Field Type Description     id string ID of template to delete    <p></p>","title":"DeleteCredentialTemplateRequest"},{"location":"reference/proto/#deletecredentialtemplateresponse","text":"<p>Response to <code>DeleteCredentialTemplateRequest</code></p> <p></p>","title":"DeleteCredentialTemplateResponse"},{"location":"reference/proto/#getcredentialtemplaterequest","text":"<p>Request to fetch a template by ID</p>    Field Type Description     id string ID of template to fetch    <p></p>","title":"GetCredentialTemplateRequest"},{"location":"reference/proto/#getcredentialtemplateresponse","text":"<p>Response to <code>GetCredentialTemplateRequest</code></p>    Field Type Description     template TemplateData Template fetched by ID    <p></p>","title":"GetCredentialTemplateResponse"},{"location":"reference/proto/#gettemplaterequest","text":"<p>Unused</p>    Field Type Description     id string     <p></p>","title":"GetTemplateRequest"},{"location":"reference/proto/#gettemplateresponse","text":"<p>Unused</p>    Field Type Description     data TemplateData     <p></p>","title":"GetTemplateResponse"},{"location":"reference/proto/#listcredentialtemplatesrequest","text":"<p>Request to list templates using a SQL query</p>    Field Type Description     query string SQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code>   continuation_token string Token provided by previous <code>ListCredentialTemplatesResponse</code> if more data is available for query    <p></p>","title":"ListCredentialTemplatesRequest"},{"location":"reference/proto/#listcredentialtemplatesresponse","text":"<p>Response to <code>ListCredentialTemplatesRequest</code></p>    Field Type Description     templates TemplateData[] Templates found by query   has_more_results bool Whether more results are available for this query via <code>continuation_token</code>   continuation_token string Token to fetch next set of resuts via <code>ListCredentialTemplatesRequest</code>    <p></p>","title":"ListCredentialTemplatesResponse"},{"location":"reference/proto/#listtemplatesrequest","text":"<p>Unused</p> <p></p>","title":"ListTemplatesRequest"},{"location":"reference/proto/#listtemplatesresponse","text":"<p>Unused</p>    Field Type Description     templates TemplateData[]     <p></p>","title":"ListTemplatesResponse"},{"location":"reference/proto/#searchcredentialtemplatesrequest","text":"<p>Request to search templates using a SQL query</p>    Field Type Description     query string SQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code>   continuation_token string Token provided by previous <code>SearchCredentialTemplatesResponse</code> if more data is available for query    <p></p>","title":"SearchCredentialTemplatesRequest"},{"location":"reference/proto/#searchcredentialtemplatesresponse","text":"<p>Response to <code>SearchCredentialTemplatesRequest</code></p>    Field Type Description     items_json string Raw JSON data returned from query   has_more bool Whether more results are available for this query via <code>continuation_token</code>   continuation_token string Token to fetch next set of results via <code>SearchCredentialTemplatesRequest</code>    <p></p>","title":"SearchCredentialTemplatesResponse"},{"location":"reference/proto/#templatedata","text":"<p>Credential Template</p>    Field Type Description     id string Template ID   name string Template name   version int32 Template version number   fields TemplateData.FieldsEntry[] Fields defined for the template   allow_additional_fields bool Whether credentials issued against this template may contain fields not defined by template   schema_uri string URI pointing to template JSON schema document   context_uri string URI pointing to template JSON-LD context document   ecosystem_id string ID of ecosystem in which template resides   type string Template type (<code>VerifiableCredential</code>)   created_by string ID of template creator    <p></p>","title":"TemplateData"},{"location":"reference/proto/#templatedatafieldsentry","text":"Field Type Description     key string    value TemplateField     <p></p>","title":"TemplateData.FieldsEntry"},{"location":"reference/proto/#templatefield","text":"<p>A field defined in a template</p>    Field Type Description     description string Human-readable description of the field   optional bool Whether this field may be omitted when a credential is issued against the template   type FieldType The type of the field     <p></p>","title":"TemplateField"},{"location":"reference/proto/#fieldtype","text":"<p>Valid types for credential fields</p>    Name Number Description     STRING 0    NUMBER 1    BOOL 2    DATETIME 4       <p></p> <p>Top</p>","title":"FieldType"},{"location":"reference/proto/#servicesverifiable-credentialsv1verifiable-credentialsproto","text":"<p></p>","title":"services/verifiable-credentials/v1/verifiable-credentials.proto"},{"location":"reference/proto/#service-verifiablecredential","text":"Method Name Request Type Response Type Description     Issue IssueRequest IssueResponse Sign and issue a verifiable credential from a submitted document. The document must be a valid JSON-LD document.   IssueFromTemplate IssueFromTemplateRequest IssueFromTemplateResponse Sign and issue a verifiable credential from a pre-defined template. This process will also add schema validation and revocation registry values to the credential.   CheckStatus CheckStatusRequest CheckStatusResponse Check credential status in the revocation registry   UpdateStatus UpdateStatusRequest UpdateStatusResponse Update credential status by setting the revocation value   CreateProof CreateProofRequest CreateProofResponse Create a proof from a signed document that is a valid verifiable credential and contains a signature from which a proof can be derived.   VerifyProof VerifyProofRequest VerifyProofResponse Verifies a proof by checking the signature value, and if possible schema validation, revocation status, and issuer status against a trust registry   Send SendRequest SendResponse Sends a document directly to a user's email within the given ecosystem     <p></p>","title":"Service - VerifiableCredential"},{"location":"reference/proto/#checkstatusrequest","text":"<p>Request to check a credential's revocation status</p>    Field Type Description     credential_status_id string Credential Status ID to check. This is not the same as the credential's ID.    <p></p>","title":"CheckStatusRequest"},{"location":"reference/proto/#checkstatusresponse","text":"<p>Response to <code>CheckStatusRequest</code></p>    Field Type Description     revoked bool The credential's revocation status    <p></p>","title":"CheckStatusResponse"},{"location":"reference/proto/#createproofrequest","text":"<p>Request to create a proof for a Verifiable Credential using public key tied to caller. Either <code>item_id</code> or <code>document_json</code> may be provided, not both.</p>    Field Type Description     reveal_document_json string A valid JSON-LD frame describing which fields should be revealed in the generated proof. If unspecified, all fields in the document will be revealed   item_id string ID of wallet item stored in a Trinsic cloud wallet   document_json string A valid JSON-LD Verifiable Credential document string with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet.    <p></p>","title":"CreateProofRequest"},{"location":"reference/proto/#createproofresponse","text":"<p>Response to <code>CreateProofRequest</code></p>    Field Type Description     proof_document_json string Valid JSON-LD proof for the specified credential    <p></p>","title":"CreateProofResponse"},{"location":"reference/proto/#issuefromtemplaterequest","text":"<p>Request to create and sign a JSON-LD Verifiable Credential from a template using public key tied to caller</p>    Field Type Description     template_id string ID of template to use   values_json string JSON document string with keys corresponding to the fields of the template referenced by <code>template_id</code>   framework_id string Governance framework ID to use with issuance of this credential. If specified, the issued credential will contain extended issuer metadata with membership info for the given ecosystem governance framework (EGF)    <p></p>","title":"IssueFromTemplateRequest"},{"location":"reference/proto/#issuefromtemplateresponse","text":"<p>Response to <code>IssueFromTemplateRequest</code></p>    Field Type Description     document_json string Verifiable Credential document, in JSON-LD form, constructed from the specified template and values; signed with public key tied to caller of <code>IssueFromTemplateRequest</code>    <p></p>","title":"IssueFromTemplateResponse"},{"location":"reference/proto/#issuerequest","text":"<p>Request to sign a JSON-LD Credential using public key tied to caller</p>    Field Type Description     document_json string Valid JSON-LD Credential document to be signed, in string form    <p></p>","title":"IssueRequest"},{"location":"reference/proto/#issueresponse","text":"<p>Response to <code>IssueRequest</code></p>    Field Type Description     signed_document_json string Verifiable Credential document, signed with public key tied to caller of <code>IssueRequest</code>    <p></p>","title":"IssueResponse"},{"location":"reference/proto/#sendrequest","text":"<p>Request to send a document to another user's wallet</p>    Field Type Description     email string Email address of user to send item to   did_uri string DID of recipient (presently unsupported)   didcomm_invitation_json string DIDComm out-of-band invitation JSON (presently unsupported)   document_json string JSON document to send to recipient    <p></p>","title":"SendRequest"},{"location":"reference/proto/#sendresponse","text":"<p>Response to <code>SendRequest</code></p> <p></p>","title":"SendResponse"},{"location":"reference/proto/#updatestatusrequest","text":"<p>Request to update a credential's revocation status</p>    Field Type Description     credential_status_id string Credential Status ID to update. This is not the same as the credential's ID.   revoked bool New revocation status of credential    <p></p>","title":"UpdateStatusRequest"},{"location":"reference/proto/#updatestatusresponse","text":"<p>Response to <code>UpdateStatusRequest</code></p> <p></p>","title":"UpdateStatusResponse"},{"location":"reference/proto/#validationmessage","text":"<p>Result of a validation check on a proof</p>    Field Type Description     is_valid bool Whether or not this validation check passed   messages string[] If validation failed, contains messages explaining why    <p></p>","title":"ValidationMessage"},{"location":"reference/proto/#verifyproofrequest","text":"<p>Request to verify a proof</p>    Field Type Description     proof_document_json string JSON-LD proof document string to verify    <p></p>","title":"VerifyProofRequest"},{"location":"reference/proto/#verifyproofresponse","text":"<p>Response to <code>VerifyProofRequest</code></p>    Field Type Description     is_valid bool Whether all validations in <code>validation_results</code> passed   validation_messages string[] Deprecated. Use <code>validation_results</code> instead   validation_results VerifyProofResponse.ValidationResultsEntry[] Results of each validation check performed, such as schema conformance, revocation status, signature, etc. Detailed results are provided for failed validations.    <p></p>","title":"VerifyProofResponse"},{"location":"reference/proto/#verifyproofresponsevalidationresultsentry","text":"Field Type Description     key string    value ValidationMessage        <p></p> <p>Top</p>","title":"VerifyProofResponse.ValidationResultsEntry"},{"location":"reference/proto/#serviceseventv1eventproto","text":"<p></p>","title":"services/event/v1/event.proto"},{"location":"reference/proto/#apicall","text":"Field Type Description     source string    request bytes    response bytes     <p></p>","title":"APICall"},{"location":"reference/proto/#egfcreated","text":"<p>Entity Governance Framework created and attached to ecosystem</p>    Field Type Description     id string UUID of the governance framework   ecosystem_id string UUID of the ecosystem that owns this EGF   trust_registry string Trust registry associated with this EGF   governing_authority string Wallet ID of the authority for this EGF   type string Type of EGF   name string User-friendly name for the EGF   description string Description of the EGF   governance_framework string URI for the EGF    <p></p>","title":"EGFCreated"},{"location":"reference/proto/#event","text":"<p>Event</p>    Field Type Description     id string UUID of event   type EventType Type of event   timestamp string Timestamp event occurred, in ISO 8601 format (ex. <code>2022-07-07T08:09:10.11Z</code>)   data bytes Event-specific payload, as an encoded protobuf message    <p></p>","title":"Event"},{"location":"reference/proto/#itemreceived","text":"<p>Item inserted into wallet</p>    Field Type Description     id string UUID of the new item   received string Timestamp when the item was received, in ISO 8601 format (ex. <code>2022-07-07T08:09:10.11Z</code>)    <p></p>","title":"ItemReceived"},{"location":"reference/proto/#ping","text":"<p>Webhook test event</p>    Field Type Description     id string UUID of this ping   webhook_id string UUID of the webhook receiving the ping   timestamp string Timestamp ping was requested, in ISO 8601 format (ex. <code>2022-07-07T08:09:10.11Z</code>)   message string Arbitrary message specified when ping was requested    <p></p>","title":"Ping"},{"location":"reference/proto/#templatecreated","text":"<p>Template created in ecosystem</p>    Field Type Description     id string UUID of the template   ecosystem_id string UUID of the ecosystem that owns this template   name string Template name   type string Template type   created_by string WalletID that created the template     <p></p>","title":"TemplateCreated"},{"location":"reference/proto/#eventtype","text":"<p>All event types</p>    Name Number Description     PING 0    LOG 1    EGF_CREATED 5    EGF_MEMBER_REGISTERED 6    EGF_MEMBER_UNREGISTERED 7    TEMPLATE_CREATED 10    TEMPLATE_DELETED 11    WALLET_CREATED 15    ITEM_RECEIVED 16      <p></p>","title":"EventType"},{"location":"reference/proto/#file-level-extensions","text":"Extension Type Base Number Description     event_type EventType .google.protobuf.MessageOptions 60002 Event type associated with this Event message.     <p></p> <p>Top</p>","title":"File-level Extensions"},{"location":"reference/proto/#servicesdebugv1debugproto","text":"<p></p>","title":"services/debug/v1/debug.proto"},{"location":"reference/proto/#service-debugging","text":"Method Name Request Type Response Type Description     CallEmpty .google.protobuf.Empty .google.protobuf.Empty    CallEmptyAuth .google.protobuf.Empty .google.protobuf.Empty         <p></p> <p>Top</p>","title":"Service - Debugging"},{"location":"reference/proto/#servicesaccountv1accountproto","text":"<p></p>","title":"services/account/v1/account.proto"},{"location":"reference/proto/#service-account","text":"Method Name Request Type Response Type Description     SignIn SignInRequest SignInResponse Sign in to an already existing account   Login LoginRequest LoginResponse Begin login flow for specified account, creating one if it does not already exist   LoginConfirm LoginConfirmRequest LoginConfirmResponse Finalize login flow with two-factor confirmation code   Info AccountInfoRequest AccountInfoResponse Get account information   ListDevices ListDevicesRequest ListDevicesResponse List all connected devices   RevokeDevice RevokeDeviceRequest RevokeDeviceResponse Revoke device access to the account's cloud wallet   AuthorizeWebhook AuthorizeWebhookRequest AuthorizeWebhookResponse Authorize Ecosystem to receive webhook events     <p></p>","title":"Service - Account"},{"location":"reference/proto/#accountdetails","text":"<p>Account registration details</p>    Field Type Description     name string Account name   email string Email address of account   sms string SMS number including country code    <p></p>","title":"AccountDetails"},{"location":"reference/proto/#accountecosystem","text":"<p>Deprecated</p>    Field Type Description     id string    name string    description string    uri string     <p></p>","title":"AccountEcosystem"},{"location":"reference/proto/#accountinforequest","text":"<p>Request for information about the account used to make the request</p> <p></p>","title":"AccountInfoRequest"},{"location":"reference/proto/#accountinforesponse","text":"<p>Information about the account used to make the request</p>    Field Type Description     details AccountDetails The account details associated with the calling request context   ecosystems AccountEcosystem[] Deprecated. Use <code>ecosystem_id</code> instead   wallet_id string The wallet ID associated with this account   device_id string The device ID associated with this account session   ecosystem_id string The ecosystem ID within which this account resides   public_did string The public DID associated with this account. This DID is used as the <code>issuer</code> when signing verifiable credentials   authorized_webhooks string[] Webhook events, if any, this wallet has authorized    <p></p>","title":"AccountInfoResponse"},{"location":"reference/proto/#accountprofile","text":"<p>Device profile containing sensitive authentication data. This information should be stored securely</p>    Field Type Description     profile_type string The type of profile, used to differentiate between protocol schemes or versions   auth_data bytes Auth data containg information about the current device access   auth_token bytes Secure token issued by server used to generate zero-knowledge proofs   protection TokenProtection Token security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.    <p></p>","title":"AccountProfile"},{"location":"reference/proto/#authorizewebhookrequest","text":"<p>Request to authorize Ecosystem provider to receive webhooks for events which occur on this wallet.</p>    Field Type Description     events string[] Events to authorize access to. Default is \"*\" (all events)    <p></p>","title":"AuthorizeWebhookRequest"},{"location":"reference/proto/#authorizewebhookresponse","text":"<p>Response to <code>AuthorizeWebhookRequest</code></p> <p></p>","title":"AuthorizeWebhookResponse"},{"location":"reference/proto/#listdevicesrequest","text":"<p></p>","title":"ListDevicesRequest"},{"location":"reference/proto/#listdevicesresponse","text":"<p></p>","title":"ListDevicesResponse"},{"location":"reference/proto/#loginconfirmrequest","text":"<p>Request to finalize login flow</p>    Field Type Description     challenge bytes Challenge received from <code>Login</code>   confirmation_code_hashed bytes Two-factor confirmation code sent to account email or phone, hashed using Blake3. Our SDKs will handle this hashing process for you.    <p></p>","title":"LoginConfirmRequest"},{"location":"reference/proto/#loginconfirmresponse","text":"<p>Response to <code>LoginConfirmRequest</code></p>    Field Type Description     profile AccountProfile Profile response; must be unprotected using unhashed confirmation code. Our SDKs will handle this process for you, and return to you an authentication token string.    <p></p>","title":"LoginConfirmResponse"},{"location":"reference/proto/#loginrequest","text":"<p>Request to begin login flow</p>    Field Type Description     email string Email address of account. If unspecified, an anonymous account will be created.   invitation_code string Invitation code associated with this registration   ecosystem_id string ID of Ecosystem to sign into. Ignored if <code>invitation_code</code> is passed.    <p></p>","title":"LoginRequest"},{"location":"reference/proto/#loginresponse","text":"<p>Response to <code>LoginRequest</code></p>    Field Type Description     challenge bytes Random byte sequence unique to this login request. If present, two-factor confirmation of login is required. Must be sent back, unaltered, in <code>LoginConfirm</code>.   profile AccountProfile Account profile response. If present, no confirmation of login is required.    <p></p>","title":"LoginResponse"},{"location":"reference/proto/#revokedevicerequest","text":"<p></p>","title":"RevokeDeviceRequest"},{"location":"reference/proto/#revokedeviceresponse","text":"<p></p>","title":"RevokeDeviceResponse"},{"location":"reference/proto/#signinrequest","text":"<p>Request for creating or signing into an account</p>    Field Type Description     details AccountDetails Account registration details   invitation_code string Invitation code associated with this registration   ecosystem_id string ID of Ecosystem to use Ignored if <code>invitation_code</code> is passed    <p></p>","title":"SignInRequest"},{"location":"reference/proto/#signinresponse","text":"<p>Response for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc.</p>    Field Type Description     confirmation_method ConfirmationMethod Indicates if confirmation of account is required.   profile AccountProfile Contains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data.    <p></p>","title":"SignInResponse"},{"location":"reference/proto/#tokenprotection","text":"<p>Token protection info</p>    Field Type Description     enabled bool Indicates if token is protected using a PIN, security code, HSM secret, etc.   method ConfirmationMethod The method used to protect the token     <p></p>","title":"TokenProtection"},{"location":"reference/proto/#confirmationmethod","text":"<p>Confirmation method type for two-factor workflows</p>    Name Number Description     None 0 No confirmation required   Email 1 Email confirmation required   Sms 2 SMS confirmation required   ConnectedDevice 3 Confirmation from a connected device is required   Other 10 Third-party method of confirmation is required      <p></p> <p>Top</p>","title":"ConfirmationMethod"},{"location":"reference/proto/#servicesproviderv1providerproto","text":"<p></p>","title":"services/provider/v1/provider.proto"},{"location":"reference/proto/#service-provider","text":"Method Name Request Type Response Type Description     CreateEcosystem CreateEcosystemRequest CreateEcosystemResponse Create new ecosystem and assign the authenticated user as owner   UpdateEcosystem UpdateEcosystemRequest UpdateEcosystemResponse Update an existing ecosystem   GrantAuthorization GrantAuthorizationRequest GrantAuthorizationResponse Grant user authorization to ecosystem resources   RevokeAuthorization RevokeAuthorizationRequest RevokeAuthorizationResponse Revoke user authorization to ecosystem resources   GetAuthorizations GetAuthorizationsRequest GetAuthorizationsResponse Retreive the list of permissions for this particular account/ecosystem   AddWebhook AddWebhookRequest AddWebhookResponse Add a webhook endpoint to the ecosystem   DeleteWebhook DeleteWebhookRequest DeleteWebhookResponse Delete a webhook endpoint from the ecosystem   EcosystemInfo EcosystemInfoRequest EcosystemInfoResponse Get ecosystem information   GenerateToken GenerateTokenRequest GenerateTokenResponse Generates an unprotected authentication token that can be used to configure server side applications   Invite InviteRequest InviteResponse Invite a user to the ecosystem   InvitationStatus InvitationStatusRequest InvitationStatusResponse Check the status of an invitation   GetOberonKey GetOberonKeyRequest GetOberonKeyResponse Returns the public key being used to create/verify oberon tokens   GetEventToken GetEventTokenRequest GetEventTokenResponse Generate a signed token (JWT) that can be used to connect to the message bus     <p></p>","title":"Service - Provider"},{"location":"reference/proto/#addwebhookrequest","text":"<p>Request to add a webhook to an ecosystem</p>    Field Type Description     destination_url string Destination to post webhook calls to. Must be a reachable HTTPS URL.   secret string Secret string used for HMAC-SHA256 signing of webhook payloads to verify that a webhook comes from Trinsic   events string[] Events to subscribe to. Default is \"*\" (all events)    <p></p>","title":"AddWebhookRequest"},{"location":"reference/proto/#addwebhookresponse","text":"<p>Response to <code>AddWebhookRequest</code></p>    Field Type Description     ecosystem Ecosystem Ecosystem data with new webhook    <p></p>","title":"AddWebhookResponse"},{"location":"reference/proto/#createecosystemrequest","text":"<p>Request to create an ecosystem</p>    Field Type Description     name string Globally unique name for the Ecosystem. This name will be part of the ecosystem-specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen. If not passed, ecosystem name will be auto-generated.   description string Ecosystem description   uri string External URL associated with your organization or ecosystem entity   details services.account.v1.AccountDetails The account details of the owner of the ecosystem    <p></p>","title":"CreateEcosystemRequest"},{"location":"reference/proto/#createecosystemresponse","text":"<p>Response to <code>CreateEcosystemRequest</code></p>    Field Type Description     ecosystem Ecosystem Details of the created ecosystem   profile services.account.v1.AccountProfile Account profile for auth of the owner of the ecosystem   confirmation_method services.account.v1.ConfirmationMethod Indicates if confirmation of account is required.    <p></p>","title":"CreateEcosystemResponse"},{"location":"reference/proto/#deletewebhookrequest","text":"<p>Request to delete a webhook from an ecosystem</p>    Field Type Description     webhook_id string ID of webhook to delete    <p></p>","title":"DeleteWebhookRequest"},{"location":"reference/proto/#deletewebhookresponse","text":"<p>Response to <code>DeleteWebhookRequest</code></p>    Field Type Description     ecosystem Ecosystem Ecosystem data after removal of webhook    <p></p>","title":"DeleteWebhookResponse"},{"location":"reference/proto/#ecosystem","text":"<p>Details of an ecosystem</p>    Field Type Description     id string URN of the ecosystem   name string Globally unique name for the ecosystem   description string Ecosystem description   uri string External URL associated with the organization or ecosystem entity   webhooks WebhookConfig[] Configured webhooks, if any    <p></p>","title":"Ecosystem"},{"location":"reference/proto/#ecosysteminforequest","text":"<p>Request to fetch information about an ecosystem</p> <p></p>","title":"EcosystemInfoRequest"},{"location":"reference/proto/#ecosysteminforesponse","text":"<p>Response to <code>InfoRequest</code></p>    Field Type Description     ecosystem Ecosystem Ecosystem corresponding to requested <code>ecosystem_id</code>    <p></p>","title":"EcosystemInfoResponse"},{"location":"reference/proto/#generatetokenrequest","text":"<p>Request to generate an authentication token for the current account</p>    Field Type Description     description string Description to identify this token    <p></p>","title":"GenerateTokenRequest"},{"location":"reference/proto/#generatetokenresponse","text":"<p>Response to <code>GenerateTokenRequest</code></p>    Field Type Description     profile services.account.v1.AccountProfile Account authentication profile that contains unprotected token    <p></p>","title":"GenerateTokenResponse"},{"location":"reference/proto/#getauthorizationsrequest","text":"<p>Fetch list of grants that the current account has access to in its ecosystem</p> <p></p>","title":"GetAuthorizationsRequest"},{"location":"reference/proto/#getauthorizationsresponse","text":"<p>Response to <code>GetAuthorizationsRequest</code></p>    Field Type Description     grants Grant[] Grants attached to account    <p></p>","title":"GetAuthorizationsResponse"},{"location":"reference/proto/#geteventtokenrequest","text":"<p>Generates an events token bound to the provided ed25519 public key.</p>    Field Type Description     pk bytes Raw public key to generate event token for    <p></p>","title":"GetEventTokenRequest"},{"location":"reference/proto/#geteventtokenresponse","text":"<p>Response message containing a token (JWT) that can be used to connect directly to the message streaming architecture</p>    Field Type Description     token string JWT bound to the public key provided in <code>GetEventTokenRequest</code>    <p></p>","title":"GetEventTokenResponse"},{"location":"reference/proto/#getoberonkeyrequest","text":"<p>Request to fetch the Trinsic public key used to verify authentication token validity</p> <p></p>","title":"GetOberonKeyRequest"},{"location":"reference/proto/#getoberonkeyresponse","text":"<p>Response to <code>GetOberonKeyRequest</code></p>    Field Type Description     key string Oberon Public Key as RAW base64-url encoded string    <p></p>","title":"GetOberonKeyResponse"},{"location":"reference/proto/#grant","text":"<p>A grant authorizing <code>actions</code> on a <code>resourceId</code></p>    Field Type Description     resourceId string the urn of the resource   actions string[] list of actions that are allowed   child_grants Grant[] any child grants    <p></p>","title":"Grant"},{"location":"reference/proto/#grantauthorizationrequest","text":"<p>Grant permissions to a resource or path in the ecosystem</p>    Field Type Description     email string Email address of account being granted permission. Mutually exclusive with <code>walletId</code>.   walletId string Wallet ID of account being granted permission. Mutually exclusive with <code>email</code>.   resource string Resource string that account is receiving permissions for. Resources are specified as a RESTful path: /{ecoId}/{resource type}/{resource id}. <code>ecoId</code> may be omitted.   action string Action to authorize. Default is \"*\" (all)    <p></p>","title":"GrantAuthorizationRequest"},{"location":"reference/proto/#grantauthorizationresponse","text":"<p>Response to <code>GrantAuthorizationRequest</code></p> <p></p>","title":"GrantAuthorizationResponse"},{"location":"reference/proto/#invitationstatusrequest","text":"<p>Request details for the status of an invitation</p>    Field Type Description     invitation_id string ID of invitation, received from <code>InviteResponse</code>    <p></p>","title":"InvitationStatusRequest"},{"location":"reference/proto/#invitationstatusresponse","text":"<p>Response to <code>InvitationStatusRequest</code></p>    Field Type Description     status InvitationStatusResponse.Status Status of invitation   status_details string Human-readable string with details about invitation status    <p></p>","title":"InvitationStatusResponse"},{"location":"reference/proto/#inviterequest","text":"<p>Request to invite a participant to an ecosystem</p>    Field Type Description     participant ParticipantType Type of participant being invited (individual/organization)   description string Description of invitation   details services.account.v1.AccountDetails Account details of invitee    <p></p>","title":"InviteRequest"},{"location":"reference/proto/#inviterequestdidcomminvitation","text":"<p></p>","title":"InviteRequest.DidCommInvitation"},{"location":"reference/proto/#inviteresponse","text":"<p>Response to <code>InviteRequest</code></p>    Field Type Description     invitation_id string ID of created invitation   invitation_code string Invitation code -- must be passed back in <code>LoginRequest</code>    <p></p>","title":"InviteResponse"},{"location":"reference/proto/#revokeauthorizationrequest","text":"<p>Revoke permissions to a resource or path in the ecosystem</p>    Field Type Description     email string Email address of account having permission revoked. Mutually exclusive with <code>walletId</code>.   walletId string Wallet ID of account having permission revoked. Mutually exclusive with <code>email</code>.   resource string Resource string that account is losing permissions for. Resources are specified as a RESTful path: /{ecoId}/{resource type}/{resource id}. <code>ecoId</code> may be omitted.   action string Action to revoke. Default is \"*\" (all)    <p></p>","title":"RevokeAuthorizationRequest"},{"location":"reference/proto/#revokeauthorizationresponse","text":"<p>Response to <code>RevokeAuthorizationRequest</code></p> <p></p>","title":"RevokeAuthorizationResponse"},{"location":"reference/proto/#updateecosystemrequest","text":"<p>Request to update an ecosystem's metadata</p>    Field Type Description     description string New description of the ecosystem   uri string New external URL associated with the organization or ecosystem entity    <p></p>","title":"UpdateEcosystemRequest"},{"location":"reference/proto/#updateecosystemresponse","text":"<p>Response to <code>UpdateEcosystemRequest</code></p>    Field Type Description     Ecosystem Ecosystem Current ecosystem metadata, post-update    <p></p>","title":"UpdateEcosystemResponse"},{"location":"reference/proto/#webhookconfig","text":"<p>Webhook configured on an ecosystem</p>    Field Type Description     id string UUID of the webhook   destination_url string HTTPS URL to POST webhook calls to   events string[] Events the webhook is subscribed to   status string Last known status of webhook (whether or not Trinsic can successfully reach destination)     <p></p>","title":"WebhookConfig"},{"location":"reference/proto/#invitationstatusresponsestatus","text":"Name Number Description     Error 0 Onboarding resulted in error   InvitationSent 1 The participant has been invited   Completed 2 The participant has been onboarded   Expired 3 The invite has expired    <p></p>","title":"InvitationStatusResponse.Status"},{"location":"reference/proto/#participanttype","text":"<p>Type of participant being invited to ecosystem</p>    Name Number Description     participant_type_individual 0 Participant is an individual   participant_type_organization 1 Participant is an organization      <p></p> <p>Top</p>","title":"ParticipantType"},{"location":"reference/proto/#servicestrust-registryv1trust-registryproto","text":"<p></p>","title":"services/trust-registry/v1/trust-registry.proto"},{"location":"reference/proto/#service-trustregistry","text":"Method Name Request Type Response Type Description     AddFramework AddFrameworkRequest AddFrameworkResponse Add a governance framework to the ecosystem   RemoveFramework RemoveFrameworkRequest RemoveFrameworkResponse Remove a governance framework from the ecosystem   SearchRegistry SearchRegistryRequest SearchRegistryResponse Search the ecosystem's governance frameworks   RegisterMember RegisterMemberRequest RegisterMemberResponse Register an authoritative issuer for a credential schema   UnregisterMember UnregisterMemberRequest UnregisterMemberResponse Removes an authoritative issuer for a credential schema from the trust registry   GetMembershipStatus GetMembershipStatusRequest GetMembershipStatusResponse Fetch the membership status of an issuer for a given credential schema in a trust registry   FetchData FetchDataRequest FetchDataResponse stream Not implemented.     <p></p>","title":"Service - TrustRegistry"},{"location":"reference/proto/#addframeworkrequest","text":"<p>Request to register a new ecosystem governance framework in the current ecosystem</p>    Field Type Description     governance_framework_uri string URI of governance framework organization   name string Name of governance framework organization   description string Description of governance framework    <p></p>","title":"AddFrameworkRequest"},{"location":"reference/proto/#addframeworkresponse","text":"<p>Response to <code>AddFrameworkRequest</code></p>    Field Type Description     id string Unique framework identifier   governing_authority string DID URI of Trinsic account which created the governance framework   trust_registry string URN of trust registry for governance framework    <p></p>","title":"AddFrameworkResponse"},{"location":"reference/proto/#fetchdatarequest","text":"<p>Not implemented.</p>    Field Type Description     governance_framework_uri string    query string     <p></p>","title":"FetchDataRequest"},{"location":"reference/proto/#fetchdataresponse","text":"<p>Not implemented.</p>    Field Type Description     response_json string    has_more_results bool    continuation_token string     <p></p>","title":"FetchDataResponse"},{"location":"reference/proto/#getmembershipstatusrequest","text":"<p>Request to fetch membership status in governance framework for a specific credential schema. Only one of <code>did_uri</code>, <code>x509_cert</code> may be specified.</p>    Field Type Description     governance_framework_uri string URI of governance framework   did_uri string DID URI of member   x509_cert string X.509 certificate of member   schema_uri string URI of credential schema associated with membership    <p></p>","title":"GetMembershipStatusRequest"},{"location":"reference/proto/#getmembershipstatusresponse","text":"<p>Response to <code>GetMembershipStatusRequest</code></p>    Field Type Description     status RegistrationStatus Status of member for given credential schema    <p></p>","title":"GetMembershipStatusResponse"},{"location":"reference/proto/#governanceframework","text":"<p>Ecosystem Governance Framework</p>    Field Type Description     governance_framework_uri string URI of governance framework organization   trust_registry_uri string URI of trust registry associated with governance framework   description string Description of governance framework    <p></p>","title":"GovernanceFramework"},{"location":"reference/proto/#registermemberrequest","text":"<p>Request to register a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.</p>    Field Type Description     did_uri string DID URI of member to register   wallet_id string Trinsic Wallet ID of member to register   email string Email address of member to register. Must be associated with an existing Trinsic account.   schema_uri string URI of credential schema to register member as authorized issuer of   valid_from_utc uint64 Unix Timestamp member is valid from. Member will not be considered valid before this timestamp.   valid_until_utc uint64 Unix Timestamp member is valid until. Member will not be considered valid after this timestamp.   framework_id string ID of the governance framework that member is being added to    <p></p>","title":"RegisterMemberRequest"},{"location":"reference/proto/#registermemberresponse","text":"<p>Response to <code>RegisterMemberRequest</code></p> <p></p>","title":"RegisterMemberResponse"},{"location":"reference/proto/#removeframeworkrequest","text":"<p>Request to remove a governance framework from the current ecosystem</p>    Field Type Description     id string ID of governance framework to remove    <p></p>","title":"RemoveFrameworkRequest"},{"location":"reference/proto/#removeframeworkresponse","text":"<p>Response to <code>RemoveFrameworkRequest</code></p> <p></p>","title":"RemoveFrameworkResponse"},{"location":"reference/proto/#searchregistryrequest","text":"<p>Request to search all governance frameworks within ecosystem</p>    Field Type Description     query string SQL query to execute against frameworks. Example: <code>SELECT c from c where c.type == 'GovernanceFramework'</code>   continuation_token string Token to fetch next set of results, from previous <code>SearchRegistryResponse</code>    <p></p>","title":"SearchRegistryRequest"},{"location":"reference/proto/#searchregistryresponse","text":"<p>Response to <code>SearchRegistryRequest</code></p>    Field Type Description     items_json string JSON string containing array of resultant objects   has_more bool Whether more data is available to fetch for query   continuation_token string Token to fetch next set of results via <code>SearchRegistryRequest</code>    <p></p>","title":"SearchRegistryResponse"},{"location":"reference/proto/#unregistermemberrequest","text":"<p>Request to unregister a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.</p>    Field Type Description     did_uri string DID URI of member to unregister   wallet_id string Trinsic Wallet ID of member to unregister   email string Email address of member to unregister. Must be associated with an existing Trinsic account.   schema_uri string URI of credential schema to unregister member as authorized issuer of   framework_id string ID of the governance framework that member is being removed from    <p></p>","title":"UnregisterMemberRequest"},{"location":"reference/proto/#unregistermemberresponse","text":"<p>Response to <code>UnregisterMemberRequest</code></p>  <p></p>","title":"UnregisterMemberResponse"},{"location":"reference/proto/#registrationstatus","text":"Name Number Description     CURRENT 0 Member is currently authorized, as of the time of the query   EXPIRED 1 Member's authorization has expired   TERMINATED 2 Member has voluntarily ceased Issuer role under the specific EGF   REVOKED 3 Member authority under specific EGF was terminated by the governing authority   NOT_FOUND 10 Member is not associated with given credential schema in the EGF      <p></p> <p>Top</p>","title":"RegistrationStatus"},{"location":"reference/proto/#servicesoptionsfield-optionsproto","text":"<p></p>","title":"services/options/field-options.proto"},{"location":"reference/proto/#sdktemplateoption","text":"Field Type Description     anonymous bool Whether the service endpoint allows anonymous (no auth token necessary) authentication This is used by the <code>protoc-gen-trinsic-sdk</code> plugin for metadata.   ignore bool Whether the SDK template generator should ignore this method. This method will be wrapped manually.      <p></p>","title":"SdkTemplateOption"},{"location":"reference/proto/#file-level-extensions_1","text":"Extension Type Base Number Description     optional bool .google.protobuf.FieldOptions 60000 Whether field is optional in Trinsic's backend. This is not the same as an <code>optional</code> protobuf label; it only impacts documentation generation for the field.   sdk_template_option SdkTemplateOption .google.protobuf.MethodOptions 60001      <p></p> <p>Top</p>","title":"File-level Extensions"},{"location":"reference/proto/#sdkoptionsv1optionsproto","text":"<p></p>","title":"sdk/options/v1/options.proto"},{"location":"reference/proto/#serviceoptions","text":"<p>Configuration for Trinsic SDK Services</p>    Field Type Description     server_endpoint string Trinsic API endpoint. Defaults to <code>prod.trinsic.cloud</code>   server_port int32 Trinsic API port; defaults to <code>443</code>   server_use_tls bool Whether TLS is enabled between SDK and Trinsic API; defaults to <code>true</code>   auth_token string Authentication token for SDK calls; defaults to empty string (unauthenticated)    <p>Default ecosystem ID to use for various SDK calls; defaults to <code>default</code> string default_ecosystem = 5; |</p>","title":"ServiceOptions"},{"location":"reference/proto/#scalar-value-types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby      double  double double float float64 double float Float    float  float float float float32 float float Float    int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)    int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum    uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)    uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)    sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)    sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum    fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)    fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum    sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)    sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum    bool  bool boolean boolean bool bool boolean TrueClass/FalseClass    string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)    bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Scalar Value Types"},{"location":"reference/services/account-service/","text":"<p>The Account Service allows you to create and sign in to accounts.</p>  <p>Wallets vs Accounts</p> <p>Wallets and accounts are related and often interchangeable -- each account has an associated wallet, and operations on a wallet are performed using an account's access token.</p> <p>Every account has exactly one wallet. </p>   <p>Authentication Tokens</p> <p>When you create or sign in to an account, the response is an authentication token string.</p> <p>This string is an encoded form of your account profile, as well as an access key to perform calls using the account.</p> <p>These are effectively API keys; they should be kept safe and never published.</p>","title":"Account Service"},{"location":"reference/services/account-service/#login","text":"<p>Attempts the first step of the login process for the specified account, creating it if it does not already exist.</p> <p>Trinsic will response with a <code>challenge</code>, and send an authentication code to the account's email address.</p> <p>The authentication code must be passed along with <code>challenge</code> to LoginConfirm to finalize the login.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic account login --email \"bob@example.com\"\n</code></pre>   <pre><code>const loginResponse = await trinsic.account().login(\n  LoginRequest.fromPartial({\n    email: \"bob@example.com\",\n  })\n);\n</code></pre>   <pre><code>var loginResponse = await trinsic.Account.LoginAsync(new() {\n    EcosystemId = ecosystemId,\n    Email = \"bob@example.com\"\n});\n</code></pre>   <pre><code>login_response = await trinsic.account.login(\n    request=LoginRequest(email=\"bob@example.com\")\n)\n</code></pre>   <pre><code>loginResponse, err := trinsic.Account().Login(context.Background(), &amp;account.LoginRequest{\n    Email: \"bob@example.com\",\n})\n</code></pre>   <pre><code>var loginResponse =\n    trinsic\n        .account()\n        .login(LoginRequest.newBuilder().setEmail(\"bob@example.com\").build())\n        .get();\n</code></pre>      <p>LoginRequestRequest to begin login flowemail optional stringEmail address of account. If unspecified, an anonymous account will be created.invitation_code optional stringInvitation code associated with this registrationecosystem_id optional stringID of Ecosystem to sign into. Ignored if <code>invitation_code</code> is passed.</p>   <p>LoginResponseResponse to <code>LoginRequest</code>challenge bytesRandom byte sequence unique to this login request. If present, two-factor confirmation of login is required. Must be sent back, unaltered, in <code>LoginConfirm</code>.profile AccountProfileAccount profile response. If present, no confirmation of login is required.Show child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is required</p>     <p>Anonymous Login</p> <p>Anonymous accounts are accounts which are not tied to any email or phone number, and do not require any authentication. They are typically used for testing and prototypes.</p> <p>To create an anonymous account with an SDK, use the <code>TrinsicService.LoginAnonymous()</code> method.</p> <p>To create an anonymous account with the CLI, simply leave the <code>email</code> parameter unspecified.</p>","title":"Login"},{"location":"reference/services/account-service/#login-confirm","text":"<p>Finalizes the login process.</p> <p>You must pass <code>challenge</code> as it was received in response to Login, along with the confirmation code that was sent in an email.</p> <p>Our SDK will take care of hashing the confirmation code for you.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic account login --email \"bob@example.com\"\n</code></pre>   <pre><code>const authToken = await trinsic\n  .account()\n  .loginConfirm(loginResponse.challenge, \"12345\");\n</code></pre>   <pre><code>var authToken = await trinsic.Account.LoginConfirmAsync(loginResponse.Challenge, authCode);\n</code></pre>   <pre><code>auth_token = await trinsic.account.login_confirm(\n    challenge=login_response.challenge, auth_code=\"12345\"\n)\n</code></pre>   <pre><code>authToken, err := trinsic.Account().LoginConfirm(context.Background(), loginResponse.GetChallenge(), \"12345\")\n</code></pre>   <pre><code>var authToken =\n    trinsic.account().loginConfirm(loginResponse.getChallenge(), \"12345\").get();\n</code></pre>      <p>LoginConfirmRequestRequest to finalize login flowchallenge bytesChallenge received from <code>Login</code>confirmation_code_hashed bytesTwo-factor confirmation code sent to account email or phone, hashed using Blake3. Our SDKs will handle this hashing process for you.</p>   <p>LoginConfirmResponseResponse to <code>LoginConfirmRequest</code>profile AccountProfileProfile response; must be unprotected using unhashed confirmation code. Our SDKs will handle this process for you, and return to you an authentication token string.Show child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is required</p>","title":"Login Confirm"},{"location":"reference/services/account-service/#get-account-info","text":"<p>Returns the account information (name, email address, phone number, etc.) used to create the currently-active account profile.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic account info\n</code></pre>   <pre><code>const info = await accountService.info();\n</code></pre>   <pre><code>var info = await trinsic.Account.GetInfoAsync();\n</code></pre>   <pre><code>info = await service.get_info()\n</code></pre>   <pre><code>info2, err2 := trinsic.Account().GetInfo(context.Background())\n</code></pre>   <pre><code>var info = trinsic.account().getInfo().get();\n</code></pre>      <p>AccountInfoRequestRequest for information about the account used to make the requestThis message has no fields</p>   <p>AccountInfoResponseInformation about the account used to make the requestdetails AccountDetailsThe account details associated with the calling request contextShow child attributesdetails.name optional stringAccount namedetails.email optional stringEmail address of accountdetails.sms optional stringSMS number including country codeecosystems AccountEcosystem[]Use <code>ecosystem_id</code> insteadShow child attributesecosystems[i].id stringecosystems[i].name stringecosystems[i].description stringecosystems[i].uri stringwallet_id stringThe wallet ID associated with this accountdevice_id stringThe device ID associated with this account sessionecosystem_id stringThe ecosystem ID within which this account residespublic_did stringThe public DID associated with this account. This DID is used as the <code>issuer</code> when signing verifiable credentialsauthorized_webhooks string[]Webhook events, if any, this wallet has authorized</p>     <p>Note</p> <p>This call returns the information associated with the authentication token used to create the request; therefore, it is not possible to pass a different authentication token to this call. Otherwise, Trinsic's zero-knowledge proof authentication scheme would be violated.</p> <p>When using the CLI, this will return information for the account most recently logged in to.</p> <p>When using the SDK, this will return information for the authentication token stored in the <code>AccountService</code> instance's <code>ServiceOptions.AuthToken</code> field, which will be the account most recently logged in to, unless you have manually set this value yourself.</p>","title":"Get Account Info"},{"location":"reference/services/account-service/#authorize-webhook","text":"<p>Authorizes the ecosystem provider to receive webhooks pertaining to this wallet.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic account authorize-webhook --events \"*\"\n</code></pre>   <pre><code>const response = await trinsic.account().authorizeWebhook(\n  AuthorizeWebhookRequest.fromPartial({\n    events: [\"*\"], // Authorize all events\n  })\n);\n</code></pre>   <pre><code>var request = new AuthorizeWebhookRequest();\nrequest.Events.Add(\"*\"); //Authorize all events\n\nawait trinsic.Account.AuthorizeWebhookAsync(request);\n</code></pre>   <pre><code>request = AuthorizeWebhookRequest()\nrequest.events.append(\"*\")\nresponse = await trinsic.account.authorize_webhook(request=request)\n</code></pre>   <pre><code>request := &amp;account.AuthorizeWebhookRequest{\n    Events: []string{\"*\"}, //Authorize all events\n}\n\nauthResponse, err := trinsic.Account().AuthorizeWebhook(context.Background(), request)\n</code></pre>   <pre><code>var authorizeResponse =\n    trinsic\n        .account()\n        .authorizeWebhook(\n            AuthorizeWebhookRequest.newBuilder()\n                .addEvents(\"*\") // Authorize all events\n                .build())\n        .get();\n</code></pre>      <p>AuthorizeWebhookRequestRequest to authorize Ecosystem provider to receive webhooks for events which occur on this wallet.events string[]Events to authorize access to. Default is \"*\" (all events)</p>   <p>AuthorizeWebhookResponseResponse to <code>AuthorizeWebhookRequest</code>This message has no fields</p>","title":"Authorize Webhook"},{"location":"reference/services/account-service/#protect-account-profile","text":"<p>Deprecated Sign-in Flow</p> <p>This section is related to the the deprecated SignIn endpoint; the new Login flow does not require the use of <code>Protect</code> and <code>Unprotect</code>.</p>  <p>Protects the specified account profile with a security code. It is not possible to execute this call using the CLI.</p> TypeScriptC#PythonGoJava   <pre><code>const protectedProfile = await accountService.protect(accountProfile, \"1234\");\n</code></pre>   <pre><code>var securityCode = \"1234\";\nvar myProtectedProfile = AccountService.Protect(myProfile, securityCode);\nvar myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n</code></pre>   <pre><code>code = b\"1234\"\nmy_protected_profile = account_service.protect(\n    profile=my_profile, security_code=code\n)\nmy_unprotected_profile = account_service.unprotect(\n    profile=my_protected_profile, security_code=code\n)\n</code></pre>   <pre><code>securityCode := \"1234\"\nprotectedProfile, err := trinsic.Account().Protect(profile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\nunprotectedProfile, err := trinsic.Account().Unprotect(protectedProfile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var code = \"1234\";\nvar myProtectedProfile = AccountService.protect(myProfile, code);\nvar myUnprotectedProfile = AccountService.unprotect(myProtectedProfile, code);\n</code></pre>     <p>Info</p> <p>In this context, \"protection\" refers to a cryptographic operation on the authorization token for an account.</p> <p>Protecting an account profile with code <code>c</code> returns a new access token which is unusable until it is unprotected with the same code <code>c</code>. It is not possible to reverse the protection process without the original protection code.</p> <p>You will receive a protected account profile from Trinsic if you attempt to sign in to an account via email, SMS, or any other method which requires authentication. Trinsic will send a security code to the email or phone number associated with the account, which can be used to unprotect the account profile.</p> <p>Specifically, Trinsic is using Oberon to handle access tokens; protection and unprotection is handled using the blinding/unblinding features of Oberon.</p>","title":"Protect Account Profile"},{"location":"reference/services/account-service/#unprotect-account-profile","text":"<p>Deprecated Sign-in Flow</p> <p>This section is related to the the deprecated SignIn endpoint; the new Login flow does not require the use of <code>Protect</code> and <code>Unprotect</code>.</p>  <p>Unprotects the specified account profile using the given code. It is not possible to execute this call using the CLI.</p> <p>The profile must have been previously protected using the same code that is being used to unprotect it. Profiles can be protected using any arbitrary code via the Protect method.</p> <p>Most commonly, this method is used on a protected profile received from the Sign In method. The code to unprotect it will have been sent to the account owner via email or SMS.</p> TypeScriptC#PythonGoJava   <pre><code>const accountProfile = await accountService.unprotect(protectedProfile, \"1234\");\n</code></pre>   <pre><code>var securityCode = \"1234\";\nvar myProtectedProfile = AccountService.Protect(myProfile, securityCode);\nvar myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n</code></pre>   <pre><code>code = b\"1234\"\nmy_protected_profile = account_service.protect(\n    profile=my_profile, security_code=code\n)\nmy_unprotected_profile = account_service.unprotect(\n    profile=my_protected_profile, security_code=code\n)\n</code></pre>   <pre><code>securityCode := \"1234\"\nprotectedProfile, err := trinsic.Account().Protect(profile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\nunprotectedProfile, err := trinsic.Account().Unprotect(protectedProfile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var code = \"1234\";\nvar myProtectedProfile = AccountService.protect(myProfile, code);\nvar myUnprotectedProfile = AccountService.unprotect(myProtectedProfile, code);\n</code></pre>","title":"Unprotect Account Profile"},{"location":"reference/services/account-service/#deprecated-sign-in","text":"<p>Deprecated</p> <p>This endpoint is deprecated, and will be removed in the near future.</p> <p>Please use Login and LoginConfirm.</p>  <p>Sign in to an existing account, or create a new one.</p> <p>If no account details are passed to this method, an anonymous account will be created.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic account login --email &lt;PROFILE_EMAIL&gt; --name &lt;PROFILE_NAME&gt;\n</code></pre>   <pre><code>const allison = (await accountService.signIn()).getProfile();\n</code></pre>   <pre><code>var myProfile = await trinsic.Account.SignInAsync(new());\n</code></pre>   <pre><code>my_profile = await account_service.login_anonymous()\n</code></pre>   <pre><code>profile, err := trinsic.Account().LoginAnonymous(context.Background())\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var myProfile = trinsic.account().signIn().get();\n</code></pre>      <p>SignInRequestRequest for creating or signing into an accountdetails optional AccountDetailsAccount registration detailsShow child attributesdetails.name optional stringAccount namedetails.email optional stringEmail address of accountdetails.sms optional stringSMS number including country codeinvitation_code optional stringInvitation code associated with this registrationecosystem_id optional stringID of Ecosystem to use Ignored if <code>invitation_code</code> is passed</p>   <p>SignInResponseResponse for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc.confirmation_method ConfirmationMethodIndicates if confirmation of account is required.Show enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is requiredprofile AccountProfileContains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data.Show child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is required</p>    <p>This operation, if successful, returns an authentication token string.</p>  <p>Protected Authentication Tokens</p> <p>If you are attempting to login to a non-anonymous account (by specifying an email address or phone number), the authentication token returned will be protected, and cannot be used until it has been unprotected.</p> <p>Trinsic will have sent a security code to the account's email address or phone number; this security code must be used with the Unprotect call to receive a usable authentication token.</p> <p>In the future, we will provide an SDK call to determine if an authentication token is protected.</p>","title":"[Deprecated] Sign In"},{"location":"reference/services/credential-service/","text":"<p>The Credential Service exposes functionality for issuance, proof generation, verification, and revocation of Verifiable Credentials.</p>  <p>Signature Format</p> <p>The Credential service currently supports BBS+ Signatures , which enable selective disclosure of credential fields during proof generation.</p> <p>Credentials are signed, and proofs are created, using a key pair unique to the signing / holding wallet. This key pair is created and managed by Trinsic upon account creation.</p>","title":"Credential Service"},{"location":"reference/services/credential-service/#issue-credential","text":"<p>Issues a credential from a valid JSON-LD document. Issued credentials are not automatically stored in any wallet.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic vc issue --document &lt;JSONLD_FILE&gt; --out &lt;OUTPUT_FILE&gt;\n</code></pre>   <pre><code>const issueResponse = await trinsic\n  .credential()\n  .issue(IssueRequest.fromPartial({ documentJson: credentialJSON }));\n</code></pre>   <pre><code>var credential = await trinsic.Credential.IssueAsync(new() { DocumentJson = credentialJson });\n</code></pre>   <pre><code>issue_response = await trinsic_service.credential.issue(\n    request=IssueRequest(document_json=credential_json)\n)\n</code></pre>   <pre><code>issueResponse, err := trinsic.Credential().Issue(context.Background(),\n    &amp;credential.IssueRequest{\n        DocumentJson: unsignedCredential,\n    })\n</code></pre>   <pre><code>var issueResult =\n    trinsic\n        .credential()\n        .issue(IssueRequest.newBuilder().setDocumentJson(unsignedCredential).build())\n        .get();\n\nvar signedCredentialJson = issueResult.getSignedDocumentJson();\n</code></pre>      <p>IssueRequestRequest to sign a JSON-LD Credential using public key tied to callerdocument_json stringValid JSON-LD Credential document to be signed, in string form</p>   <p>IssueResponseResponse to <code>IssueRequest</code>signed_document_json stringVerifiable Credential document, signed with public key tied to caller of <code>IssueRequest</code></p>     <p>Warning</p> <p><code>IssueCredential</code> requires a valid JSON-LD document to be provided. Do not confuse this operation with Issue Credential From Template.</p> <p>When provided a valid credential, this endpoint creates and appends the <code>proof</code> object, using a key pair tied to the issuing Trinsic account.</p> <p>You can learn more about how to create these documents, and about VC data models in general, from W3C: VC Data Model v1.1. </p>","title":"Issue Credential"},{"location":"reference/services/credential-service/#issue-credential-from-template","text":"<p>Issues a credential from a previously-defined template.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic vc issue-from-template [OPTIONS] --template-id &lt;ID&gt;\n\n# OPTIONS\n# --out &lt;OUTPUT_FILE&gt;     (Optional) Output file to store the issued credential\n# --values-data &lt;JSON&gt;    The JSON values of the credential subject\n# --values-file &lt;FILE&gt;    The file with JSON values of the credential subject\n</code></pre>   <pre><code>let request = IssueFromTemplateRequest.fromPartial({\n  templateId: templateResponse?.data?.id ?? \"\",\n  valuesJson: JSON.stringify({\n    name: \"Alice\",\n    numberOfBags: 2,\n    dateOfBirth: new Date(\"1/1/2000\").toISOString(),\n    vaccinated: true,\n  }),\n});\n\nlet response = await trinsic.credential().issueFromTemplate(request);\n</code></pre>   <pre><code>var credentialJson = await trinsic.Credential.IssueFromTemplateAsync(new() {\n    TemplateId = templateId,\n    ValuesJson = values\n});\n</code></pre>   <pre><code>values = json.dumps({\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"age\": \"42\"})\nissue_response = await trinsic_service.credential.issue_from_template(\n    request=IssueFromTemplateRequest(\n        template_id=template.data.id, values_json=values\n    )\n)\n</code></pre>   <pre><code>issueTemplateResponse, err := trinsic.Credential().IssueFromTemplate(context.Background(),\n    &amp;credential.IssueFromTemplateRequest{\n        ValuesJson: valuesJson,\n        TemplateId: templateId,\n    })\n</code></pre>   <pre><code>var valuesMap = new HashMap&lt;String, Object&gt;();\nvaluesMap.put(\"firstName\", \"Jane\");\nvaluesMap.put(\"lastName\", \"Doe\");\nvaluesMap.put(\"age\", 42);\nvar valuesJson = new Gson().toJson(valuesMap);\nvar issueResponse =\n    trinsic\n        .credential()\n        .issueFromTemplate(\n            IssueFromTemplateRequest.newBuilder()\n                .setTemplateId(template.getData().getId())\n                .setValuesJson(valuesJson)\n                .build())\n        .get();\n</code></pre>      <p>IssueFromTemplateRequestRequest to create and sign a JSON-LD Verifiable Credential from a template using public key tied to callertemplate_id stringID of template to usevalues_json stringJSON document string with keys corresponding to the fields of the template referenced by <code>template_id</code>framework_id optional stringGovernance framework ID to use with issuance of this credential. If specified, the issued credential will contain extended issuer metadata with membership info for the given ecosystem governance framework (EGF)</p>   <p>IssueFromTemplateResponseResponse to <code>IssueFromTemplateRequest</code>document_json stringVerifiable Credential document, in JSON-LD form, constructed from the specified template and values; signed with public key tied to caller of <code>IssueFromTemplateRequest</code></p>","title":"Issue Credential from Template"},{"location":"reference/services/credential-service/#check-revocation-status","text":"<p>Checks a credential's revocation status by its <code>credential_status_id</code>.</p> <p>A <code>credential_status_id</code> can be found in a credential's <code>credentialStatus.id</code> field, if present.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic vc get-status --credential-status-id &lt;ID&gt;\n</code></pre>   <pre><code>var checkResponse = await trinsic.Credential.CheckStatusAsync(new() { CredentialStatusId = \"\" });\n</code></pre>   <pre><code>#     check_response = await trinsic_service.credential.check_status(\n#         request=CheckStatusRequest(credential_status_id=\"\")\n#     )\n</code></pre>   <pre><code>status, err := trinsic.Credential().CheckStatus(context.Background(), &amp;credential.CheckStatusRequest{CredentialStatusId: \"\"})\n</code></pre>   <pre><code>var checkStatusResponse =\n    trinsic.credential().checkStatus(CheckStatusRequest.newBuilder().build()).get();\n</code></pre>      <p>CheckStatusRequestRequest to check a credential's revocation statuscredential_status_id stringCredential Status ID to check. This is not the same as the credential's ID.</p>   <p>CheckStatusResponseResponse to <code>CheckStatusRequest</code>revoked boolThe credential's revocation status</p>","title":"Check Revocation Status"},{"location":"reference/services/credential-service/#update-revocation-status","text":"<p>Updates the revocation status of a credential (revoke or unrevoke).</p> <p>A <code>credential_status_id</code> can be found in a credential's <code>credentialStatus.id</code> field, if present.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code># Revoke a credential\ntrinsic vc update-status --revoked --credential-status-id &lt;ID&gt;\n\n# Unrevoke a credential\ntrinsic vc update-status --unrevoked --credential-status-id &lt;ID&gt;\n</code></pre>   <pre><code>await trinsic.Credential.UpdateStatusAsync(new() { CredentialStatusId = \"\", Revoked = true });\n</code></pre>   <pre><code>#     update_response = await trinsic_service.credential.update_status(\n#         request=UpdateStatusRequest(credential_status_id=\"\", revoked=True)\n#     )\n</code></pre>   <pre><code>updateResponse, err := trinsic.Credential().UpdateStatus(context.Background(), &amp;credential.UpdateStatusRequest{CredentialStatusId: \"\", Revoked: true})\n</code></pre>   <pre><code>trinsic.credential().updateStatus(UpdateStatusRequest.newBuilder().build());\n</code></pre>      <p>UpdateStatusRequestRequest to update a credential's revocation statuscredential_status_id stringCredential Status ID to update. This is not the same as the credential's ID.revoked boolNew revocation status of credential</p>   <p>UpdateStatusResponseResponse to <code>UpdateStatusRequest</code>This message has no fields</p>","title":"Update Revocation Status"},{"location":"reference/services/credential-service/#create-proof","text":"<p>Creates and signs a proof for a valid JSON-LD credential, using the BBS+ Signature Suite.</p> <p>If the credential is stored in a Trinsic cloud wallet, pass its <code>item_id</code>; otherwise, pass the raw JSON-LD credential via <code>document_json</code>.</p> <p>If <code>reveal_document_json</code> is passed, a proof will be generated for only the fields specified.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic vc create-proof --document-id &lt;STRING&gt; --out &lt;OUTPUT_FILE&gt; --reveal-document &lt;JSONLD_FRAME_FILE&gt;\n</code></pre>   <pre><code>let proof = await trinsic.credential().createProof(\n  CreateProofRequest.fromPartial({\n    itemId: insertItemResponse.itemId,\n    revealDocumentJson: getVaccineCertFrameJSON(),\n  })\n);\n</code></pre>   <pre><code>var proof = await trinsic.Credential.CreateProofAsync(new() {\n    DocumentJson = credentialJson.DocumentJson,\n    RevealDocumentJson = frame.ToString(Formatting.None)\n});\n</code></pre>   <pre><code>proof_response = await trinsic_service.credential.create_proof(\n    request=CreateProofRequest(\n        reveal_document_json=proof_request_json, document_json=credential_json\n    )\n)\n</code></pre>   <pre><code>request := &amp;credential.CreateProofRequest{\n    Proof: &amp;credential.CreateProofRequest_DocumentJson{\n        DocumentJson: credentialJson,\n    },\n}\n\nproofResponse, err := trinsic.Credential().CreateProof(context.Background(), request)\n</code></pre>   <pre><code>var createProofResponse =\n    trinsic\n        .credential()\n        .createProof(\n            CreateProofRequest.newBuilder()\n                .setDocumentJson(signedCredentialJson)\n                .setRevealDocumentJson(proofRequestJson)\n                .build())\n        .get();\n\nvar credentialProof = createProofResponse.getProofDocumentJson();\n</code></pre>      <p>CreateProofRequestRequest to create a proof for a Verifiable Credential using public key tied to caller. Either <code>item_id</code> or <code>document_json</code> may be provided, not both.reveal_document_json stringA valid JSON-LD frame describing which fields should be revealed in the generated proof.  If unspecified, all fields in the document will be revealeditem_id stringID of wallet item stored in a Trinsic cloud walletdocument_json stringA valid JSON-LD Verifiable Credential document string  with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet.</p>   <p>CreateProofResponseResponse to <code>CreateProofRequest</code>proof_document_json stringValid JSON-LD proof for the specified credential</p>     <p>Selective Disclosure</p> <p>BBS+ Signatures support the ability to generate a proof for a subset of a credential's fields, instead of every field.</p> <p>This enables increased user privacy: fields which aren't included in <code>reveal_document_json</code> will not be present in the generated proof.</p> <p>We are working on documentation for the expected structure of <code>reveal_document_json</code> and will make it available soon.</p>","title":"Create Proof"},{"location":"reference/services/credential-service/#verify-proof","text":"<p>Verifies a proof for validity and authenticity. Only supports BBS+ Signatures at present.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code># The JSONLD_FILE refers to the proof document obtained from a CreateProofResponse\ntrinsic vc issuer verify-proof --proof-document &lt;JSONLD_FILE&gt;\n</code></pre>   <pre><code>let verifyResponse = await trinsic.credential().verifyProof({\n  proofDocumentJson: proof.proofDocumentJson,\n});\n</code></pre>   <pre><code>var valid = await trinsic.Credential.VerifyProofAsync(new() { ProofDocumentJson = proof.ProofDocumentJson });\n</code></pre>   <pre><code>verify_result = await trinsic_service.credential.verify_proof(\n    request=VerifyProofRequest(proof_document_json=credential_proof)\n)\n</code></pre>   <pre><code>verifyResponse, err := trinsic.Credential().VerifyProof(context.Background(), &amp;credential.VerifyProofRequest{\n    ProofDocumentJson: proofJson,\n})\n</code></pre>   <pre><code>var verifyProofResponse =\n    trinsic\n        .credential()\n        .verifyProof(\n            VerifyProofRequest.newBuilder().setProofDocumentJson(credentialProof).build())\n        .get();\n\nboolean isValid = verifyProofResponse.getIsValid();\n</code></pre>      <p>VerifyProofRequestRequest to verify a proofproof_document_json stringJSON-LD proof document string to verify</p>   <p>VerifyProofResponseResponse to <code>VerifyProofRequest</code>is_valid boolWhether all validations in <code>validation_results</code> passedvalidation_messages string[]Use <code>validation_results</code> insteadvalidation_results map(string -&gt; ValidationMessage)Results of each validation check performed,  such as schema conformance, revocation status, signature, etc. Detailed results are provided for failed validations.Show child attributesvalidation_results[key].is_valid boolWhether or not this validation check passedvalidation_results[key].messages string[]If validation failed, contains messages explaining why</p>     Validation Results <p>The verification process performs a number of validations, each of which may fail independently of the others.</p> <p>For example, a credential may be expired or revoked, but otherwise perfectly valid.</p> <p><code>validation_results</code> contains an entry for each of the following verification steps:</p>    Name Description     <code>SignatureVerification</code> Cryptographic signature validity of proof   <code>CredentialStatus</code> (if supported by credential) Checks if credential has been revoked   <code>SchemaConformance</code> Ensures credential conforms with its schema   <code>TrustRegistryMembership</code> (if relevant) Verifies that credential issuer is an authorized member of the credential's governing Trust Registry   <code>IssuerIsSigner</code> Document <code>issuer</code> is same DID as document signer. If false, it is not safe to assume that the claimed <code>issuer</code> actually issued the credential.","title":"Verify Proof"},{"location":"reference/services/credential-service/#exchange-credentials","text":"","title":"Exchange Credentials"},{"location":"reference/services/credential-service/#send-via-email","text":"<p>Sends a credential to a user via email.</p> <p>The specified email address must be tied to an existing account in the same ecosystem.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic vc send --email &lt;EMAIL_ADDRESS&gt; --item &lt;FILE&gt;\n</code></pre>   <pre><code>await credentialService.send(document, \"admin@example.com\");\n</code></pre>   <pre><code>var sendResponse = await trinsic.Credential.SendAsync(new() { Email = \"example@trinsic.id\" });\n</code></pre>   <pre><code>send_response = await trinsic_service.credential.send(\n    request=SendRequest(\n        document_json=credential_json, email=\"example@trinsic.id\"\n    )\n)\n</code></pre>   <pre><code>sendResponse, err := trinsic.Credential().Send(context.Background(), &amp;credential.SendRequest{\n    DeliveryMethod: &amp;credential.SendRequest_Email{\n        Email: \"example@trinsic.id\",\n    },\n    DocumentJson: credentialJson,\n})\n</code></pre>   <pre><code>trinsic\n    .credential()\n    .send(\n        SendRequest.newBuilder()\n            .setDocumentJson(signedCredentialJson)\n            .setEmail(recipientEmail)\n            .build());\n</code></pre>      <p>SendRequestRequest to send a document to another user's walletemail stringEmail address of user to send item todid_uri stringDID of recipient (presently unsupported)didcomm_invitation_json stringDIDComm out-of-band invitation JSON (presently unsupported)document_json stringJSON document to send to recipient</p>   <p>SendResponseResponse to <code>SendRequest</code>This message has no fields</p>     <p>Alternative Exchange Protocols</p> <p>During this beta period, credentials may only be sent to a wallet via email address or with the InsertItem call.</p> <p>There are a number of ongoing industry efforts to standardize exchange protocols, such as:</p> <ul> <li>DIDComm Messaging </li> <li>Wallet And Credential Interactions </li> <li>OpenID Connect Credential Provider </li> </ul> <p>We aim to provide support for these methods as they mature.</p>","title":"Send via Email"},{"location":"reference/services/provider-service/","text":"<p>The Provider Service enables the creation and management of ecosystems and webhooks.</p>  <p>Named vs Anonymous ecosystems</p> <p>There are two types of ecosystems: named and anonymous.</p> <p>Named ecosystems are suitable for production, and will be prepared for you by Trinsic during onboarding.</p> <p>Anonymous ecosystems have auto-generated names (such as <code>eager-elephant-94jkn5h</code>), and may be created by anyone at any time.</p> <p>Using an anonymous ecosystem for purposes other than prototyping and testing is considered an unauthorized use of Trinsic's platform.</p>","title":"Provider Service"},{"location":"reference/services/provider-service/#create-ecosystem","text":"<p>Creates a new ecosystem, along with a root controlling account.</p> <p>If <code>name</code> is left empty, an anonymous ecosystem will be created.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic provider create-ecosystem --name &lt;ECOSYSTEM_NAME&gt; --email &lt;OWNER_EMAIL&gt;\n</code></pre>   <pre><code>let createResponse = await trinsic.provider().createEcosystem(\n  CreateEcosystemRequest.fromPartial({\n    description: \"Test ecosystem from Node\",\n    uri: \"https://example.com\",\n  })\n);\n</code></pre>   <pre><code>var (ecosystem, authToken) = await trinsic.Provider.CreateEcosystemAsync(new() {\n    Description = \"My ecosystem\",\n    Uri = \"https://example.com\"\n});\n</code></pre>   <pre><code>actual_create = await trinsic_service.provider.create_ecosystem(\n    request=CreateEcosystemRequest(\n        description=\"My ecosystem\", uri=\"https://example.com\"\n    )\n)\n</code></pre>   <pre><code>actualCreate, err := trinsic.Provider().CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n    Description: \"My ecosystem\",\n    Uri:         \"https://example.com\",\n})\n</code></pre>   <pre><code>var response =\n    trinsic\n        .provider()\n        .createEcosystem(\n            CreateEcosystemRequest.newBuilder()\n                .setDescription(\"My ecosystem\")\n                .setUri(\"https://example.com\")\n                .build())\n        .get();\n</code></pre>      <p>CreateEcosystemRequestRequest to create an ecosystemname optional stringGlobally unique name for the Ecosystem. This name will be part of the ecosystem-specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen. If not passed, ecosystem name will be auto-generated.description optional stringEcosystem descriptionuri optional stringExternal URL associated with your organization or ecosystem entitydetails AccountDetailsThe account details of the owner of the ecosystemShow child attributesdetails.name optional stringAccount namedetails.email optional stringEmail address of accountdetails.sms optional stringSMS number including country code</p>   <p>CreateEcosystemResponseResponse to <code>CreateEcosystemRequest</code>ecosystem EcosystemDetails of the created ecosystemShow child attributesecosystem.id stringURN of the ecosystemecosystem.name stringGlobally unique name for the ecosystemecosystem.description stringEcosystem descriptionecosystem.uri stringExternal URL associated with the organization or ecosystem entityecosystem.webhooks WebhookConfig[]Configured webhooks, if anyShow child attributesecosystem.webhooks[i].id stringUUID of the webhookecosystem.webhooks[i].destination_url stringHTTPS URL to POST webhook calls toecosystem.webhooks[i].events string[]Events the webhook is subscribed toecosystem.webhooks[i].status stringLast known status of webhook (whether or not Trinsic can successfully reach destination)profile AccountProfileAccount profile for auth of the owner of the ecosystemShow child attributesprofile.profile_type stringThe type of profile, used to differentiate between protocol schemes or versionsprofile.auth_data bytesAuth data containg information about the current device accessprofile.auth_token bytesSecure token issued by server used to generate zero-knowledge proofsprofile.protection TokenProtectionToken security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.Show child attributesprofile.protection.enabled boolIndicates if token is protected using a PIN, security code, HSM secret, etc.profile.protection.method ConfirmationMethodThe method used to protect the tokenShow enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is requiredconfirmation_method ConfirmationMethodIndicates if confirmation of account is required.Show enum valuesConfirmationMethod.None  = 0No confirmation requiredConfirmationMethod.Email  = 1Email confirmation requiredConfirmationMethod.Sms  = 2SMS confirmation requiredConfirmationMethod.ConnectedDevice  = 3Confirmation from a connected device is requiredConfirmationMethod.Other  = 10Third-party method of confirmation is required</p>","title":"Create Ecosystem"},{"location":"reference/services/provider-service/#update-ecosystem","text":"<p>Updates the active ecosystem's <code>description</code> or <code>uri</code>.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic provider update-ecosystem \\\n                 --description \"New description\" \\\n                 --uri \"https://new-example.com\"\n</code></pre>   <pre><code>let updateResponse = await trinsic.provider().updateEcosystem(\n  UpdateEcosystemRequest.fromPartial({\n    description: \"New ecosystem description\",\n    uri: \"https://new-example.com\",\n  })\n);\n</code></pre>   <pre><code>var updateResult = await trinsic.Provider.UpdateEcosystemAsync(new() {\n    Description = \"New ecosystem description\",\n    Uri = \"New ecosystem URI\"\n});\n</code></pre>   <pre><code>request = UpdateEcosystemRequest(\n    description=\"My new description\", uri=\"https://example.com\"\n)\nresponse = await trinsic.provider.update_ecosystem(request=request)\n</code></pre>   <pre><code>updateRequest := &amp;provider.UpdateEcosystemRequest{\n    Description: \"My new description\",\n    Uri:         \"https://new-example.com\",\n}\n\nupdateResponse, err := trinsic.Provider().UpdateEcosystem(context.Background(), updateRequest)\n</code></pre>   <pre><code>var updateResponse =\n    trinsic\n        .provider()\n        .updateEcosystem(\n            UpdateEcosystemRequest.newBuilder()\n                .setDescription(\"My updated ecosystem\")\n                .setUri(\"https://new-example.com\")\n                .build())\n        .get();\n</code></pre>      <p>UpdateEcosystemRequestRequest to update an ecosystem's metadatadescription stringNew description of the ecosystemuri stringNew external URL associated with the organization or ecosystem entity</p>   <p>UpdateEcosystemResponseResponse to <code>UpdateEcosystemRequest</code>Ecosystem EcosystemCurrent ecosystem metadata, post-updateShow child attributesEcosystem.id stringURN of the ecosystemEcosystem.name stringGlobally unique name for the ecosystemEcosystem.description stringEcosystem descriptionEcosystem.uri stringExternal URL associated with the organization or ecosystem entityEcosystem.webhooks WebhookConfig[]Configured webhooks, if anyShow child attributesEcosystem.webhooks[i].id stringUUID of the webhookEcosystem.webhooks[i].destination_url stringHTTPS URL to POST webhook calls toEcosystem.webhooks[i].events string[]Events the webhook is subscribed toEcosystem.webhooks[i].status stringLast known status of webhook (whether or not Trinsic can successfully reach destination)</p>","title":"Update Ecosystem"},{"location":"reference/services/provider-service/#get-ecosystem-info","text":"<p>Fetches information about the active ecosystem.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic provider ecosystem-info\n</code></pre>   <pre><code>const infoResponse = await trinsic\n  .provider()\n  .ecosystemInfo(EcosystemInfoRequest.fromPartial({}));\n\nconst ecosystem = infoResponse.ecosystem;\n</code></pre>   <pre><code>var infoResult = await trinsic.Provider.EcosystemInfoAsync(new());\n</code></pre>   <pre><code>response = await trinsic.provider.ecosystem_info(request=EcosystemInfoRequest())\necosystem = response.ecosystem\n</code></pre>   <pre><code>infoResponse, err := trinsic.Provider().EcosystemInfo(context.Background(), &amp;provider.EcosystemInfoRequest{})\n</code></pre>   <pre><code>var infoResponse =\n    trinsic.provider().ecosystemInfo(EcosystemInfoRequest.getDefaultInstance()).get();\n</code></pre>      <p>EcosystemInfoRequestRequest to fetch information about an ecosystemThis message has no fields</p>   <p>EcosystemInfoResponseResponse to <code>InfoRequest</code>ecosystem EcosystemEcosystem corresponding to requested <code>ecosystem_id</code>Show child attributesecosystem.id stringURN of the ecosystemecosystem.name stringGlobally unique name for the ecosystemecosystem.description stringEcosystem descriptionecosystem.uri stringExternal URL associated with the organization or ecosystem entityecosystem.webhooks WebhookConfig[]Configured webhooks, if anyShow child attributesecosystem.webhooks[i].id stringUUID of the webhookecosystem.webhooks[i].destination_url stringHTTPS URL to POST webhook calls toecosystem.webhooks[i].events string[]Events the webhook is subscribed toecosystem.webhooks[i].status stringLast known status of webhook (whether or not Trinsic can successfully reach destination)</p>","title":"Get Ecosystem Info"},{"location":"reference/services/provider-service/#add-webhook","text":"<p>Adds a webhook to an ecosystem.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic provider add-webhook \\\n                --url \"https://example.com/webhooks/trinsic\" \\\n                --secret \"my well-kept secret\" \\\n                --events \"*\"\n</code></pre>   <pre><code>let addResponse = await trinsic.provider().addWebhook(\n  AddWebhookRequest.fromPartial({\n    destinationUrl: \"https://example.com/webhooks/trinsic\",\n    secret: \"my well-kept secret\",\n    events: [\"*\"],\n  })\n);\n</code></pre>   <pre><code>var addWebhookResponse = await trinsic.Provider.AddWebhookAsync(new() {\n    DestinationUrl = \"https://example.com/webhooks/trinsic\",\n    Secret = \"my well-kept secret\"\n});\n</code></pre>   <pre><code>request = AddWebhookRequest(\n    destination_url=\"https://example.com/webhooks/trinsic\",\n    secret=\"my well-kept secret\",\n)\nrequest.events.append(\"*\")  # Enable all events\n\nresponse = await trinsic.provider.add_webhook(request=request)\n</code></pre>   <pre><code>request := &amp;provider.AddWebhookRequest{\n    DestinationUrl: \"https://example.com/webhooks/trinsic\",\n    Secret:         \"my well-kept secret\",\n    Events:         []string{\"*\"}, // All events\n}\n\nresponse, err := trinsic.Provider().AddWebhook(context.Background(), request)\n</code></pre>   <pre><code>var addWebhookResponse =\n    trinsic\n        .provider()\n        .addWebhook(\n            AddWebhookRequest.newBuilder()\n                .setDestinationUrl(\"https://example.com/webhooks/trinsic\")\n                .setSecret(\"my well-kept secret\")\n                .addEvents(\"*\") // All events\n                .build())\n        .get();\n</code></pre>      <p>AddWebhookRequestRequest to add a webhook to an ecosystemdestination_url stringDestination to post webhook calls to. Must be a reachable HTTPS URL.secret stringSecret string used for HMAC-SHA256 signing of webhook payloads to verify that a webhook comes from Trinsicevents string[]Events to subscribe to. Default is \"*\" (all events)</p>   <p>AddWebhookResponseResponse to <code>AddWebhookRequest</code>ecosystem EcosystemEcosystem data with new webhookShow child attributesecosystem.id stringURN of the ecosystemecosystem.name stringGlobally unique name for the ecosystemecosystem.description stringEcosystem descriptionecosystem.uri stringExternal URL associated with the organization or ecosystem entityecosystem.webhooks WebhookConfig[]Configured webhooks, if anyShow child attributesecosystem.webhooks[i].id stringUUID of the webhookecosystem.webhooks[i].destination_url stringHTTPS URL to POST webhook calls toecosystem.webhooks[i].events string[]Events the webhook is subscribed toecosystem.webhooks[i].status stringLast known status of webhook (whether or not Trinsic can successfully reach destination)</p>     <p>Webhook Limits</p> <p>At present, an ecosystem can have no more than 10 webhooks.</p>   <p>Wallet Webhook Events</p> <p>In order to receive webhooks for events which occur on a wallet, an additional authorization step must be performed.</p> <p>See AuthorizeWebhook for more info.</p>","title":"Add Webhook"},{"location":"reference/services/provider-service/#delete-webhook","text":"<p>Deletes a webhook from an ecosystem.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic provider delete-webhook --webhook-id &lt;WEBHOOK_ID&gt;\n</code></pre>   <pre><code>let deleteResponse = await trinsic.provider().deleteWebhook(\n  DeleteWebhookRequest.fromPartial({\n    webhookId: webhookId,\n  })\n);\n</code></pre>   <pre><code>var deleteWebhookResponse = await trinsic.Provider.DeleteWebhookAsync(new() {\n    WebhookId = webhookId\n});\n</code></pre>   <pre><code>response = await trinsic.provider.delete_webhook(\n    request=DeleteWebhookRequest(webhook_id)\n)\n</code></pre>   <pre><code>request := &amp;provider.DeleteWebhookRequest{\n    WebhookId: webhookId,\n}\n\ndeleteResponse, err := trinsic.Provider().DeleteWebhook(context.Background(), request)\n</code></pre>   <pre><code>var deleteWebhookResponse =\n    trinsic\n        .provider()\n        .deleteWebhook(DeleteWebhookRequest.newBuilder().setWebhookId(webhookId).build())\n        .get();\n</code></pre>      <p>DeleteWebhookRequestRequest to delete a webhook from an ecosystemwebhook_id stringID of webhook to delete</p>   <p>DeleteWebhookResponseResponse to <code>DeleteWebhookRequest</code>ecosystem EcosystemEcosystem data after removal of webhookShow child attributesecosystem.id stringURN of the ecosystemecosystem.name stringGlobally unique name for the ecosystemecosystem.description stringEcosystem descriptionecosystem.uri stringExternal URL associated with the organization or ecosystem entityecosystem.webhooks WebhookConfig[]Configured webhooks, if anyShow child attributesecosystem.webhooks[i].id stringUUID of the webhookecosystem.webhooks[i].destination_url stringHTTPS URL to POST webhook calls toecosystem.webhooks[i].events string[]Events the webhook is subscribed toecosystem.webhooks[i].status stringLast known status of webhook (whether or not Trinsic can successfully reach destination)</p>","title":"Delete Webhook"},{"location":"reference/services/template-service/","text":"<p>The Template Service allows you to manage and search Credential Templates.</p>  <p>Templates are optional</p> <p>Templates are designed to be a helpful abstraction over the complexities of producing valid JSON-LD Verifiable Credentials.</p> <p>You aren't required to use templates; if you produce valid JSON-LD VCs yourself, they can be issued through Trinsic.</p>","title":"Template Service"},{"location":"reference/services/template-service/#create-template","text":"<p>Creates a new credential template.</p> <p>In the background, Trinsic will also generate and save a valid JSON-LD Context and schema for your template.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic template create --name 'My Credential' --fields-data '{\\\"field1\\\":{}}'\n</code></pre>   <pre><code>const credentialTemplateName = `My First Credential Template-${uuid()}`;\nconst nameField = TemplateField.fromPartial({\n  description: \"The name of the person\",\n  type: FieldType.STRING,\n  optional: false,\n});\n\nconst numberOfBags = TemplateField.fromPartial({\n  type: FieldType.NUMBER,\n  description: \"The number of bags the person is taking on the trip\",\n  optional: false,\n});\n\nconst dateOfBirth = TemplateField.fromPartial({\n  type: FieldType.DATETIME,\n  description: \"The date of birth of the person\",\n  optional: false,\n});\n\nconst isVaccinated = TemplateField.fromPartial({\n  type: FieldType.BOOL,\n  description: \"Whether or not the person has been vaccinated\",\n  optional: false,\n});\n</code></pre>   <pre><code>CreateCredentialTemplateRequest templateRequest = new() {\n    Name = \"An Example Credential\",\n    AllowAdditionalFields = false\n};\ntemplateRequest.Fields.Add(\"firstName\", new() { Description = \"Given name\" });\ntemplateRequest.Fields.Add(\"lastName\", new());\ntemplateRequest.Fields.Add(\"age\", new() { Optional = true }); // TODO - use FieldType.NUMBER once schema validation is fixed.\n\nvar template = await trinsic.Template.CreateAsync(templateRequest);\n</code></pre>   <pre><code>template = await trinsic_service.template.create(\n    request=CreateCredentialTemplateRequest(\n        name=f\"An Example Credential: {uuid.uuid4()}\",\n        allow_additional_fields=False,\n        fields={\n            \"firstName\": TemplateField(description=\"Given name\"),\n            \"lastName\": TemplateField(),\n            \"age\": TemplateField(optional=True, type=FieldType.NUMBER),\n        },\n    )\n)\n</code></pre>   <pre><code>templateRequest := &amp;template.CreateCredentialTemplateRequest{Name: fmt.Sprintf(\"Example Template - %s\", uuid.New()), AllowAdditionalFields: false, Fields: make(map[string]*template.TemplateField)}\ntemplateRequest.Fields[\"firstName\"] = &amp;template.TemplateField{Description: \"Given name\"}\ntemplateRequest.Fields[\"lastName\"] = &amp;template.TemplateField{}\ntemplateRequest.Fields[\"age\"] = &amp;template.TemplateField{Type: template.FieldType_NUMBER, Optional: true}\n\ntemplateResponse, err := trinsic.Template().Create(context.Background(), templateRequest)\n</code></pre>   <pre><code>var fields = new HashMap&lt;String, TemplateField&gt;();\nfields.put(\"firstName\", TemplateField.newBuilder().setDescription(\"Given name\").build());\nfields.put(\"lastName\", TemplateField.newBuilder().build());\nfields.put(\n    \"age\", TemplateField.newBuilder().setType(FieldType.NUMBER).setOptional(true).build());\nvar templateRequest =\n    CreateCredentialTemplateRequest.newBuilder()\n        .setName(\"My Example Credential-\" + UUID.randomUUID())\n        .setAllowAdditionalFields(false)\n        .putAllFields(fields)\n        .build();\nvar template = trinsic.template().create(templateRequest).get();\n</code></pre>      <p>CreateCredentialTemplateRequestRequest to create a new templatename stringName of new templatefields map(string -&gt; TemplateField)Fields which compose the templateShow child attributesfields[key].description stringHuman-readable description of the fieldfields[key].optional boolWhether this field may be omitted when a credential is issued against the templatefields[key].type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4allow_additional_fields boolWhether credentials may be issued against this template which have fields not specified in <code>fields</code></p>   <p>CreateCredentialTemplateResponseResponse to <code>CreateCredentialTemplateRequest</code>data TemplateDataCreated templateShow child attributesdata.id stringTemplate IDdata.name stringTemplate namedata.version int32Template version numberdata.fields map(string -&gt; TemplateField)Fields defined for the templateShow child attributesdata.fields[key].description stringHuman-readable description of the fielddata.fields[key].optional boolWhether this field may be omitted when a credential is issued against the templatedata.fields[key].type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4data.allow_additional_fields boolWhether credentials issued against this template may  contain fields not defined by templatedata.schema_uri stringURI pointing to template JSON schema documentdata.context_uri stringURI pointing to template JSON-LD context documentdata.ecosystem_id stringID of ecosystem in which template residesdata.type stringTemplate type (<code>VerifiableCredential</code>)data.created_by stringID of template creator</p>","title":"Create Template"},{"location":"reference/services/template-service/#get-template","text":"<p>Fetches a template definition by <code>id</code>.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic template get --id &lt;TEMPLATE_ID&gt;\n</code></pre>   <pre><code>var getTemplateResponse = await trinsic.Template.GetAsync(new() { Id = template.Data.Id });\n</code></pre>   <pre><code>get_template_response = await trinsic_service.template.get(\n    request=GetCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre>   <pre><code>getResponse, err := trinsic.Template().Get(context.Background(), &amp;template.GetCredentialTemplateRequest{Id: templateResponse.Data.Id})\n</code></pre>   <pre><code>var getResponse =\n    trinsic.template().get(GetCredentialTemplateRequest.newBuilder().setId(id).build()).get();\n</code></pre>      <p>GetCredentialTemplateRequestRequest to fetch a template by IDid stringID of template to fetch</p>   <p>GetCredentialTemplateResponseResponse to <code>GetCredentialTemplateRequest</code>template TemplateDataTemplate fetched by IDShow child attributestemplate.id stringTemplate IDtemplate.name stringTemplate nametemplate.version int32Template version numbertemplate.fields map(string -&gt; TemplateField)Fields defined for the templateShow child attributestemplate.fields[key].description stringHuman-readable description of the fieldtemplate.fields[key].optional boolWhether this field may be omitted when a credential is issued against the templatetemplate.fields[key].type FieldTypeThe type of the fieldShow enum valuesFieldType.STRING  = 0FieldType.NUMBER  = 1FieldType.BOOL  = 2FieldType.DATETIME  = 4template.allow_additional_fields boolWhether credentials issued against this template may  contain fields not defined by templatetemplate.schema_uri stringURI pointing to template JSON schema documenttemplate.context_uri stringURI pointing to template JSON-LD context documenttemplate.ecosystem_id stringID of ecosystem in which template residestemplate.type stringTemplate type (<code>VerifiableCredential</code>)template.created_by stringID of template creator</p>","title":"Get Template"},{"location":"reference/services/template-service/#delete-template","text":"<p>Deletes a credential template by <code>id</code>.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic tamplate delete --id &lt;TEMPLATE_ID&gt;\n</code></pre>   <pre><code>var deleteTemplateResponse = await trinsic.Template.DeleteAsync(new() { Id = template.Data.Id });\n</code></pre>   <pre><code>delete_template_response = await trinsic_service.template.delete(\n    request=DeleteCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre>   <pre><code>deleteResponse, err := trinsic.Template().Delete(context.Background(), &amp;template.DeleteCredentialTemplateRequest{Id: templateResponse.Data.Id})\n</code></pre>   <pre><code>var deleteResponse =\n    trinsic\n        .template()\n        .delete(DeleteCredentialTemplateRequest.newBuilder().setId(id).build())\n        .get();\n</code></pre>      <p>DeleteCredentialTemplateRequestRequest to delete a template by IDid stringID of template to delete</p>   <p>DeleteCredentialTemplateResponseResponse to <code>DeleteCredentialTemplateRequest</code>This message has no fields</p>","title":"Delete Template"},{"location":"reference/services/template-service/#search-templates","text":"<p>Searches all templates defined in the current ecosystem, and a <code>continuation_token</code> to paginate large result sets.</p> <p>If no <code>query</code> is specified, this call by default returns the first 100 templates.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic wallet search \\\n    --query \"SELECT * FROM c\"\n</code></pre>   <pre><code>var searchTemplateResponse = await trinsic.Template.SearchAsync(new() { Query = \"SELECT * FROM c\" });\n</code></pre>   <pre><code>search_template_response = await trinsic_service.template.search(\n    request=SearchCredentialTemplatesRequest(query=\"SELECT * FROM c\")\n)\n</code></pre>   <pre><code>searchResponse, err := trinsic.Template().Search(context.Background(), &amp;template.SearchCredentialTemplatesRequest{Query: \"SELECT * FROM c\"})\n</code></pre>   <pre><code>var searchResponse =\n    trinsic\n        .template()\n        .search(\n            SearchCredentialTemplatesRequest.newBuilder()\n                .setQuery(\"SELECT * FROM c WHERE c.id = '\" + id + \"'\")\n                .build())\n        .get();\n</code></pre>      <p>SearchCredentialTemplatesRequestRequest to search templates using a SQL queryquery stringSQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code>continuation_token optional stringToken provided by previous <code>SearchCredentialTemplatesResponse</code> if more data is available for query</p>   <p>SearchCredentialTemplatesResponseResponse to <code>SearchCredentialTemplatesRequest</code>items_json stringRaw JSON data returned from queryhas_more boolWhether more results are available for this query via <code>continuation_token</code>continuation_token stringToken to fetch next set of results via <code>SearchCredentialTemplatesRequest</code></p>","title":"Search Templates"},{"location":"reference/services/template-service/#advanced-search","text":"<p>The Search endpoint supports SQL queries through the <code>query</code> parameter.</p> <p>This allows for arbitrary query predicates, as well as more advanced functionality -- such as modifying the output format.</p>","title":"Advanced Search"},{"location":"reference/services/template-service/#schema","text":"<p>Any table name may be used in your query (we use <code>c</code> here) -- it doesn't matter what it is.</p>    Name Type Description     id string Corresponds to the <code>id</code> returned when template was created   type string Always <code>VerifiableCredential</code>   ecosystemId string ID of ecosystem in which template resides   createdBy string ID of account which defined the template   name string Name provided during template creation   schemaUri string HTTPS URL pointing to JSON Schema generated by Trinsic for this template   contextUri string HTTPS URL pointing to JSON-LD Context generated by Trinsic for this template   version int Version of template; increments whenever template is modified.   fields object JSON Object representing the template's fields    <p>Note that <code>fields</code> is an object, not a string; thus, any of its sub-fields may be queried against.</p>  <p>More Info</p> <p>This endpoint works very similarly to querying Wallet items; please see Wallet Service &gt; Search for more information.</p>","title":"Schema"},{"location":"reference/services/trust-registry-service/","text":"<p>The Trust Registry Service exposes functionality for managing Trust Registries -- lists of authorized issuers for the various credential types within an ecosystem.</p>  <p>Under Construction</p> <p>This section -- and the underlying API -- is under active development.</p> <p>We are working to define exactly how Trust Registries will be implemented within our platform; this page and API may change as we do so.</p>","title":"Trust Registry Service"},{"location":"reference/services/trust-registry-service/#create-governance-framework","text":"<p>Creates a Governance Framework and attaches it to the current ecosystem.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry register-efg\n</code></pre>   <pre><code>var schemaUri = \"https://schema.org/Card\";\nvar frameworkUri = \"https://example.com\";\nvar registerFrameworkResponse = await trinsic.TrustRegistry.AddFrameworkAsync(new() {\n    Name = \"Demo framework\",\n    Description = \"My governance framework\",\n    GovernanceFrameworkUri = frameworkUri\n});\n</code></pre>   <pre><code>register_framework_response = await trinsic_service.trust_registry.add_framework(\n    request=AddFrameworkRequest(\n        governance_framework_uri=https_example_com,\n        description=\"Demo framework\",\n        name=framework_name,\n    )\n)\n</code></pre>   <pre><code>newFramework, err := trinsic.TrustRegistry().AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n    GovernanceFrameworkUri: frameworkURI,\n    Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n})\n</code></pre>   <pre><code>var frameworkResponse =\n    trinsic\n        .trustRegistry()\n        .addFramework(\n            AddFrameworkRequest.newBuilder()\n                .setGovernanceFrameworkUri(frameworkUri)\n                .setName(\"Example Framework\" + UUID.randomUUID())\n                .build())\n        .get();\n</code></pre>      <p>AddFrameworkRequestRequest to register a new ecosystem governance framework in the current ecosystemgovernance_framework_uri stringURI of governance framework organizationname stringName of governance framework organizationdescription stringDescription of governance framework</p>   <p>AddFrameworkResponseResponse to <code>AddFrameworkRequest</code>id stringUnique framework identifiergoverning_authority stringDID URI of Trinsic account which created the governance frameworktrust_registry stringURN of trust registry for governance framework</p>","title":"Create Governance Framework"},{"location":"reference/services/trust-registry-service/#register-issuer","text":"<p>Registers an authorized issuer for a specific credential type (identified by its <code>schema_uri</code>).</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry register-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>var didUri = \"did:example:test\";\nvar registerMemberResponse = await trinsic.TrustRegistry.RegisterMemberAsync(new() {\n    DidUri = didUri,\n    FrameworkId = registerFrameworkResponse.Id,\n    SchemaUri = schemaUri\n});\n</code></pre>   <pre><code>await trinsic_service.trust_registry.register_member(\n    request=RegisterMemberRequest(\n        did_uri=did_example_test,\n        framework_id=register_framework_response.id,\n        schema_uri=https_schema_org,\n    )\n)\n</code></pre>   <pre><code>registerMemberResponse, err := trinsic.TrustRegistry().RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n    FrameworkId: newFramework.Id,\n    SchemaUri:   schemaURI,\n    Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n})\n</code></pre>   <pre><code>var memberResponse =\n    trinsic\n        .trustRegistry()\n        .registerMember(\n            RegisterMemberRequest.newBuilder()\n                .setDidUri(didUri)\n                .setFrameworkId(frameworkResponse.getId())\n                .setSchemaUri(typeUri)\n                .build())\n        .get();\n</code></pre>      <p>RegisterMemberRequestRequest to register a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.did_uri stringDID URI of member to registerwallet_id stringTrinsic Wallet ID of member to registeremail stringEmail address of member to register. Must be associated with an existing Trinsic account.schema_uri stringURI of credential schema to register member as authorized issuer ofvalid_from_utc uint64Unix Timestamp member is valid from. Member will not be considered valid before this timestamp.valid_until_utc uint64Unix Timestamp member is valid until. Member will not be considered valid after this timestamp.framework_id stringID of the governance framework that member is being added to</p>   <p>RegisterMemberResponseResponse to <code>RegisterMemberRequest</code>This message has no fields</p>","title":"Register Issuer"},{"location":"reference/services/trust-registry-service/#unregister-issuer","text":"<p>Unregisters an issuer for a specific credential type (identified by its <code>schema_uri</code>).</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry unregister-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>var unregisterResponse = await trinsic.TrustRegistry.UnregisterMemberAsync(new() {\n    DidUri = didUri,\n    FrameworkId = registerFrameworkResponse.Id,\n    SchemaUri = schemaUri\n});\n</code></pre>   <pre><code>unregister_issuer_response = await trinsic_service.trust_registry.unregister_member(\n    request=UnregisterMemberRequest(\n        framework_id=register_framework_response.id,\n        schema_uri=https_schema_org,\n        did_uri=did_example_test,\n    )\n)\n</code></pre>   <pre><code>    unregisterMemberResponse, err := trinsic.TrustRegistry().UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n\n \u22ef\n\n        // Do absolutely nothing\n</code></pre>   <pre><code>trinsic\n    .trustRegistry()\n    .unregisterMember(\n        UnregisterMemberRequest.newBuilder()\n            .setFrameworkId(frameworkResponse.getId())\n            .setDidUri(didUri)\n            .setSchemaUri(typeUri)\n            .build());\n</code></pre>      <p>UnregisterMemberRequestRequest to unregister a member as a valid issuer of a specific credential schema. Only one of <code>did_uri</code>, <code>wallet_id</code>, or <code>email</code> may be specified.did_uri stringDID URI of member to unregisterwallet_id stringTrinsic Wallet ID of member to unregisteremail stringEmail address of member to unregister. Must be associated with an existing Trinsic account.schema_uri stringURI of credential schema to unregister member as authorized issuer offramework_id stringID of the governance framework that member is being removed from</p>   <p>UnregisterMemberResponseResponse to <code>UnregisterMemberRequest</code>This message has no fields</p>","title":"Unregister Issuer"},{"location":"reference/services/trust-registry-service/#check-issuer-status","text":"<p>Check the status of an issuer for a specific credential type.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry check-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>var issuerStatus = await trinsic.TrustRegistry.GetMembershipStatusAsync(new() {\n    DidUri = didUri,\n    GovernanceFrameworkUri = frameworkUri,\n    SchemaUri = schemaUri\n});\n</code></pre>   <pre><code>check_response = await trinsic_service.trust_registry.get_membership_status(\n    request=GetMembershipStatusRequest(\n        did_uri=did_example_test,\n        governance_framework_uri=https_example_com,\n        schema_uri=https_schema_org,\n    )\n)\n</code></pre>   <pre><code>    getMembershipStatusResponse, err := trinsic.TrustRegistry().GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n\n \u22ef\n\n        // Do absolutely nothing\n</code></pre>   <pre><code>var issuerStatus =\n    trinsic\n        .trustRegistry()\n        .getMembershipStatus(\n            GetMembershipStatusRequest.newBuilder()\n                .setDidUri(didUri)\n                .setGovernanceFrameworkUri(frameworkUri)\n                .setSchemaUri(typeUri)\n                .build())\n        .get();\n</code></pre>      <p>GetMembershipStatusRequestRequest to fetch membership status in governance framework for a specific credential schema. Only one of <code>did_uri</code>, <code>x509_cert</code> may be specified.governance_framework_uri stringURI of governance frameworkdid_uri stringDID URI of memberx509_cert stringX.509 certificate of memberschema_uri stringURI of credential schema associated with membership</p>   <p>GetMembershipStatusResponseResponse to <code>GetMembershipStatusRequest</code>status RegistrationStatusStatus of member for given credential schemaShow enum valuesRegistrationStatus.CURRENT  = 0Member is currently authorized, as of the time of the queryRegistrationStatus.EXPIRED  = 1Member's authorization has expiredRegistrationStatus.TERMINATED  = 2Member has voluntarily ceased Issuer role under the specific EGFRegistrationStatus.REVOKED  = 3Member authority under specific EGF was terminated by the governing authorityRegistrationStatus.NOT_FOUND  = 10Member is not associated with given credential schema in the EGF</p>","title":"Check Issuer Status"},{"location":"reference/services/trust-registry-service/#search","text":"<p>Search the registry for registered issuers using a SQL query.</p>   Sample Request Response   Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry search --query &lt;SQL query&gt;\n</code></pre>   <pre><code>var searchResult = await trinsic.TrustRegistry.SearchAsync(new());\n</code></pre>   <pre><code>search_result = await trinsic_service.trust_registry.search()\n</code></pre>   <pre><code>ecosystemList, err := trinsic.TrustRegistry().Search(context.Background(), nil)\n</code></pre>   <pre><code>var searchResult = trinsic.trustRegistry().search().get();\n</code></pre>      <p>SearchRegistryRequestRequest to search all governance frameworks within ecosystemquery stringSQL query to execute against frameworks. Example: <code>SELECT c from c where c.type == 'GovernanceFramework'</code>continuation_token optional stringToken to fetch next set of results, from previous <code>SearchRegistryResponse</code></p>   <p>SearchRegistryResponseResponse to <code>SearchRegistryRequest</code>items_json stringJSON string containing array of resultant objectshas_more boolWhether more data is available to fetch for querycontinuation_token stringToken to fetch next set of results via <code>SearchRegistryRequest</code></p>","title":"Search"},{"location":"reference/services/trust-registry-service/#cache-offline-registry-file","text":"Trinsic CLI   <pre><code>trinsic trust-registry download \n</code></pre>","title":"Cache Offline Registry File"},{"location":"reference/services/wallet-service/","text":"<p>The wallet service is the main interface for interacting with a cloud wallet. </p>  <p>Wallets vs Accounts</p> <p>Wallets and accounts are related and often interchangeable -- each account has an associated wallet, and operations on a wallet are performed using an account's access token.</p> <p>Every account has exactly one wallet. </p>   <p>Wallet Standard</p> <p>This service is designed to follow the recommendations of the Universal Wallet 2020  specification by the W3C Community Credentials Group.</p>","title":"Wallet Service"},{"location":"reference/services/wallet-service/#create-wallet","text":"<p>A wallet is created whenever an account is created.</p> <p>Therefore, to create a wallet, you'll need to create a new account.</p>","title":"Create Wallet"},{"location":"reference/services/wallet-service/#insert-item","text":"<p>Stores a credential (or any other JSON object) in a wallet.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic wallet insert-item --item &lt;INPUT_JSON_FILE&gt;\n</code></pre>   <pre><code>let insertItemResponse = await trinsic.wallet().insertItem(\n  InsertItemRequest.fromPartial({\n    itemJson: issueResponse.signedDocumentJson,\n  })\n);\n</code></pre>   <pre><code>var insertItemResponse = await trinsic.Wallet.InsertItemAsync(new() { ItemJson = credentialJson.DocumentJson });\n</code></pre>   <pre><code>insert_response = await trinsic.wallet.insert_item(\n    request=InsertItemRequest(\n        item_json=credential, item_type=\"VerifiableCredential\"\n    )\n)\n</code></pre>   <pre><code>insertResponse, err := trinsic.Wallet().InsertItem(context.Background(), &amp;wallet.InsertItemRequest{\n    ItemJson: credentialJson,\n    ItemType: \"VerifiableCredential\",\n})\n</code></pre>   <pre><code>var insertResponse =\n    trinsic\n        .wallet()\n        .insertItem(\n            InsertItemRequest.newBuilder()\n                .setItemJson(credentialJson)\n                .setItemType(\"VerifiableCredential\")\n                .build())\n        .get();\n</code></pre>      <p>InsertItemRequestRequest to insert a JSON document into a walletitem_json stringDocument to insert; must be stringified JSONitem_type optional stringItem type (ex. \"VerifiableCredential\")</p>   <p>InsertItemResponseResponse to <code>InsertItemRequest</code>item_id stringID of item inserted into wallet</p>     <p>What can be stored in a wallet?</p> <p>Wallets are mainly intended to hold Verifiable Credentials, but can technically store any JSON blob.</p> <p>If you store a Verifiable Credential in a Wallet, ensure that its <code>item_type</code> is <code>VerifiableCredential</code>.</p> <p>Otherwise, ensure its <code>item_type</code> is not <code>VerifiableCredential</code>.</p>","title":"Insert Item"},{"location":"reference/services/wallet-service/#search-wallet","text":"<p>Searches a wallet, returning all matching items, and a <code>continuation_token</code> to paginate large result sets.</p> <p>If no <code>query</code> is specified, this call by default returns the first 100 items in the wallet.</p>   Sample Request Response   Trinsic CLITypeScriptC#PythonGoJava   <pre><code>trinsic wallet search\n</code></pre>   <pre><code>let items = await trinsic.wallet().search();\n</code></pre>   <pre><code>var walletItems = await trinsic.Wallet.SearchWalletAsync(new());\n</code></pre>   <pre><code>wallet_items = await trinsic.wallet.search_wallet()\n</code></pre>   <pre><code>searchResponse, err := trinsic.Wallet().SearchWallet(context.Background(), &amp;wallet.SearchRequest{})\n</code></pre>   <pre><code>var walletItems = trinsic.wallet().searchWallet().get();\n</code></pre>      <p>SearchRequestRequest to search items in walletquery stringSQL Query to execute against items in walletcontinuation_token optional stringToken provided by previous <code>SearchResponse</code> if more data is available for query</p>   <p>SearchResponseResponse to <code>SearchRequest</code>items string[]Array of query results, as JSON stringshas_more boolWhether more results are available for this query via <code>continuation_token</code>continuation_token stringToken to fetch next set of results via <code>SearchRequest</code></p>     <p>Verifiable Presentation Request Spec</p> <p>In the future, this endpoint will support the Verifiable Presentation Request Spec .</p>","title":"Search Wallet"},{"location":"reference/services/wallet-service/#advanced-search","text":"<p>The Search endpoint supports SQL queries through the <code>query</code> parameter.</p> <p>This allows for arbitrary query predicates, as well as more advanced functionality -- such as modifying the output format.</p>","title":"Advanced Search"},{"location":"reference/services/wallet-service/#schema","text":"<p>Any table name may be used in your query (we use <code>c</code> here) -- it doesn't matter what it is.</p>    Name Type Description     id string Corresponds to the <code>item_id</code> returned when item was inserted into wallet   type string Specified via <code>item_type</code> when item was inserted into wallet   data object The JSON object passed via <code>item_json</code> when item was inserted into wallet    <p>Note that <code>data</code> is an object, not a string; thus, any of its sub-fields may be queried against.</p> <p>For example, <code>SELECT * FROM c WHERE c.data.someField = 'Hello, World!'</code> would match against the following JSON object inserted via InsertItem:</p> <pre><code>{ \n    \"someField\": \"Hello, World!\"\n}\n</code></pre>","title":"Schema"},{"location":"reference/services/wallet-service/#common-sql-queries","text":"","title":"Common SQL Queries"},{"location":"reference/services/wallet-service/#paging","text":"<p>Paging uses the <code>OFFSET</code> clause that takes in a value indicating how many records should be skipped in the returned query. To specify the size of the result set (page size) use the <code>LIMIT</code> clause.</p> <pre><code>SELECT * FROM c OFFSET 10 LIMIT 5\n</code></pre>","title":"Paging"},{"location":"reference/services/wallet-service/#sorting","text":"<p>The optional <code>ORDER BY</code> clause specifies the sorting order for results returned by the query. To control sorting order, specify <code>ASC</code> or <code>DESC</code> at the end; if not specified ascending order is used by default.</p> <pre><code>SELECT * FROM c ORDER BY c.credential.issued DESC\n</code></pre>","title":"Sorting"},{"location":"reference/services/wallet-service/#filtering","text":"<p>The optional WHERE clause (<code>WHERE &lt;filter_condition&gt;</code>) specifies condition(s) that the source JSON items must satisfy for the query to include them in results. A JSON item must evaluate the specified conditions to true to be considered for the result. The index layer uses the <code>WHERE</code> clause to determine the smallest subset of source items that can be part of the result.</p> <pre><code>SELECT * FROM c WHERE c.name = 'Trinsic' AND c.dateCreated &gt;= \"2020-09-30T23:14:25.7251173Z\"\n</code></pre>","title":"Filtering"},{"location":"reference/services/wallet-service/#grouping","text":"<p>The <code>GROUP BY</code> clause divides the query's results according to the values of one or more specified properties. Examples and detailed description on working with grouped results can be found here </p>","title":"Grouping"},{"location":"reference/services/wallet-service/#additional-resources","text":"<p>You can read the full documentation on working with SQL queries on the Azure Cosmos DB website .</p>","title":"Additional Resources"},{"location":"ruby/","text":"<p>The Trinsic Ruby SDK makes it easy to interact with the Trinsic API from any Ruby application. The most recent version of the library can be found on RubyGems. You can find the SDKs source on Github.</p>","title":"The Trinsic Ruby SDK"},{"location":"ruby/#installation-and-configuration","text":"<ul> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>RUBY_DLL_PATH</code> on windows. <code>LD_LIBRARY_PATH</code> for Ruby on Mac/Linux <pre><code>gem install trinsic-services\n</code></pre></li> <li>Test installation by running the following Ruby script: <pre><code>require 'trinsic_services'\n\naccount_service = Trinsic::AccountService.new(nil, Trinsic::trinsic_prod_server)\naccount_profile = account_service.sign_in(nil).profile\nputs account_profile\n</code></pre></li> <li>Output should look something like this: <pre><code>&lt;Services::Account::V1::AccountProfile: profile_type: \"https://trinsic.id/security/v1/oberon\", auth_data: \")urn:trinsic:wallets:bbBEp9EmV1NNWMadBhit2$19ac25ae-2fd0-44d1-9ef7-73cc668e8f7d\", auth_token: \"\u2592\", protection: &lt;Services::Account::V1::TokenProtection: enabled: false, method: :None&gt;&gt;\n</code></pre></li> </ul>","title":"Installation and Configuration"},{"location":"ruby/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API </p>","title":"Next Steps"},{"location":"walkthroughs/vaccination/","text":"<p>This walkthrough demonstrates how a vaccination card can be issued, held, and shared using Verifiable Credentials with Trinsic.</p>","title":"Walkthrough: Build a Vaccine Card"},{"location":"walkthroughs/vaccination/#meet-allison","text":"<p>We'll follow Allison as she obtains a vaccine certificate, stores it in her digital wallet, and presents it to board an airplane.</p> <p>In most credential exchange scenarios, there are three primary roles: Issuer, Holder, and Verifier.</p> <p>Holder: Stores credentials received from issuers, and presents them to verifiers. (Said credentials are often, but not always, attesting information about the holder)</p> <p>Issuer: Signs and issues credentials which attest information about a credential subject.</p> <p>Verifier: Verifies credentials presented by holders.</p> <p>In this case, Allison will be the holder, a vaccination clinic will be the issuer, and an airline will be the verifier. </p>","title":"Meet Allison"},{"location":"walkthroughs/vaccination/#our-sdks","text":"<p>You can follow along using one of our SDKs, or use the Trinsic CLI, which implements full platform functionality.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>Click here for installation instructions for the Trinsic CLI.</p>    <p>Click here for installation instructions for the Node/Browser SDK.</p>   <p>Click here for installation instructions for the .NET SDK.</p>   <p>Click here for installation instructions for the Python SDK.</p>   <p>Click here for installation instructions for the Java SDK.</p>   <p>Click here for installation instructions for the Go SDK.</p>   <p>Click here for installation instructions for the Ruby SDK.</p>","title":"Our SDKs"},{"location":"walkthroughs/vaccination/#ecosystem-setup","text":"<p>Before we begin, you'll need an ecosystem -- somewhere for the resources we're about to create (wallets, templates, credentials) to live.</p>","title":"Ecosystem Setup"},{"location":"walkthroughs/vaccination/#use-existing-ecosystem","text":"<p>If you've already signed up as a customer, you'll have received an email with an ecosystem ID and authentication token. </p> <p>Copy this ecosystem ID down, and skip to the next step.</p>","title":"Use Existing Ecosystem"},{"location":"walkthroughs/vaccination/#create-new-ecosystem","text":"<p>If you don't already have an ecosystem provisioned for you, you'll need to create one first. </p> <p>This will be a sandbox ecosystem; suitable for prototyping and testing, but not production purposes. To receive a production ecosystem, sign up.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic provider create-ecosystem\n</code></pre>   <pre><code>const ecosystem = await trinsic\n  .provider()\n  .createEcosystem(CreateEcosystemRequest.fromPartial({}));\nconst ecosystemId = ecosystem.ecosystem!.id;\n</code></pre>   <pre><code>var trinsic = new TrinsicService(_options);\n\nvar (ecosystem, authToken) = await trinsic.Provider.CreateEcosystemAsync(new());\nvar ecosystemId = ecosystem?.Id;\n</code></pre>   <pre><code>ecosystem = await trinsic_service.provider.create_ecosystem()\necosystem_id = ecosystem.ecosystem.id\n</code></pre>   <pre><code>var ecosystemResponse =\n    trinsic.provider().createEcosystem(CreateEcosystemRequest.getDefaultInstance()).get();\n\nvar ecosystemId = ecosystemResponse.getEcosystem().getId();\n</code></pre>   <pre><code>ecosystem, _ := trinsic.Provider().CreateEcosystem(context.Background(), nil)\necosystemId := ecosystem.Ecosystem.Id\n</code></pre>   <pre><code>ecosystem = trinsic.provider_service.create_ecosystem\necosystem_id = ecosystem.ecosystem.id\n</code></pre>    <p>The response to this call contains the name and ID of your newly-created ecosystem; copy either of these down.</p>  <p>Further Reading: Ecosystems</p> <ul> <li>Learn more about Ecosystems</li> <li>Browse the Provider API reference</li> </ul>","title":"Create New Ecosystem"},{"location":"walkthroughs/vaccination/#create-accounts","text":"<p>We need to create Trinsic accounts for the participants in this credential exchange. Accounts and wallets can be considered interchangeably; all accounts have exactly one associated wallet.</p> <p>Accounts can be created with a single call; they're designed to minimize onboarding friction for your users.</p> <p>The clinic's account will issue the credential, Allison's account will hold it, and the airline's account will verify its contents.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>The CLI makes it easy to create wallets. For demo purposes, we'll create all three on the same machine.</p> <p>When using the CLI, the authentication token of the most recently used account is saved in <code>~/.trinsic</code>. In a real-world scenario, you should back this token up securely.</p> <pre><code>trinsic account login --ecosystem {ECOSYSTEM_ID}\n# Save auth token in `allison.txt` before continuing\n\ntrinsic account login --ecosystem {ECOSYSTEM_ID}\n# Save auth token in `airline.txt` before continuing\n\ntrinsic account login --ecosystem {ECOSYSTEM_ID}\n# Save auth token in `clinic.txt` before continuing\n</code></pre>   <pre><code>// Create 3 different profiles for each participant in the scenario\nconst allison = await trinsic.account().loginAnonymous(ecosystemId);\nconst clinic = await trinsic.account().loginAnonymous(ecosystemId);\nconst airline = await trinsic.account().loginAnonymous(ecosystemId);\n</code></pre> <p>If you would like to save the account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code>var allison = await trinsic.Account.LoginAnonymousAsync(ecosystemId!);\nvar clinic = await trinsic.Account.LoginAnonymousAsync(ecosystemId!);\nvar airline = await trinsic.Account.LoginAnonymousAsync(ecosystemId!);\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code># Create an account for each participant in the scenario\nallison = await trinsic_service.account.login_anonymous(ecosystem_id=ecosystem_id)\nairline = await trinsic_service.account.login_anonymous(ecosystem_id=ecosystem_id)\nclinic = await trinsic_service.account.login_anonymous(ecosystem_id=ecosystem_id)\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code>// Create an account for each participant in the scenario\nvar allison = trinsic.account().loginAnonymous(ecosystemId).get();\nvar clinic = trinsic.account().loginAnonymous(ecosystemId).get();\nvar airline = trinsic.account().loginAnonymous(ecosystemId).get();\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code>// Create an account for each participant in the scenario\nallison, _ := trinsic.Account().LoginAnonymous(context.Background(), ecosystemId)\nairline, _ := trinsic.Account().LoginAnonymous(context.Background(), ecosystemId)\nclinic, _ := trinsic.Account().LoginAnonymous(context.Background(), ecosystemId)\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code># Create an account for each participant in the scenario\nallison = trinsic.account_service.login_anonymous(ecosystem_id)\nclinic = trinsic.account_service.login_anonymous(ecosystem_id)\nairline = trinsic.account_service.login_anonymous(ecosystem_id)\n</code></pre>     <p>Production Usage</p> <p>In this example, we've created anonymous accounts; the only way to access them is by saving the authentication token generated on account creation.</p> <p>In a production scenario, you may want to create accounts tied to a user's email address or phone number. This allows users to securely access their Trinsic cloud wallets at any time.</p> <p>Note that accounts are tied to their ecosystem. If you create an account tied to <code>bob@example.com</code> in the <code>example1</code> ecosystem, it will not be visible in any other ecosystem. The same email address can be used to create accounts in multiple ecosystems.</p>   <p>Further Reading: Accounts and Wallets</p> <ul> <li>Learn more about Wallets</li> <li>Browse the Account API reference</li> <li>Read about authentication tokens and security</li> </ul>","title":"Create Accounts"},{"location":"walkthroughs/vaccination/#define-a-template","text":"<p>Before we can issue a credential, we need to create a Template for it. </p> <p>Templates are simply a list of the fields that a credential can have.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>First, prepare a JSON file which describes your template:</p> templateData.json     <pre><code>{\n    \"firstName\": {\n        \"type\": \"string\",\n        \"description\": \"First name of vaccine recipient\"\n    },\n    \"lastName\": {\n        \"type\": \"string\",\n        \"description\": \"Last name of vaccine recipient\"\n    },\n    \"batchNumber\":{\n        \"type\": \"string\",\n        \"description\": \"Batch number of vaccine\"\n    },\n    \"countryOfVaccination\":{\n        \"type\": \"string\",\n        \"description\": \"Country in which the subject was vaccinated\"\n    }\n}\n</code></pre> <p>Then create the template:</p> <pre><code>trinsic template create -n \"VaccinationCertificate\" --fields-file templateData.json \n</code></pre> <p>The output of this command will include a template ID; copy this down for later use.</p>   <pre><code>//Define all fields\nconst firstNameField = TemplateField.fromPartial({\n  description: \"First name of vaccine recipient\",\n  type: FieldType.STRING,\n});\n\nconst lastNameField = TemplateField.fromPartial({\n  type: FieldType.STRING,\n  description: \"Last name of vaccine recipient\",\n});\n\nconst batchNumberField = TemplateField.fromPartial({\n  type: FieldType.STRING,\n  description: \"Batch number of vaccine\",\n});\n\nconst countryOfVaccinationField = TemplateField.fromPartial({\n  type: FieldType.STRING,\n  description: \"Country in which the subject was vaccinated\",\n});\n\n//Create request\nlet request = CreateCredentialTemplateRequest.fromPartial({\n  name: `VaccinationCertificate-${uuid()}`,\n  fields: {\n    firstName: firstNameField,\n    lastName: lastNameField,\n    batchNumber: batchNumberField,\n    countryOfVaccination: countryOfVaccinationField,\n  },\n});\n\n//Create template\nconst response = await trinsicService\n  .template()\n  .create(request);\nconst template = response.data;\n</code></pre>   <pre><code>// Set active profile to `clinic` so we can create a template\ntrinsic.SetAuthToken(clinic!);\n\n// Prepare request to create template\nCreateCredentialTemplateRequest templateRequest = new() {\n    Name = \"VaccinationCertificate\",\n    AllowAdditionalFields = false\n};\n\ntemplateRequest.Fields.Add(\"firstName\", new() { Description = \"First name of vaccine recipient\" });\ntemplateRequest.Fields.Add(\"lastName\", new() { Description = \"Last name of vaccine recipient\" });\ntemplateRequest.Fields.Add(\"batchNumber\", new() { Description = \"Batch number of vaccine\", Type = FieldType.String });\ntemplateRequest.Fields.Add(\"countryOfVaccination\", new() { Description = \"Country in which the subject was vaccinated\" });\n\n// Create template\nvar template = await trinsic.Template.CreateAsync(templateRequest);\nvar templateId = template?.Data?.Id;\n</code></pre>   <pre><code>template = await trinsic_service.template.create(\n    request=CreateCredentialTemplateRequest(\n        name=f\"VaccinationCertificate-{uuid.uuid4()}\",\n        allow_additional_fields=False,\n        fields={\n            \"firstName\": TemplateField(\n                description=\"First name of vaccine recipient\"\n            ),\n            \"lastName\": TemplateField(description=\"Last name of vaccine recipient\"),\n            \"batchNumber\": TemplateField(\n                description=\"Batch number of vaccine\", type=FieldType.STRING\n            ),\n            \"countryOfVaccination\": TemplateField(\n                description=\"Country in which the subject was vaccinated\"\n            ),\n        },\n    )\n)\n\ntemplate_id = template.data.id\n</code></pre>   <pre><code>// Set active profile to 'clinic'\ntemplateService.setAuthToken(clinic);\n\n// Define fields for template\nvar fields = new HashMap&lt;String, TemplateField&gt;();\nfields.put(\n    \"firstName\",\n    TemplateField.newBuilder().setDescription(\"First name of vaccine recipient\").build());\nfields.put(\n    \"lastName\",\n    TemplateField.newBuilder().setDescription(\"Last name of vaccine recipient\").build());\nfields.put(\n    \"batchNumber\",\n    TemplateField.newBuilder()\n        .setType(FieldType.STRING)\n        .setDescription(\"Batch number of vaccine\")\n        .build());\nfields.put(\n    \"countryOfVaccination\",\n    TemplateField.newBuilder()\n        .setDescription(\"Country in which the subject was vaccinated\")\n        .build());\n\n// Create template request\nvar templateRequest =\n    CreateCredentialTemplateRequest.newBuilder()\n        .setName(\"VaccinationCertificate\")\n        .setAllowAdditionalFields(false)\n        .putAllFields(fields)\n        .build();\n\n// Execute template creation\nvar template = templateService.create(templateRequest).get();\nvar templateId = template.getData().getId();\n</code></pre>   <pre><code>templateRequest := &amp;template.CreateCredentialTemplateRequest{Name: \"VaccinationCertificate\", AllowAdditionalFields: false, Fields: make(map[string]*template.TemplateField)}\ntemplateRequest.Fields[\"firstName\"] = &amp;template.TemplateField{Description: \"First name of vaccine recipient\"}\ntemplateRequest.Fields[\"lastName\"] = &amp;template.TemplateField{Description: \"Last name of vaccine recipient\"}\ntemplateRequest.Fields[\"batchNumber\"] = &amp;template.TemplateField{Description: \"Batch number of vaccine\", Type: template.FieldType_STRING}\ntemplateRequest.Fields[\"countryOfVaccination\"] = &amp;template.TemplateField{Description: \"Country in which the subject was vaccinated\"}\n\ncreatedTemplate, _ := trinsic.Template().Create(context.Background(), templateRequest)\n\ntemplateId := createdTemplate.Data.Id\n</code></pre>   <pre><code>request = Trinsic::Template::CreateCredentialTemplateRequest.new(name: \"VaccinationCertificate-#{SecureRandom.uuid}\",\n                                                                    allow_additional_fields: false)\nrequest.fields['firstName'] = Trinsic::Template::TemplateField.new(description: 'First name of vaccine recipient')\nrequest.fields['lastName'] = Trinsic::Template::TemplateField.new(description: 'Last name of vaccine recipient')\nrequest.fields['batchNumber'] =\n  Trinsic::Template::TemplateField.new(description: 'Batch number of vaccine',\n                                          type: Trinsic::Template::FieldType::STRING)\nrequest.fields['countryOfVaccination'] =\n  Trinsic::Template::TemplateField.new(description: 'Country in which the subject was vaccinated')\n\ntemplate = trinsic.template_service.create(request)\ntemplate_id = template.data.id\n</code></pre>     <p>Templates are Optional</p> <p>Templates are an optional helpful abstraction which removes the need to work directly with complex data formats such as JSON-LD.</p> <p>When a template is used to issue a credential, the result is a valid, interoperable JSON-LD Verifiable Credential.</p> <p>Trinsic's SDKs support issuing JSON-LD credentials that you create yourself, should you choose not to use templates.</p>   <p>Further Reading: Templates</p> <ul> <li>Learn more about Templates</li> <li>Browse the Template API reference</li> </ul>","title":"Define a Template"},{"location":"walkthroughs/vaccination/#issue-a-credential","text":"<p>Upon receiving her vaccine, the clinic issues Allison a Verifiable Credential, which proves that she was given the vaccine by the clinic.</p> <p>A credential is a JSON document that has been cryptographically signed; this signature enables verifiers to trust that the data comes a trusted source, and has not been tampered with.</p> <p>To issue a vaccine certificate, we'll use the template we created in the last step.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>First, prepare a file named <code>values.json</code> with the following content:</p> values.json     <pre><code>{\n    \"firstName\": \"Allison\",\n    \"lastName\": \"Allisonne\",\n    \"batchNumber\": \"123454321\",\n    \"countryOfVaccination\": \"US\"\n}\n</code></pre> <p>Then issue the credential:</p> <pre><code>trinsic config --auth-token $(cat clinic.txt)\ntrinsic vc issue-from-template --template-id {TEMPLATE_ID} --values-file values.json --out credential.json\n</code></pre> <p>The output of this command will contain a signed JSON document, which has been saved to <code>credential.json</code>.</p>   <pre><code>// Prepare the credential values JSON document\nconst credentialValues = JSON.stringify({\n  firstName: \"Allison\",\n  lastName: \"Allisonne\",\n  batchNumber: \"123454321\",\n  countryOfVaccination: \"US\",\n});\n\n// Sign a credential as the clinic and send it to Allison\ntrinsic.options.authToken = clinic;\nconst issueResponse = await trinsic.credential().issueFromTemplate(\n  IssueFromTemplateRequest.fromPartial({\n    templateId: template.id,\n    valuesJson: credentialValues,\n  })\n);\n</code></pre>   <pre><code>// Prepare credential values\nvar credentialValues = new Dictionary&lt;string, string&gt;() {\n    { \"firstName\", \"Allison\" },\n    { \"lastName\", \"Allisonne\" },\n    { \"batchNumber\", \"123454321\" },\n    { \"countryOfVaccination\", \"US\" }\n};\n\n// Issue credential as clinic\nvar issueResponse = await trinsic.Credential.IssueFromTemplateAsync(new() {\n    TemplateId = templateId,\n    ValuesJson = JsonSerializer.Serialize(credentialValues)\n});\n\nvar signedCredential = issueResponse?.DocumentJson;\n</code></pre>   <pre><code># Prepare values for credential\nvalues = json.dumps(\n    {\n        \"firstName\": \"Allison\",\n        \"lastName\": \"Allisonne\",\n        \"batchNumber\": \"123454321\",\n        \"countryOfVaccination\": \"US\",\n    }\n)\n\n# Issue credential\nissue_response = await trinsic_service.credential.issue_from_template(\n    request=IssueFromTemplateRequest(template_id=template.id, values_json=values)\n)\n\ncredential = issue_response.document_json\n</code></pre>   <pre><code>// Set active profile to 'clinic' so we can issue credential signed\n// with the clinic's signing keys\ntrinsicService.setAuthToken(clinic);\n\n// Prepare credential values\nvar valuesMap = new HashMap&lt;String, Object&gt;();\nvaluesMap.put(\"firstName\", \"Allison\");\nvaluesMap.put(\"lastName\", \"Allissonne\");\nvaluesMap.put(\"batchNumber\", \"123454321\");\nvaluesMap.put(\"countryOfVaccination\", \"US\");\n\n// Serialize values to JSON\nvar valuesJson = new Gson().toJson(valuesMap);\n\n// Issue credential\nvar issueResponse =\n    trinsicService\n        .credential()\n        .issueFromTemplate(\n            IssueFromTemplateRequest.newBuilder()\n                .setTemplateId(templateId)\n                .setValuesJson(valuesJson)\n                .build())\n        .get();\n\nvar credential = issueResponse.getDocumentJson();\n</code></pre>   <pre><code>// Prepare values for credential\nvaluesStruct := struct {\n    FirstName            string\n    LastName             string\n    batchNumber          string\n    countryOfVaccination string\n}{\n    FirstName:            \"Allison\",\n    LastName:             \"Allisonne\",\n    batchNumber:          \"123454321\",\n    countryOfVaccination: \"US\",\n}\nvalues, _ := json.Marshal(valuesStruct)\n\n// Issue credential\nissueResponse, _ := trinsic.Credential().IssueFromTemplate(context.Background(), &amp;credential.IssueFromTemplateRequest{\n    TemplateId: createdTemplate.Id,\n    ValuesJson: string(values),\n})\n\nissuedCredential := issueResponse.DocumentJson\n</code></pre>   <pre><code># Prepares values for credential\nvalues = JSON.generate({ firstName: 'Allison', lastName: 'Allisonne', batchNumber: '123454321',\n                         countryOfVaccination: 'US' })\n\n# Issue credential\nissue_response = trinsic.credential_service.issue_from_template(Trinsic::Credentials::IssueFromTemplateRequest.new(\n                                                          template_id: template.id, values_json: values\n                                                        ))\ncredential = issue_response.document_json\n</code></pre>     <p>Further Reading: Issuance and Credentials</p> <ul> <li>Learn more about Verifiable Credentials</li> <li>Browse the Credential API reference</li> </ul>","title":"Issue a Credential"},{"location":"walkthroughs/vaccination/#send-credential-to-allison","text":"<p>Now that the clinic has a signed credential, it must be securely transmitted to Allison, so she can store it in her wallet.</p> <p>Because it's just a JSON string, it could be delivered in many ways -- for example, in the response to an HTTPS request which triggered the issuance process.</p>  <p>Send via Trinsic</p> <p>In the future, we will offer the ability to send a credential directly to a Trinsic user's wallet.</p> <p>Click here to learn more about this feature.</p>","title":"Send Credential to Allison"},{"location":"walkthroughs/vaccination/#store-credential-in-wallet","text":"<p>Once Allison receives the credential, it must be stored in her wallet.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic config --auth-token $(cat allison.txt)\ntrinsic wallet insert-item --item credential.json\n</code></pre>   <pre><code>// Alice stores the credential in her cloud wallet.\ntrinsic.options.authToken = allison;\nconst insertResponse = await trinsic.wallet().insertItem(\n  InsertItemRequest.fromPartial({\n    itemJson: issueResponse.documentJson,\n  })\n);\n</code></pre>   <pre><code>// Set active profile to 'allison' so we can manage her cloud wallet\ntrinsic.SetAuthToken(allison!);\n\n// Insert credential into Allison's wallet\nvar insertItemResponse = await trinsic.Wallet.InsertItemAsync(new() {\n    ItemJson = signedCredential\n});\n\nvar itemId = insertItemResponse?.ItemId;\n</code></pre>   <pre><code># Allison stores the credential in her cloud wallet\ntrinsic_service.service_options.auth_token = allison\n\ninsert_response = await trinsic_service.wallet.insert_item(\n    request=InsertItemRequest(item_json=credential)\n)\n\nitem_id = insert_response.item_id\n</code></pre>   <pre><code>// Set active profile to 'allison' so we can manage her cloud wallet\ntrinsic.setAuthToken(allison);\n\n// Allison stores the credential in her cloud wallet.\nvar insertItemResponse =\n    trinsic\n        .wallet()\n        .insertItem(InsertItemRequest.newBuilder().setItemJson(credential).build())\n        .get();\n\nfinal var itemId = insertItemResponse.getItemId();\n</code></pre>   <pre><code>// Allison stores the credential in her cloud wallet\ntrinsic.SetAuthToken(allison)\ninsertResponse, _ := trinsic.Wallet().InsertItem(context.Background(), &amp;wallet.InsertItemRequest{ItemJson: issuedCredential})\n\nitemId := insertResponse.ItemId\n</code></pre>   <pre><code># Allison stores the credential in her cloud wallet\ntrinsic.auth_token = allison\ninsert_response = trinsic.wallet_service.insert_item(Trinsic::Wallet::InsertItemRequest.new(item_json: credential))\nitem_id = insert_response.item_id\n</code></pre>    <p>The response to this call contains an Item ID; copy this down.</p>  <p>Further Reading: Wallets</p> <ul> <li>Learn more about Wallets</li> <li>Browse the Wallet API reference</li> </ul>","title":"Store Credential in Wallet"},{"location":"walkthroughs/vaccination/#create-a-proof-of-vaccination","text":"<p>Before boarding, the airline requests proof of vaccination from Allison. Specifically, they want to see proof that she holds a <code>VaccinationCertificate</code> credential.</p> <p>Let's use the CreateProof call to build a proof for Allison's held credential.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic config --auth-token $(cat allison.txt)\ntrinsic vc create-proof --item-id \"{ITEM_ID}\" --out proof.json\n</code></pre>   <pre><code>// Allison shares the credential with the venue.\ntrinsic.options.authToken = allison;\nconst proofResponse = await trinsic.credential().createProof(\n  CreateProofRequest.fromPartial({\n    itemId: insertResponse.itemId,\n  })\n);\n</code></pre>   <pre><code>// Build a proof for the signed credential as allison\nvar proofResponse = await trinsic.Credential.CreateProofAsync(new() {\n    ItemId = itemId\n});\n\nvar proofJSON = proofResponse?.ProofDocumentJson;\n</code></pre>   <pre><code># Allison shares the credential with the airline\ntrinsic_service.service_options.auth_token = allison\n\nproof_response = await trinsic_service.credential.create_proof(\n    request=CreateProofRequest(item_id=item_id)\n)\n\ncredential_proof = proof_response.proof_document_json\n</code></pre>   <pre><code>// Set active profile to 'allison' so we can create a proof using her key\ntrinsic.setAuthToken(allison);\n\n// Allison shares the credential with the venue\nvar createProofResponse =\n    trinsic\n        .credential()\n        .createProof(CreateProofRequest.newBuilder().setItemId(itemId).build())\n        .get();\n\nvar credentialProof = createProofResponse.getProofDocumentJson();\n</code></pre>   <pre><code>// Allison shares the credential with the airline\ntrinsic.SetAuthToken(allison)\nproofResponse, _ := trinsic.Credential().CreateProof(context.Background(), &amp;credential.CreateProofRequest{\n    Proof: &amp;credential.CreateProofRequest_ItemId{ItemId: itemId},\n})\n\ncredentialProof := proofResponse.ProofDocumentJson\n</code></pre>   <pre><code># Allison shares the credential with the airline\ntrinsic.auth_token = allison\nproof_response = trinsic.credential_service.create_proof(Trinsic::Credentials::CreateProofRequest.new(item_id: item_id))\ncredential_proof = proof_response.proof_document_json\n</code></pre>    <p>Allison sends this proof to the airline for them to verify.</p>  <p>Partial Proofs</p> <p>In this example, the proof is being created over the entire credential; all of its fields are revealed to the verifier.</p> <p>It is possible for the airline to send Allison a frame which requests only certain fields of the credential. The airline would not be able to see other fields of the credential, but cryptographic guarantees would still hold over the revealed fields.</p> <p>See the CreateProof reference for more information.</p>   <p>OpenID Connect for Presentation</p> <p>Trinsic offers an OpenID Connect service as an alternative flow for the exchange of a credential between a holder and a verifier.</p> <p>In this flow, a holder simply clicks a link (or scans a QR code), logs into their Trinsic cloud wallet, and selects a credential to share. </p>","title":"Create a Proof of Vaccination"},{"location":"walkthroughs/vaccination/#verify-proof","text":"<p>Once the airline receives the proof, they can use the VerifyProof call to ensure its authenticity.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic config --auth-token $(cat airline.txt)\ntrinsic vc verify-proof --proof-document proof.json\n</code></pre>   <pre><code>// The airline verifies the credential\ntrinsic.options.authToken = airline;\nconst verifyResponse = await trinsic.credential().verifyProof(\n  VerifyProofRequest.fromPartial({\n    proofDocumentJson: proofResponse.proofDocumentJson,\n  })\n);\n</code></pre>   <pre><code>// Set active profile to `airline`\ntrinsic.SetAuthToken(airline!);\n\n// Verify that Allison has provided a valid proof\nvar verifyResponse = await trinsic.Credential.VerifyProofAsync(new() {\n    ProofDocumentJson = proofJSON\n});\n\nbool credentialValid = verifyResponse?.IsValid ?? false;\n</code></pre>   <pre><code># The airline verifies the credential\ntrinsic_service.service_options.auth_token = airline\n\nverify_result = await trinsic_service.credential.verify_proof(\n    request=VerifyProofRequest(proof_document_json=credential_proof)\n)\n\nvalid = verify_result.is_valid\n</code></pre>   <pre><code>trinsic.setAuthToken(airline);\n\n// Verify that Allison has provided a valid proof\nvar verifyProofResponse =\n    trinsic\n        .credential()\n        .verifyProof(\n            VerifyProofRequest.newBuilder().setProofDocumentJson(credentialProof).build())\n        .get();\n\nboolean isValid = verifyProofResponse.getIsValid();\n</code></pre>   <pre><code>// The airline verifies the credential\ntrinsic.SetAuthToken(airline)\nverifyResult, _ := trinsic.Credential().VerifyProof(context.Background(), &amp;credential.VerifyProofRequest{ProofDocumentJson: credentialProof})\nvalid := verifyResult.IsValid\n</code></pre>   <pre><code># The airline verifies the credential\ntrinsic.auth_token = airline\n\nverify_result = trinsic.credential_service.verify_proof(\n  Trinsic::Credentials::VerifyProofRequest.new(proof_document_json: credential_proof)\n)\n\nvalid = verify_result.is_valid\n</code></pre>     <p>Interoperability</p> <p>The Verifiable Credentials and Proofs that Trinsic's platform produces are based on open standards.</p> <p>Although we use the VerifyProof call in this example, the proof could be verified using any standards-compliant software.</p>","title":"Verify Proof"},{"location":"walkthroughs/vaccination/#full-source-code","text":"TypescriptC#PythonJavaGoRuby   <p>This sample is available as <code>VaccineDemoShared.ts</code> in our SDK repository.</p>   <p>This sample is available as <code>VaccineWalkthroughTests.cs</code> in our SDK repository.</p>   <p>This sample is available as <code>vaccine_demo.py</code> in our SDK repository.</p>   <p>This sample is available as <code>VaccineDemo.java</code> in our SDK repository.</p>   <p>This sample is available as <code>vaccine_test.go</code> in our SDK repository.</p>   <p>This sample is available as <code>vaccine_demo.rb</code> in our SDK repository.</p>","title":"Full Source Code"},{"location":"walkthroughs/vaccination/#next-steps","text":"<p>Congratulations! If you've completed all the steps of this walkthrough, you've just created a mini ecosystem of issuers, verifiers, and holders all exchanging credentials. Depending on your goals, there are a couple of possible next steps to take. </p> <ul> <li>Try out a sample app</li> <li>Browse the Service Reference</li> <li>Learn more about the key concepts and technologies at play</li> </ul>","title":"Next Steps"},{"location":"web/","text":"<p>The Trinsic Web SDK makes it easy to interact with the Trinsic API from any client-side web application. You can find the SDKs source on Github.</p>","title":"The Trinsic Javascript / Web SDK"},{"location":"web/#installation","text":"<p>Install the package for Node or Browser from npmjs.com </p> Install     <pre><code>npm i @trinsic/trinsic\n</code></pre>","title":"Installation"},{"location":"web/#create-new-project","text":"<p>Let's create a new console app that we will use to add our sample code</p> <pre><code>mkdir web-sample &amp;&amp; cd web-sample &amp;&amp; npm init\n</code></pre> <p>You can select all the defaults for the node project.</p> <p>Add the required dependencies</p> <pre><code>npm i @trinsic/trinsic\n</code></pre> <pre><code>npm i --save-dev http-server webpack webpack-cli\n</code></pre>","title":"Create new project"},{"location":"web/#configure-webpack","text":"<p>After installing the dependencies you'll need a configuration file for webpack. Create a file called webpack.config.js at the root of your project and then copy and paste this into that file</p> <pre><code>const path = require(\"path\");\n\nmodule.exports = {\n    mode: \"development\",\n    entry: \"./src/index.js\",\n    output: {\n        path: path.resolve(__dirname, \"./src\"),\n        filename: \"bundle.js\",\n    },\n};\n</code></pre>","title":"Configure Webpack"},{"location":"web/#configure-webpack-for-react","text":"<p>If using React you may need to start your project with craco</p> <p>Install Craco</p> <pre><code>npm i @craco/craco\n</code></pre> <p>Next change your react scripts in your package.json file</p> <pre><code>\"scripts\": {\n-   \"start\": \"react-scripts start\",\n+   \"start\": \"craco start\",\n-   \"build\": \"react-scripts build\",\n+   \"build\": \"craco build\"\n-   \"test\": \"react-scripts test\",\n+   \"test\": \"craco test\"\n}\n</code></pre> <p>Finally you will need to add a craco configuration file called <code>craco.config.js</code> and add the following:</p> <pre><code>// craco.config.js\n\nconst { addBeforeLoader, loaderByName } = require(\"@craco/craco\");\n\nmodule.exports = {\n    webpack: {\n        configure: (webpackConfig) =&gt; {\n            const wasmExtensionRegExp = /\\.wasm$/;\n            webpackConfig.resolve.extensions.push(\".wasm\");\n\n            webpackConfig.module.rules.forEach((rule) =&gt; {\n                (rule.oneOf || []).forEach((oneOf) =&gt; {\n                    if (\n                        oneOf.loader &amp;&amp;\n                        oneOf.loader.indexOf(\"file-loader\") &gt;= 0\n                    ) {\n                        oneOf.exclude.push(wasmExtensionRegExp);\n                    }\n                });\n            });\n\n            const wasmLoader = {\n                test: /\\.wasm$/,\n                exclude: /node_modules/,\n                loaders: [\"wasm-loader\"],\n            };\n\n            addBeforeLoader(\n                webpackConfig,\n                loaderByName(\"file-loader\"),\n                wasmLoader\n            );\n\n            return webpackConfig;\n        },\n    },\n};\n</code></pre> <p>This allows react loaders to properly load in some of our needed .wasm files.</p>","title":"Configure Webpack for React"},{"location":"web/#set-up-website","text":"<p>Create a simple html page with a script tag referencing the webpack bundle that will be built after completing the sample code. Note that you will not have the bundle.js file yet because it will be generated from the index.js file you create.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;title&gt;Web Sample&lt;/title&gt;\n        &lt;meta charset=\"UTF-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n        &lt;meta name=\"description\" content=\"\" /&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Web Sample&lt;/h1&gt;\n        &lt;div id=\"wallet\"&gt;&lt;/div&gt;\n    &lt;/body&gt;\n    &lt;script src=\"../bundle.js\"&gt;&lt;/script&gt;\n&lt;/html&gt;\n</code></pre> <p>Your file structure should look like this</p> <pre><code>web-sample\n    src\n        index.html\n        index.js\n    package.json\n    webpack.config.js\n</code></pre>","title":"Set up Website"},{"location":"web/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"}]}