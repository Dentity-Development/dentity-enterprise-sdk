{"config":{"indexing":"full","jieba_dict":"","jieba_dict_user":"","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Introduction"},{"location":"#issue-and-verify-universally-accepted-digital-credentials","text":"<p>Trinsic is the proof of anything platform. We make it easy for people and organizations to prove things about themselves with technology instead of paper documents. Our software is based on Decentralized Identifiers (DIDs) and Verifiable Credentials (VCs), a new digital identity standard. </p> <p>Using Trinsic, organizations and their customers share data between each other in a trustworthy, standardized, and privacy-preserving way without requiring a centralized server or database. </p> <p>We make all of this possible by signing, sharing and storing verifiable data within identity wallets owned by individuals. People can easily share them with others to prove things about themselves anywhere.</p> <p>Learn how to issue and verify universally-accepted digital credentials so that anywhere people go online or in-person, they can simply tap their phone, prove who they are, and get what they need.</p>","title":"Issue and verify universally-accepted digital credentials."},{"location":"#our-products","text":"","title":"Our Products"},{"location":"#trinsic-core","text":"<p>Trinsic Core is infrastructure for digital trust. It's our set of APIs for sending verifiable data between digital identity wallets. Core gives people and organizations the ability to easily and securely prove things about themselves with digital credentials.</p> <p>With Core, you can transform credentials, licenses, passes, and certificates into a W3C standard format that can be exchanged digitally and verified instantly by anyone called a \"verifiable credential\".</p>","title":"Trinsic Core"},{"location":"#trinsic-ecosystems","text":"<p>A layer built on top of Core, Trinsic Ecosystems is a product for organizations that want to build an ecosystem of different issuers, holders, and verifiers of credentials. By ecosystem, we mean a network of companies and consumers that need to be able to securely share and instantly verify data. </p> <p>At Trinsic, we call the organizations that bring together these ecosystems of companies and customers \"providers\" since they are providing digital trust to the ecosystem through Trinsic's infrastructure.</p>  <p>Get Started in 15 Minutes</p> <p>Want to get started using digital credentials quickly? Try our tutorial to get a conceptual walkthrough of a common use case.</p>","title":"Trinsic Ecosystems"},{"location":"early-adopter/","text":"<p>For development teams ready to integrate verifiable credentials for a specific industry or use case, Trinsic Ecosystems has been built specifically for you. We're currently in beta with a small group of customers.</p> <p>If you'd like to join the beta for Trinsic Ecosystems, please reach out! Simply fill out the form below, and we'll get in touch.</p> <p>Sign Up</p>","title":"Introducing Trinsic Ecosystems"},{"location":"roadmap/","text":"","title":"Roadmap"},{"location":"roadmap/#sdks","text":"","title":"SDKs"},{"location":"roadmap/#available-sdks","text":"<ul> <li> .NET</li> <li> Node</li> <li> Python</li> <li> Web</li> <li> Java</li> </ul>","title":"Available SDKs"},{"location":"roadmap/#coming-soon","text":"<ul> <li> Android</li> <li> iOS</li> <li> Go</li> <li> Ruby</li> </ul>","title":"Coming Soon"},{"location":"support/","text":"<p>Normally, the best way to ask quick questions is through the Trinsic Community slack channel.</p> <p>If you have a bug to report, please report it on the Github issues on our SDK. Contributions and additions to this docs site are always welcome.</p> <p>Finally, if you're interested in getting in touch with the team for any other reason, contact us at support@trinsic.id. We treat any feedback as gold.</p>","title":"Have a Question?"},{"location":"android/","text":"<p>The Trinsic Android sample application makes it easy to interact with the Trinsic API. The sample application is located here</p>","title":"Android Sample Application"},{"location":"android/#installation","text":"<ol> <li>Clone the <code>sdk-examples</code> repository</li> <li>Open the folder <code>sdk-examples/android</code> in Android Studio</li> <li>Run gradle build for the first time, it will take a while, but it should pull down all the required <code>.jar</code> files</li> <li>You should be able to build and run the android application.</li> <li>There is an <code>sdk-examples/android-controller</code> application written in Python which allows you to issue credentials/verify proofs outside of the android application for demonstration purposes.</li> </ol>  <p>Note</p> <p>If you want to included the two required Trinsic <code>.jar</code> files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p>  <pre><code>def urlFile = { url, name -&gt;\n    File file = new File(\"$buildDir/download/${name}.jar\")\n    file.parentFile.mkdirs()\n    if (!file.exists()) {\n        new URL(url).withInputStream { downloadStream -&gt;\n            file.withOutputStream { fileOut -&gt;\n                fileOut &lt;&lt; downloadStream\n            }\n        }\n    }\n    files(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\n    // other dependencies\n    implementation urlFile('https://github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0')\n    implementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1')\n}\n</code></pre>","title":"Installation"},{"location":"android/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Java API Reference</p>","title":"Next Steps"},{"location":"cli/","text":"<p>The Trinsic CLI makes it easy to interact with the Trinsic API from your terminal. You can get the CLI on homebrew or build the CLI from source on Github. It contains all the commands of Trinsic's SDKs and makes them interactive. </p>","title":"The Trinsic CLI"},{"location":"cli/#installation","text":"MacOS and LinuxWindowsFrom source   <p>We use homebrew to distribute the CLI packages for MacOS and Linux. Install Homebrew</p> <p>Then run these commands to install the Trinsic CLI <pre><code>brew tap trinsic-id/tap\nbrew install trinsic-cli\n</code></pre></p>   <p>The CLI can be installed using Winget <pre><code>winget install trinsic.okapi\nwinget install trinsic.cli\n</code></pre></p>   <p>The CLI can also be built from source.</p> <p>This requires the Rustup toolchain  installed on your system.</p> <p>Once installed, run this command in terminal:</p> <pre><code>cargo +nightly install --git https://github.com/trinsic-id/sdk trinsic\n</code></pre> <p>To verify that the CLI has been installed successfully, try running:</p> <pre><code>trinsic --help\n</code></pre>","title":"Installation"},{"location":"cli/#next-steps","text":"<p>Once the CLI is installed, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference. For more information about the CLI, read the configuration guide</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"},{"location":"cli/config/","text":"<p>The CLI stores its configuration in the user's home directory in <code>~/.trinsic/</code>. This directory contains the main configuration file <code>config.toml</code> and all the profile data.</p>","title":"Configuration"},{"location":"cli/config/#show-configuration","text":"<p>To print the current configuration file in the terminal use:</p> <pre><code>trinsic config --show\n</code></pre> <p>Typical configuration file may look like this:</p> <pre><code>[server]\naddress = \"https://prod.trinsic.cloud\"\n\n[profile]\ndefault = \"my_profile\"\n</code></pre>","title":"Show Configuration"},{"location":"cli/config/#update-configuration-entry","text":"<p>To change the configuration values, use the <code>config</code> subcommand with the attribute and its value.</p> <pre><code>trinsic config &lt;attribute_name&gt; &lt;attribute_value&gt;\n</code></pre> <p>The following attributes are currently supported:</p>  <code>server-address</code>  <p>Updates the default server address the CLI communicates</p> <pre><code>trinsic config --server-address https://example.com/\n</code></pre>  <code>profile-default</code>  <p>Updates the default profile used with the CLI</p> <pre><code>trinsic config --profile-default alice\n</code></pre>","title":"Update Configuration Entry"},{"location":"cli/demo/","text":"","title":"Trinsic CLI Demo"},{"location":"cli/demo/#steps-to-run","text":"<ul> <li>Click the green Run button</li> <li>Follow walkthrough</li> <li>Note: If you resize this window, make sure to reload the page. If not, the CLI will have display problems.</li> </ul>","title":"Steps to Run"},{"location":"dotnet/","text":"<p>The Trinsic C# / .NET SDK makes it easy to interact with the Trinsic API from your .NET application. The most recent version of the library can be found on NuGet. The Trinsic SDK supports .NET applications written in C#, VB.NET, and F# that utilize any supported version of .NET Core. You can also find the SDKs source on Github.</p>  <p>Supported runtimes</p> <p>.NET targets for iOS, Android, and Blazor are fully supported using the same package dependencies via .NET 6.</p>","title":"The Trinsic C# / .NET SDK"},{"location":"dotnet/#installation-in-a-new-project","text":"<p>Add the required dependencies from Nuget.org </p> Package Manager.NET CLIPackageReference   <pre><code>PM&gt; Install-Package Trinsic\n</code></pre>   <pre><code>dotnet add package Trinsic\n</code></pre>   <pre><code>&lt;PackageReference Include=\"Trinsic\" /&gt;\n</code></pre>","title":"Installation in a new project"},{"location":"dotnet/#configuration","text":"<pre><code>// accountServiceConstructor() {\nvar myAccountService = new AccountService(_options);\n// }\n// accountServiceSignIn() {\nvar myProfile = await myAccountService.SignInAsync(new());\n// }\nmyAccountService.Options.AuthToken = myProfile;\n// accountServiceGetInfo() {\nvar output = await myAccountService.GetInfoAsync();\n// }\nAssert.NotNull(output);\n</code></pre>","title":"Configuration"},{"location":"dotnet/#next-steps","text":"<p>Once the .NET SDK package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API C# API Reference</p>","title":"Next Steps"},{"location":"go/","text":"<p>The Trinsic Go SDK makes it easy to interact with the Trinsic API from any Go application. The most recent version of the library can be found on ____. You can find the SDKs source on Github.</p>","title":"The Trinsic Go SDK"},{"location":"go/#installation-and-configuration","text":"<ul> <li>NOTE: Windows installation is possible, but requires jumping through a few hoops. More details to come later.</li> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>You need to have CGO configured for the okapi native binary link</li> <li>Issue the following command: <pre><code>go install github.com/trinsic-id/sdk/go@latest\n</code></pre></li> <li>To test the installation, try the following go code:</li> </ul> <pre><code>opts, err := sdk.NewServiceOptions()\nif err != nil {\n    panic(\"could not create service options\")\n}\naccountService, err := sdk.NewAccountService(opts)\nif err != nil {\n    panic(\"Account service not created\")\n}\n\nprofile, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\nif err != nil {\n    panic(\"Sign in failed!\")\n}\nfmt.Printf(\"%v\\n\", profile)\n</code></pre>","title":"Installation and Configuration"},{"location":"go/#next-steps","text":"<p>Once the go package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Go API Reference</p>","title":"Next Steps"},{"location":"ios/","text":"<p>The Trinsic Swift SDK makes it easy to interact with the Trinsic API from any application built for iOS, MacCatalyst, or MacOS. The SDK is available for Swift Package Manager and can be added in your dependency section in <code>Package.swift</code> as follows:</p> <pre><code>dependencies: [\n    .package(name: \"Trinsic\", url: \"https://github.com/trinsic-id/sdk-swift\", branch: \"main\")\n],\n</code></pre> <p>You can find more details, source code, and tests for the Swift SDK at trinsic-id/sdk-swift.</p>","title":"The Trinsic Swift SDK"},{"location":"java/","text":"<p>The Trinsic Java SDK makes it easy to interact with the Trinsic API from any Java application. The most recent version of the package is found on the Github Release. You can find the SDKs source on Github.</p>","title":"The Trinsic Java SDK"},{"location":"java/#installation","text":"<ol> <li>Add the <code>urlFile</code> code shown below to your <code>build.gradle</code>.</li> <li>Add the implementations as shown below to your <code>build.gradle</code>.</li> <li>Run <code>gradle build</code> to download the required jar files. This can take some time.</li> </ol>","title":"Installation"},{"location":"java/#configuration","text":"<ol> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>LD_LIBRARY_PATH</code>, even on Windows.</li> </ol>  <p>Note</p> <p>If you want to included the two required Trinsic <code>.jar</code> files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p>  <pre><code>def urlFile = { url, name -&gt;\n    File file = new File(\"$buildDir/download/${name}.jar\")\n    file.parentFile.mkdirs()\n    if (!file.exists()) {\n        new URL(url).withInputStream { downloadStream -&gt;\n            file.withOutputStream { fileOut -&gt;\n                fileOut &lt;&lt; downloadStream\n            }\n        }\n    }\n    files(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\n    // other dependencies\n    implementation urlFile('https://github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0')\n    implementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1')\n}\n</code></pre>","title":"Configuration"},{"location":"java/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Java API Reference</p>","title":"Next Steps"},{"location":"learn/","text":"<p>Understand the key concepts involved when using Trinsic, or work through our tutorials to learn how to build out specific functionality.</p>","title":"Learn"},{"location":"learn/credentials/","text":"<p></p> <p>\"Verifiable Credentials\", or \"VCs\" are digital documents that conform to the W3C Verifiable Credential Data Model. VCs provide a standard for digitally issuing, holding, and verifying data about a subject. A verifiable credential is a set of tamper-evident claims and metadata that cryptographically prove who issued it.  https://www.w3.org/TR/vc-data-model/</p> <p>Verifiable credentials are unique from other kinds of digital documents because they enable you to verify the following things: </p> <ol> <li>The original issuing entity (the source of the data) </li> <li>It was issued to the entity presenting it (the subject of the data) </li> <li>It hasn't been tampered with (the veracity of the data)</li> <li>Whether the issuer revoked the credential as of a particular point in time (the status of the data)</li> </ol> <p>trust triangle</p>","title":"What are Verifiable Credentials"},{"location":"learn/credentials/#components-of-a-credential","text":"<p>To break down the components of a credential, we'll use a digital driver's license as an example.</p>","title":"Components of a Credential"},{"location":"learn/credentials/#issuer-did","text":"<p>As you can see from the diagram above, a verifier will only accept a credential if they trust its source. For example, in the United States a TSA agent will only let you on an airplane if you present a valid driver's license (or other gov ID); they do this because they trust the DMV or other agency that issued it. In order to validate where a credential came from, verifiers use the issuer's DID.</p> <p>Each new issuer is assigned an issuer DID. The issuer DID acts as a public-facing address or public key. In self-sovereign identity, these DIDs are usually written to a public blockchain, but other locations are possible, too. Each issuer DID has an associated private key which is used to cryptographically \"sign\" each issued credential. In fact, each attribute inside the credential is signed in this manner, allowing the holder of the credential to share only a subset of the attributes when desired. For example, someone could share their name and age from their driver's license without sharing the driver's license number, address, and hair color. Using the issuer DID and straightforward public-private key cryptography, anyone can verify the attributes in the credential were attested to by the issuer. </p>","title":"Issuer DID"},{"location":"learn/credentials/#schema","text":"<p>Each credential needs a template so the data can be shared and interpreted correctly. That template is called a Schema.</p> <p>Schemas are the general structure of the credential. In our example, they tell us what information must be included on the driver's license in order for it to be valid, like Full name, Address, Eye color, etc. </p> <p>In short, they are the attributes that you want to include in this credential.</p>","title":"Schema"},{"location":"learn/credentials/#example","text":"<pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"description\": \"Email\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"emailAddress\": {\n            \"type\": \"string\",\n            \"format\": \"email\"\n            }\n        },\n    \"required\": [\"emailAddress\"],\n    \"additionalProperties\": false\n}\n</code></pre> <p>Schemas are nonproprietary; any issuer can view/use the schemas written by any other issuer.</p> <p>We abstract schema creation away into the same action as creation of a credential template. Keep reading to read how to create a schema and credential template. </p>","title":"Example:"},{"location":"learn/credentials/#verifications","text":"<p>Passes are documents generated from credentials that contain only the information required to be verified. They can be generated in advance or in real-time. Passes minimize the information about you that is shared with third parties.</p> <p>Credentials are signed using BLS keys. These create from the credential fields. </p>","title":"Verifications"},{"location":"learn/ecosystems/","text":"<p>Exchanging credentials often requires many different participants to all communicate and collaborate. Aligning standards and incentives is challenging. </p> <p>We've made it simple to create an ecosystem of participants to all exchange credentials. </p>","title":"Ecosystems"},{"location":"learn/ecosystems/#potential-scenarios","text":"<p>Industry groups, enterprises, and startups who are deploying this technology to multi-party ecosystems. Our focus on building for interoperability, hyper-scalability, and ease of use means you can get to market faster with a better product with Trinsic than any other way. </p> <p>Trust ecosystems are networks of participants that can authenticate to and share data with one another. Trust ecosystems exist all around us, but most are analog and disaggregated. The first trust ecosystems to go digital were payments networks. Visa, MasterCard, etc. introduced a standard mechanism to allow consumers to make purchases with any merchant using credit from any bank. Visa created an enduring business while simultaneously unlocking value for all participants involved.</p> <p>Credit card networks represent only one kind of trust ecosystem. A trust ecosystem at a minimum has the following 4 roles.</p> <ul> <li>Provider - provides the tools and rules to the rest of the participants to ensure a healthy ecosystem, generally through a product experience that is sold to the other participants</li> <li>Issuer - is the source of data that is shared throughout an ecosystem</li> <li>Verifier - consumes data in an ecosystem</li> <li>Holder - holds data, and is generally the subject of the data, in an ecosystem</li> </ul>","title":"Potential Scenarios"},{"location":"learn/ecosystems/#anatomy-of-a-trust-ecosystem","text":"<p>Before diving into the value provided by each participant, it\u2019s helpful to cover how it works at a high level. You may dive deeper into any of these items by clicking into the respective pages. We\u2019ll use the analogy of a payment network to conceptualize the purpose of each component.</p> <p>Wallet - A place to securely store verifiable credentials.</p> <p>Credential - W3C Verifiable Credentials that contain valuable data about a subject. These are signed and issued by an issuer.</p> <p>Pass - A presentation of a verifiable credential that only includes the information required for use case.</p> <p>Underlying Tech - All of the additional standardized technology Trinsic uses to build trust ecosystems.</p>","title":"Anatomy of a Trust Ecosystem"},{"location":"learn/ecosystems/#value-of-trust-ecosystems-to-participants","text":"<p>The first step to successfully building a trust ecosystem that can scale is to identify the value for each of the participants. Here we will elaborate on the value derived by each actor in an ecosystem and how Trinsic\u2019s platform is optimized to help deliver it.</p>","title":"Value of Trust Ecosystems to Participants"},{"location":"learn/ecosystems/#providers","text":"<p>Providers typically already have, or are building, a product or platform to sell to the issuers and verifiers with the goal of creating a sustainable business. </p> <p>Visa, for example, isn\u2019t a currency, a bank, or a merchant. They sell the rails for transaction settlement to banks and merchants to enable the seamless transactions we all enjoy. By taking a small interchange fee, they capture value alongside the banks and merchants and have built a sustainable business.</p> <p>Trinsic is the only company to offer a product tailored specifically for providers. That means instead of patching together various open source components meant for issuers or verifiers, Trinsic offers a product built from the ground-up to accommodate the unique needs of providers. Ultimately, that means providers using Trinsic get to market faster with better products.</p>","title":"Providers"},{"location":"learn/ecosystems/#issuers","text":"<p>Issuers realize value when they extend or augment their existing business operations. By issuing the data they already have in verifiable credential form, they often can increase revenue, reduce verification costs, and improve brand presence. </p> <p>When credit cards were in their infancy, banks began issuing cards because it allowed them to continue their existing business (giving credit) in a new way. Likewise, the issuers that get the most value from verifiable credentials are ones who already have data about people, and simply need to give it to them in a new way (e.g. medical labs who already give paper documents can now give digital form).</p> <p>Trinsic\u2019s platform is optimized to both reduce onboarding costs and add help issuers scale without increasing their costs</p> <ul> <li>Before credit cards banks could offer various consumer loans</li> </ul>","title":"Issuers"},{"location":"learn/ecosystems/#holders","text":"<p>Holders acquire the most convenient way to prove something about themselves digitally, both in-person and online</p> <ul> <li>Before credit cards, consumers needed to pay with paper. Paying with credit meant bespoke processes with each individual retailer (e.g. opening a tab at a bar, creating a Macy\u2019s account, etc). Likewise today our digital identities are all siloed and separate, resulting in a myriad of problems for consumers.</li> </ul>","title":"Holders"},{"location":"learn/ecosystems/#verifiers","text":"<p>Verifiers get instant, trusted authentication and verification without needing to maintain their own infrastructure</p> <ul> <li>Before credit card networks like Visa, merchants needed to issue credit and manage collections in-house if they wanted customers who could buy on credit. Likewise, companies in virtually every industry have compliance, risk, and identity departments where they manage this in-house. Just as Visa turned electronic payments into a simple terminal installation for merchants, so too will trust ecosystems unlock the ability for verifiers of all kinds to focus on their true business without compromising on trust and security.</li> </ul> <p>Like the internet itself, trust over IP represents a massive business opportunity for innovators in all industries. And like the internet itself, the vast majority of the value will be created at the application layer.</p>","title":"Verifiers"},{"location":"learn/intro/","text":"<p>Trinsic is a hosting provider for identity wallets and an SDK for developers that want to interact with them. You can use Trinsic to give your end-users identity wallets and then share, store, and verify data through them.</p>","title":"What is Trinsic?"},{"location":"learn/intro/#wallets","text":"<p>Identity Wallets are secure, partitioned data stores for information that needs to get verified. This normally is a person, but it can also be an organization or a device. </p> <p>You can use Trinsic's platform to invite end-users to create a cloud-hosted identity wallet that can be accessed on any device using multi-factor passwordless authentication. </p> <p>Once created, applications and organizations can issue data to the identity wallet. Other applications can request to verify information from the wallet. If the end-user accepts the request, a proof of the requested information will be created and sent to the requester. </p> <p>Using identity wallets, you can build powerful products that preserve your end-users' privacy without compromising on convenience.</p> <p>Wallet Service</p>","title":"Wallets"},{"location":"learn/intro/#credentials-proofs","text":"<p>Trinsic's wallets are built to represent verifiable data as credentials. This allows any information sent to the identity wallet to be easily verified using interoperable standards. Because we follow a standardized open data model, identity wallets can bridge software platforms, letting individuals use their data wherever they choose. </p> <p>To minimize the amount of information that is requested from identity wallets, a credential's attributes can be filtered to generate a proof of the credential with only the data required to fulfill a verifier's request.</p> <p>Credential Service</p>","title":"Credentials &amp; Proofs"},{"location":"learn/intro/#templates","text":"<p>Credential templates let you publish a credential format for others to follow. There are often more than one issuer of the same type of credential, and this allows issuers to reuse the same credential format and share the same attribute types. </p> <p>When data models can be reused, more interoperability can be achieved between different systems. This lets data that previously had to be manually entered via form or sent via custom API integration get automatically exchanged and verified without needing human interaction. </p> <p>Template Service</p>","title":"Templates"},{"location":"learn/intro/#trust-registries","text":"<p>A trust registry is a way for a wallet to publish a list of other wallets that it trusts to issue and verifier credentials. </p> <p>This is useful when building trust without a centralized service or database. If you onboard wallets, it is likely that the wallet holders already have a connection with you. You can publish a list of issuers and verifiers that you've also vetted and onboarded and the wallet holders can reference this list before receiving or sharing their information with another wallet.</p> <p>When verifying a credential, a verifier can cross-reference the issuer's identifier within the credential with a trust registry to ensure it was actually issued by an organization that they trust.</p> <p>Trust Registry Service</p>","title":"Trust Registries"},{"location":"learn/intro/#ecosystems","text":"<p>When creating a product that uses identity wallets, it is useful to have the tools to onboard participants that want to either issue, store, or verify credentials. Trinsic Ecosystems is a set of tools built so you can invite participants to an ecosystem and configure their wallets for them. This makes it possible to quickly go live with a proof of concept or pilot without requiring your ecosystem participants to do any setup or integrations themselves.</p> <p>Provider Service</p>","title":"Ecosystems"},{"location":"learn/intro/#open-standards","text":"<p>Trinsic's technology is all based on open web standards. Our goal is to promote a future of applications where identity and personal data is independent from applications. To meet this end, we use decentralized identifiers that can be generated and resolved without needing a centralized database. We also follow the data model for verifiable credentials so that data sent by one application can be presented at another without requiring a specific vendor. </p> <p>Learn More</p>","title":"Open Standards"},{"location":"learn/intro/#security-and-privacy","text":"<p>As a hosting provider of identity wallets, we've recognized the need for strong security and privacy since before we started building. </p> <p>Our identity wallets are secured using zero knowledge authentication. No private keys are stored or processed on our servers. They are all generated locally by our SDKs. We do this using a lightweight zero-knowledge proof protocol. Even if an adversary were to intercept a payload, they would not be able to reuse the token to gain additional access to our system.</p> <p>Learn More</p>","title":"Security and Privacy"},{"location":"learn/security/","text":"","title":"Security Infrastructure"},{"location":"learn/security/#overview","text":"<p>Our cloud services are secured using a novel method of authentication based on zero-knowledge proofs . This approach allows us to introduce passwordless client authentication with improved security and user experience.</p> <p>Compared to traditional security methods that store users' credentials on the server, our approach relies on a one-time client/server negotiation without storing any user secrets on our servers. All secrets are stored with the user client and are entirely in their control. During authentication, users present proof of knowledge of these secret tokens, instead of the actual tokens. This proof is generated with each request and is unique for that request only.</p>","title":"Overview"},{"location":"learn/security/#zero-knowledge-architecture","text":"<p>TODO: Comparison to traditional security models</p>","title":"Zero-knowledge Architecture"},{"location":"learn/security/#oberon-auth-scheme","text":"<p>A succinct ZKP protocol for authentication. It works by using techniques similar to Identity-Based/Attribute-Based signatures.</p> <p>Oberon allows endpoints to issue multi-factor capable tokens to consumers who can prove their validity without disclosing the tokens themselves and without requiring email, SMS, or authenticator apps. Endpoints only need to store a single public key and not any tokens. An attacker that breaks into the server doesn't have any password/token files to steal and only would see a public key. The proof of token validity is only 256 bytes while the token itself is only 48 bytes. The issuing party and verifying servers can be separate entities.</p> <p>Crypto details for Oberon </p>","title":"Oberon Auth Scheme"},{"location":"learn/security/#account-registration","text":"<p>The below diagram illustrates how client and server interact during the registration process and negotiate the data for authentication:</p> <pre><code>sequenceDiagram\n  actor Client\n  Client-&gt;&gt;Server: Register new account or ecosystem\n  Server--&gt;&gt;Client: Generated token\n  Note right of Server: Does not store token\n  opt\n    Note over Client: Apply multi-factor security&lt;br /&gt;using PIN, word phrase, HSM, etc.&lt;br /&gt;by cryptographically blinding&lt;br/&gt;the secret token\n    Client-&gt;&gt;Client: Token protection\n  end\n  Client-&gt;&gt;Client: Save token on client device</code></pre>","title":"Account Registration"},{"location":"learn/security/#api-requests","text":"<p>The process of making authenticated API requests against the server involves generating a proof of knowledge and appending it to the request headers. This proof is:</p> <ul> <li>valid for a limited time only (order of milliseconds)</li> <li>unique and cannot be used twice (replay protection)</li> <li>bound to the current request payload (mitm protection)</li> </ul> <p>The diagram below illustrates the steps involved in generating proof and interacting with the server.</p> <pre><code>sequenceDiagram\n    actor U as Client\n    participant A as Server\n\n    U-&gt;&gt;U: Read Token\n    U-&gt;&gt;U: Generate proof of token\n    U-&gt;&gt;A: Make API Request\n    note right of U: Proof is added in 'Authorization' header\n\n    A-&gt;&gt;A: Check authorization\n\n    alt sucesss\n        A-&gt;&gt;A: Process request\n        A--&gt;&gt;U: Send response\n    else invalid proof\n        A--&gt;&gt;U: 401 Unauthorized\n    end</code></pre>","title":"API Requests"},{"location":"learn/standards/","text":"","title":"Underlying Tech"},{"location":"learn/standards/#linked-data","text":"<p>When we consider credentials getting exchanged online far and wide, a problem starts to occur - how does everyone know what every else means when they show a credential? To the rescue comes Linked Data, a format for representing structured data with self-contained descriptors of that data.</p> <p>\"Linked data is to spreadsheets and databases what the web of hypertext documents is to word processor files\" - W3C Wiki on Linked Data</p>","title":"Linked Data"},{"location":"learn/standards/#decentralized-identifiers","text":"<p>Taken from the Verifiable Credential Data Model, a decentralized identifier is \"a portable URL-based identifier, also known as a DID, associated with an entity. These identifiers are most often used in a verifiable credential and are associated with subjects such that a verifiable credential itself can be easily ported from one repository to another without the need to reissue the credential. An example of a DID is <code>did:example:123456abcdef</code>\"</p>","title":"Decentralized Identifiers"},{"location":"learn/standards/#zero-knowledge-proofs","text":"<p>One of the most exciting qualities of verifiable credentials are their ability to minimize the data shared about you when you prove who you are. The classic example is showing your driver's license in a bar. While a human bouncer may forget all the revealing information on your driver's license, a computerized bouncer that scans your driver's license never forgets any information. With zero knowledge proofs, you can choose specific information from your credentials to share with verifiers.</p> <p>These are enabled through a BBS+ Signature specification.</p>","title":"Zero Knowledge Proofs"},{"location":"learn/templates/","text":"<p>Trinsic's credential templates make it easy to define types of credentials and publish these types for multiple issuers all to use. Credential templates will create two things to include in a credential: a json schema and a json ld context. Templates remove all of that complexity and let you define a list of attributes along with the attribute types and descriptions. </p> <p>This an example of a list of attributes that would comprise a credential template: </p> <pre><code>{\n    \"name\": {\n        \"type\": \"string\",\n        \"description\": \"Name of the business\",\n    },\n    \"website\": {\n        \"type\": \"string\",\n        \"description\": \"More information about the business\"\n    },\n    \"rating\":{\n        \"type\": \"number\",\n        \"description\": \"rating on scale of 1-10\",\n        \"optional\": false\n    },\n    \"details\":{\n        \"type\": \"string\",\n        \"description\": \"An individual's last name\",\n        \"optional\": false\n    }\n}\n</code></pre> <p>This will create a Template that has the following structure: <pre><code>TemplateData {\n    id: \"urn:template:alices-local-guides:review\",\n    name: \"Review\",\n    version: 1,\n    fields: {\n        \"name\": TemplateField {\n            description: \"Name of the business\",\n            optional: false,\n            r#type: String,\n        },\n        \"rating\": TemplateField {\n            description: \"rating on scale of 1-10\",\n            optional: false,\n            r#type: Number,\n        },\n        \"details\": TemplateField {\n            description: \"An individual's last name\",\n            optional: false,\n            r#type: String,\n        },\n        \"website\": TemplateField {\n            description: \"More information about the business\",\n            optional: false,\n            r#type: String,\n        },\n    },\n    allow_additional_fields: true,\n    schema_uri: \"https://staging-schema.trinsic.cloud/__default/review\",\n    context_uri: \"https://staging-schema.trinsic.cloud/__default/review/context\",\n    ecosystem_id: \"__default\",\n    r#type: \"VerifiableCredential\",\n}\n</code></pre> You can view the <code>schema_uri</code> and the <code>context_uri</code> in the browser as raw json</p>","title":"Credential Templates"},{"location":"learn/wallets/","text":"","title":"Wallets"},{"location":"learn/wallets/#what-are-wallets","text":"<p>A wallet is a secure place to store credentials. You can create a wallet using the Trinsic CLI or SDK and begin using it to store and share credentials.  Wallet storage is scoped to a single person or subject. Each wallet has the capability to store and share credentials and proofs. A provider wallet can also define templates, create an ecosystem governance framework, and invite wallets to their ecosystem. </p> <p>Data wallets are meant to help individuals manage their digital credentials and cryptographic keys. </p>","title":"What are wallets?"},{"location":"learn/wallets/#how-to-use-wallets-in-your-app","text":"<p>Instead of users creating accounts when they sign up for your app, users can instead connect their wallet. Because many users will be first-time wallet holders, if a user is signing up for your app and they don't have a wallet, we make it easy to create new wallets for your users with the <code>invite</code> command. Once you've invited a user to a wallet, they can enter the 2fa code to log in. </p> <p>You can give each of your end-users a wallet tied to their email address or phone number. </p>","title":"How to use wallets in your app"},{"location":"learn/wallets/#wallet-architecture","text":"<p>While wallets are hosted on our server, your client application must connect with the wallet (using device stored keys). Wallet communication is peer to peer. </p> <p>Wallets can be thought of a little like an email inbox. Each wallet can only be accessed by a set of keys stored on devices. </p>","title":"Wallet Architecture"},{"location":"learn/wallets/#commands","text":"<ul> <li>Store Item</li> <li>Search</li> <li>Send</li> </ul>","title":"Commands"},{"location":"node/","text":"<p>The Trinsic Node SDK makes it easy to interact with the Trinsic API from any backend javascript application. The most recent version of the library can be found on npm. You can find the SDKs source on Github.</p>","title":"The Trinsic Javascript / Node SDK"},{"location":"node/#installation","text":"<p>Install the package for Node from npmjs.com </p> Install   <pre><code>npm i @trinsic/trinsic\n</code></pre>","title":"Installation"},{"location":"node/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference.</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"},{"location":"python/","text":"<p>The Trinsic Python SDK makes it easy to interact with the Trinsic API from any Python application. The most recent version of the library can be found on PyPi. You can find the SDKs source on Github.</p>","title":"The Trinsic Python SDK"},{"location":"python/#installation-and-configuration","text":"<ul> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>LD_LIBRARY_PATH</code>, even on Windows.</li> <li>Recommended: Create a virtual environment</li> <li>Install the trinsic package <pre><code>pip install trinsic-sdk\n</code></pre></li> <li>Test installation by running the following python script:</li> </ul> <pre><code>import asyncio\nfrom trinsic.services import AccountService\n\nasync def demo():\n    account_service = AccountService()\n    profile = await account_service.sign_in()\n    print(profile)\n    account_service.close()\nif __name__ == \"__main__\":\n    asyncio.run(demo())\n</code></pre> <ul> <li>The output should look something like this: <pre><code>AccountProfile(profile_type='https://trinsic.id/security/v1/oberon', auth_data=b'\\n*urn:trinsic:wallets:JkhchLXS8NDwTjmJjNogkQ\\x12$1d58106c-325a-4f45-abe0-6a14aa613a10', auth_token=b'\\x83E\\x06p\\xd60V\\xe0D\\x12NU\\xe7\\n6\\x06\\x19 \\x0b\\xe0\\x8er\\xf2\\xc1\\xb3\\x96\\xdb\\xbd/\\xf5#\\xa7\\xe7F\\x10\\x97E\\xe2\\xa9\\xc4\\x10\\xdfJ\\xbe\\xea\\xa3Fz', protection=TokenProtection())\n</code></pre></li> </ul>","title":"Installation and Configuration"},{"location":"python/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Python API Reference</p>","title":"Next Steps"},{"location":"reference/","text":"<p>If you are ready to begin integrating the SDK, make sure you have an SDK installed and configured. You can install each SDK by following the instructions in each page under Build in the sidebar.</p> <p>When using the SDK, you can pass parameters to the default service constructors and use the provided methods to set different active profiles.</p>","title":"Overview"},{"location":"reference/#authorization","text":"<p>See our security section for more information on how we have implemented wallet authentication and authorization.</p>","title":"Authorization"},{"location":"reference/#sdk-services","text":"<p>Our SDK is broken down into the following services:</p> <ul> <li>Account Service</li> <li>Credential Service</li> <li>Provider Service</li> <li>Template Service</li> <li>Trust Registry Service</li> <li>Wallet Service</li> </ul>","title":"SDK Services"},{"location":"reference/#using-an-sdk-service","text":"<p>If you are using one of the Trinsic SDKs, you will need to create an instance of a service in order to use it.</p> TypeScriptC#PythonGoJavaRuby   <pre><code>const accountService = new AccountService();\n</code></pre>   <pre><code>var myAccountService = new AccountService(_options);\n</code></pre>   <pre><code>account_service = AccountService(server_config=trinsic_config())\n</code></pre>   <pre><code>opts, err := NewServiceOptions(WithTestEnv())\nif !assert2.Nil(err) {\n    return\n}\n\naccountService, err := NewAccountService(opts)\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var accountService = new AccountService(TrinsicUtilities.getTrinsicServiceOptions());\n</code></pre>   <pre><code>account_service = Trinsic::AccountService.new(nil, Trinsic::trinsic_prod_server)\n</code></pre>    <p>All service constructors also accept a ServiceOptions object as an argument, allowing you to specify a default ecosystem and other configuration properties.</p>  <p>ServiceOptions   <p>Configuration for Trinsic SDK Services</p>    Field Type Description     server_endpoint string Trinsic API endpoint; defaults to <code>prod.trinsic.cloud</code>   server_port int32 Trinsic API port; defaults to <code>443</code>   server_use_tls bool Whether TLS is enabled between SDK and Trinsic API; defaults to <code>true</code>   auth_token string Authentication token for SDK calls; defaults to empty string (unauthenticated)   default_ecosystem string Default ecosystem ID to use for various SDK calls; defaults to <code>default</code>       <p></p> <p>Top</p>   <p>The exact structure of this object will depend on the language you are working with. You can always rely on your editor's intellisense when in doubt. </p>","title":"Using an SDK Service"},{"location":"reference/other/openid/","text":"","title":"OpenID Credential Exchange Service"},{"location":"reference/other/openid/#overview","text":"<p>Trinsic provides an OpenID Connect  (\"OIDC\") service which enables verifiers to request credentials from a user's cloud wallet in a simple and secure way.</p> <p>This service does not require the use of Trinsic's SDKs in the user's browser, and is therefore lightweight and easy to integrate.</p>  <p>Credential Issuance</p> <p>Currently, Trinsic's OpenID Connect service only enables the sharing of a credential between holder and verifier. We plan to support issuance through this service at a later date.</p> <p>In the meantime, use the InsertItem SDK call to store credentials in a holder's wallet.</p>","title":"Overview"},{"location":"reference/other/openid/#integration","text":"","title":"Integration"},{"location":"reference/other/openid/#openid-connect-protocol","text":"<p>Because this is an OpenID Connect service, any compliant library may be used -- as long as it enables you to specify additional custom query parameters on the initial outbound URL.</p>  <p>OIDC Flow Implementation</p> <p>The specifics of the OpenID Connect protocol -- and how to implement it -- are out of scope for this documentation.</p> <p>If you would like to see an example implementation of a verification flow against this service, see the sample below.</p>","title":"OpenID Connect Protocol"},{"location":"reference/other/openid/#configuration","text":"<p>Configure your OIDC library with the following parameters:</p> <ul> <li><code>authority</code><ul> <li>Must be <code>https://connect.trinsic.cloud/</code></li> </ul> </li> <li><code>response_type</code><ul> <li>Must be <code>code</code></li> </ul> </li> <li><code>scope</code><ul> <li>Must be <code>openid</code></li> </ul> </li> <li><code>client_id</code><ul> <li>Any string which uniquely represents your client application</li> <li>In future, we may require registration of client IDs with Trinsic</li> </ul> </li> <li><code>redirect_uri</code><ul> <li>The URI your user should be redirected to once they have completed (or canceled) the flow</li> </ul> </li> <li>Additional Query Parameters<ul> <li><code>trinsic:ecosystem</code><ul> <li>Name of Ecosystem to fetch credentials from</li> <li>Only credentials which were issued within this Ecosystem may be returned</li> </ul> </li> <li><code>trinsic:schema</code><ul> <li>Comma-separated list of Schema URLs</li> <li>Only credentials which match one of these schemas may be returned</li> </ul> </li> </ul> </li> </ul>","title":"Configuration"},{"location":"reference/other/openid/#response-data","text":"<p>Once the user has returned to your redirect URL, exchange the authorization code (added to your redirect URI as a query parameter named <code>code</code>) for an identity token using your OIDC library.</p> <p>You will receive a JSON object of the following form:</p> <pre><code>{\n    \"id_token\": \"{JWT containing same data as vp_token}\",\n    \"access_token\":\"invalid\",\n    \"token_type\":\"Bearer\",\n    \"vp_token\":{\n        \"@context\":[\n            \"https://www.w3.org/2018/credentials/v1\",\n            \"https://w3id.org/bbs/v1\",\n            ...\n        ],\n        \"id\":\"{UUID of Holder Wallet}\",\n        \"type\":[\n            ...,\n            \"VerifiableCredential\"\n        ],\n        \"credentialSchema\":{\n            ...\n        },\n        \"credentialStatus\":{\n            ...\n        },\n        \"credentialSubject\":{\n            ...\n        },\n        \"issuanceDate\":\"{Issue date of credential}\",\n        \"issuer\":\"{DID of Issuer}\",\n        \"proof\":{\n            ...\n        }\n    }\n}\n</code></pre>  <p>Credential Format</p> <p>Note that the above data has been modified for brevity. </p> <p>The <code>@context</code> and <code>type</code> arrays will contain additional entries which are specific to the credential.</p>","title":"Response Data"},{"location":"reference/other/openid/#verify-the-received-proof","text":"<p><code>vp_token</code> is a Verifiable Proof; before making use of its data, you must verify it. </p> <p>This proof can be verified with any library that supports VC verifications for BBS+ signatures. It can also be verified using Trinsic's SDK; this is as simple as passing the proof to the VerifyProof call.</p>  <p>Always Verify</p> <p>It may be tempting to simply take the data in <code>vp_token</code> and act upon it without first verifying the proof.</p> <p>Always verify the proof before making use of its data. </p> <p>Without verification, the received proof is of no more value than an unsubstantiated claim made by your user.</p>","title":"Verify the Received Proof"},{"location":"reference/other/openid/#sample","text":"<p>If you'd like to see how to implement a basic OIDC flow against this service, or just want to see it in action, check out our client-side verification flow example .</p> <p>You'll need to fork the repl and follow the instructions in <code>README.md</code>.</p>","title":"Sample"},{"location":"reference/proto/","text":"<p></p> <p>This page documents the Protobuf Services and Messages which compose the Trinsic API.</p> <p></p> <p>Top</p>","title":"Protocol Documentation"},{"location":"reference/proto/#sdkoptionsv1optionsproto","text":"<p></p>","title":"sdk/options/v1/options.proto"},{"location":"reference/proto/#serviceoptions","text":"<p>Configuration for Trinsic SDK Services</p>    Field Type Description     server_endpoint string Trinsic API endpoint; defaults to <code>prod.trinsic.cloud</code>   server_port int32 Trinsic API port; defaults to <code>443</code>   server_use_tls bool Whether TLS is enabled between SDK and Trinsic API; defaults to <code>true</code>   auth_token string Authentication token for SDK calls; defaults to empty string (unauthenticated)   default_ecosystem string Default ecosystem ID to use for various SDK calls; defaults to <code>default</code>       <p></p> <p>Top</p>","title":"ServiceOptions"},{"location":"reference/proto/#servicesverifiable-credentialsv1verifiable-credentialsproto","text":"<p></p>","title":"services/verifiable-credentials/v1/verifiable-credentials.proto"},{"location":"reference/proto/#service-verifiablecredential","text":"Method Name Request Type Response Type Description     Issue IssueRequest IssueResponse Sign and issue a verifiable credential from a submitted document. The document must be a valid JSON-LD document.   IssueFromTemplate IssueFromTemplateRequest IssueFromTemplateResponse Sign and issue a verifiable credential from a pre-defined template. This process will also add schema validation and revocation registry entry in the credential.   CheckStatus CheckStatusRequest CheckStatusResponse Check credential status in the revocation registry   UpdateStatus UpdateStatusRequest UpdateStatusResponse Update credential status by setting the revocation value   CreateProof CreateProofRequest CreateProofResponse Create a proof from a signed document that is a valid verifiable credential and contains a signature from which a proof can be derived.   VerifyProof VerifyProofRequest VerifyProofResponse Verifies a proof by checking the signature value, and if possible schema validation, revocation status, and issuer status against a trust registry   Send SendRequest SendResponse Sends a document directly to a user's email within the given ecosystem     <p></p>","title":"Service - VerifiableCredential"},{"location":"reference/proto/#checkstatusrequest","text":"<p>Request to check a credential's revocation status</p>    Field Type Description     credential_status_id string Credential Status ID to check    <p></p>","title":"CheckStatusRequest"},{"location":"reference/proto/#checkstatusresponse","text":"<p>Response to <code>CheckStatusRequest</code></p>    Field Type Description     revoked bool The credential's revocation status    <p></p>","title":"CheckStatusResponse"},{"location":"reference/proto/#createproofrequest","text":"<p>Request to create a proof for a Verifiable Credential using public key tied to caller. Either <code>item_id</code> or <code>document_json</code> may be provided, not both.</p>    Field Type Description     reveal_document_json string A valid JSON-LD frame describing which fields should be revealed in the generated proof. If unspecified, all fields in the document will be revealed   item_id string ID of wallet item stored in a Trinsic cloud wallet   document_json string A valid JSON-LD Verifiable Credential document string with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet.    <p></p>","title":"CreateProofRequest"},{"location":"reference/proto/#createproofresponse","text":"<p>Response to <code>CreateProofRequest</code></p>    Field Type Description     proof_document_json string Valid JSON-LD proof for the specified credential    <p></p>","title":"CreateProofResponse"},{"location":"reference/proto/#issuefromtemplaterequest","text":"<p>Request to create and sign a JSON-LD Verifiable Credential from a template using public key tied to caller</p>    Field Type Description     template_id string ID of template to use   values_json string JSON document string with keys corresponding to the fields of the template referenced by <code>template_id</code>   framework_id string Governance framework ID to use with issuance of this credential. If specified, the issued credential will contain extended issuer metadata with membership info for the given ecosystem governance framework (EGF)    <p></p>","title":"IssueFromTemplateRequest"},{"location":"reference/proto/#issuefromtemplateresponse","text":"<p>Response to <code>IssueFromTemplateRequest</code></p>    Field Type Description     document_json string Verifiable Credential document, in JSON-LD form, constructed from the specified template and values; signed with public key tied to caller of <code>IssueFromTemplateRequest</code>    <p></p>","title":"IssueFromTemplateResponse"},{"location":"reference/proto/#issuerequest","text":"<p>Request to sign a JSON-LD Credential using public key tied to caller</p>    Field Type Description     document_json string Valid JSON-LD Credential document to be signed, in string form    <p></p>","title":"IssueRequest"},{"location":"reference/proto/#issueresponse","text":"<p>Response to <code>IssueRequest</code></p>    Field Type Description     signed_document_json string Verifiable Credential document, signed with public key tied to caller of <code>IssueRequest</code>    <p></p>","title":"IssueResponse"},{"location":"reference/proto/#sendrequest","text":"<p>Request to send a document to another user's wallet</p>    Field Type Description     email string Email address of user to send item to   did_uri string DID of recipient (presently unsupported)   didcomm_invitation_json string DIDComm out-of-band invitation JSON (presently unsupported)   document_json string JSON document to send to recipient    <p></p>","title":"SendRequest"},{"location":"reference/proto/#sendresponse","text":"<p>Response to <code>SendRequest</code></p> <p></p>","title":"SendResponse"},{"location":"reference/proto/#updatestatusrequest","text":"<p>Request to update a credential's revocation status</p>    Field Type Description     credential_status_id string Credential Status ID to update   revoked bool New revocation status of credential    <p></p>","title":"UpdateStatusRequest"},{"location":"reference/proto/#updatestatusresponse","text":"<p>Response to <code>UpdateStatusRequest</code></p> <p></p>","title":"UpdateStatusResponse"},{"location":"reference/proto/#validationmessage","text":"<p>Result of a validation check on a proof</p>    Field Type Description     is_valid bool Whether or not this validation check passed   messages string[] If validation failed, contains messages explaining why    <p></p>","title":"ValidationMessage"},{"location":"reference/proto/#verifyproofrequest","text":"<p>Request to verify a proof</p>    Field Type Description     proof_document_json string JSON-LD proof document string to verify    <p></p>","title":"VerifyProofRequest"},{"location":"reference/proto/#verifyproofresponse","text":"<p>Response to <code>VerifyProofRequest</code></p>    Field Type Description     is_valid bool Whether or not all validations in <code>validation_results</code> passed   validation_messages string[] Deprecated. Use <code>validation_results</code> instead   validation_results VerifyProofResponse.ValidationResultsEntry[] Results of each validation check performed, such as schema conformance, revocation status, signature, etc. Detailed results are provided for failed validations.    <p></p>","title":"VerifyProofResponse"},{"location":"reference/proto/#verifyproofresponsevalidationresultsentry","text":"Field Type Description     key string    value ValidationMessage        <p></p> <p>Top</p>","title":"VerifyProofResponse.ValidationResultsEntry"},{"location":"reference/proto/#servicesverifiable-credentialstemplatesv1templatesproto","text":"<p></p>","title":"services/verifiable-credentials/templates/v1/templates.proto"},{"location":"reference/proto/#service-credentialtemplates","text":"Method Name Request Type Response Type Description     Create CreateCredentialTemplateRequest CreateCredentialTemplateResponse    Get GetCredentialTemplateRequest GetCredentialTemplateResponse    List ListCredentialTemplatesRequest ListCredentialTemplatesResponse    Search SearchCredentialTemplatesRequest SearchCredentialTemplatesResponse    Delete DeleteCredentialTemplateRequest DeleteCredentialTemplateResponse      <p></p>","title":"Service - CredentialTemplates"},{"location":"reference/proto/#createcredentialtemplaterequest","text":"<p>Request to create a new template</p>    Field Type Description     name string Name of new template   fields CreateCredentialTemplateRequest.FieldsEntry[] Fields which compose the template   allow_additional_fields bool Whether credentials may be issued against this template which have fields not specified in <code>fields</code>    <p></p>","title":"CreateCredentialTemplateRequest"},{"location":"reference/proto/#createcredentialtemplaterequestfieldsentry","text":"Field Type Description     key string    value TemplateField     <p></p>","title":"CreateCredentialTemplateRequest.FieldsEntry"},{"location":"reference/proto/#createcredentialtemplateresponse","text":"<p>Response to <code>CreateCredentialTemplateRequest</code></p>    Field Type Description     data TemplateData Created template    <p></p>","title":"CreateCredentialTemplateResponse"},{"location":"reference/proto/#deletecredentialtemplaterequest","text":"<p>Request to delete a template by ID</p>    Field Type Description     id string ID of template to delete    <p></p>","title":"DeleteCredentialTemplateRequest"},{"location":"reference/proto/#deletecredentialtemplateresponse","text":"<p>Response to <code>DeleteCredentialTemplateRequest</code></p> <p></p>","title":"DeleteCredentialTemplateResponse"},{"location":"reference/proto/#getcredentialtemplaterequest","text":"<p>Request to fetch a template by ID</p>    Field Type Description     id string ID of template to fetch    <p></p>","title":"GetCredentialTemplateRequest"},{"location":"reference/proto/#getcredentialtemplateresponse","text":"<p>Response to <code>GetCredentialTemplateRequest</code></p>    Field Type Description     template TemplateData Template fetched by ID    <p></p>","title":"GetCredentialTemplateResponse"},{"location":"reference/proto/#gettemplaterequest","text":"<p>Unused</p>    Field Type Description     id string     <p></p>","title":"GetTemplateRequest"},{"location":"reference/proto/#gettemplateresponse","text":"<p>Unused</p>    Field Type Description     data TemplateData     <p></p>","title":"GetTemplateResponse"},{"location":"reference/proto/#listcredentialtemplatesrequest","text":"<p>Request to list templates using a SQL query</p>    Field Type Description     query string SQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code>   continuation_token string Token provided by previous <code>ListCredentialTemplatesResponse</code> if more data is available for query    <p></p>","title":"ListCredentialTemplatesRequest"},{"location":"reference/proto/#listcredentialtemplatesresponse","text":"<p>Response to <code>ListCredentialTemplatesRequest</code></p>    Field Type Description     templates TemplateData[] Templates found by query   has_more_results bool Whether more results are available for this query via <code>continuation_token</code>   continuation_token string Token to fetch next set of resuts via <code>ListCredentialTemplatesRequest</code>    <p></p>","title":"ListCredentialTemplatesResponse"},{"location":"reference/proto/#listtemplatesrequest","text":"<p>Unused</p> <p></p>","title":"ListTemplatesRequest"},{"location":"reference/proto/#listtemplatesresponse","text":"<p>Unused</p>    Field Type Description     templates TemplateData[]     <p></p>","title":"ListTemplatesResponse"},{"location":"reference/proto/#searchcredentialtemplatesrequest","text":"<p>Request to search templates using a SQL query</p>    Field Type Description     query string SQL query to execute. Example: <code>SELECT * FROM c WHERE c.name = 'Diploma'</code>   continuation_token string Token provided by previous <code>SearchCredentialTemplatesResponse</code> if more data is available for query    <p></p>","title":"SearchCredentialTemplatesRequest"},{"location":"reference/proto/#searchcredentialtemplatesresponse","text":"<p>Response to <code>SearchCredentialTemplatesRequest</code></p>    Field Type Description     items_json string Raw JSON data returned from query   has_more bool Whether more results are available for this query via <code>continuation_token</code>   continuation_token string Count of items in <code>items_json</code> int32 count = 3; unpopulated and unused Token to fetch next set of results via <code>SearchCredentialTemplatesRequest</code>    <p></p>","title":"SearchCredentialTemplatesResponse"},{"location":"reference/proto/#templatedata","text":"<p>Credential Template</p>    Field Type Description     id string Template ID   name string Template name   version int32 Template version number   fields TemplateData.FieldsEntry[] Fields defined for the template   allow_additional_fields bool Whether credentials issued against this template may contain fields not defined by template   schema_uri string URI pointing to template JSON schema document   context_uri string URI pointing to template JSON-LD context document   ecosystem_id string ID of ecosystem in which template resides   type string Template type (<code>VerifiableCredential</code>)   created_by string ID of template creator    <p></p>","title":"TemplateData"},{"location":"reference/proto/#templatedatafieldsentry","text":"Field Type Description     key string    value TemplateField     <p></p>","title":"TemplateData.FieldsEntry"},{"location":"reference/proto/#templatefield","text":"<p>A field defined in a template</p>    Field Type Description     description string Human-readable description of the field   optional bool Whether this field may be omitted when a credential is issued against the template   type FieldType The type of the field     <p></p>","title":"TemplateField"},{"location":"reference/proto/#fieldtype","text":"<p>Valid types for credential fields</p>    Name Number Description     STRING 0    NUMBER 1    BOOL 2    DATETIME 4       <p></p> <p>Top</p>","title":"FieldType"},{"location":"reference/proto/#servicesdebugv1debugproto","text":"<p></p>","title":"services/debug/v1/debug.proto"},{"location":"reference/proto/#service-debugging","text":"Method Name Request Type Response Type Description     CallEmpty .google.protobuf.Empty .google.protobuf.Empty    CallEmptyAuth .google.protobuf.Empty .google.protobuf.Empty         <p></p> <p>Top</p>","title":"Service - Debugging"},{"location":"reference/proto/#servicesuniversal-walletv1universal-walletproto","text":"<p></p>","title":"services/universal-wallet/v1/universal-wallet.proto"},{"location":"reference/proto/#service-universalwallet","text":"Method Name Request Type Response Type Description     GetItem GetItemRequest GetItemResponse Retrieve an item from the wallet with a given item identifier   Search SearchRequest SearchResponse Search the wallet using a SQL-like syntax   InsertItem InsertItemRequest InsertItemResponse Insert an item into the wallet   UpdateItem UpdateItemRequest UpdateItemResponse Update an item in the wallet   DeleteItem DeleteItemRequest DeleteItemResponse Delete an item from the wallet permanently     <p></p>","title":"Service - UniversalWallet"},{"location":"reference/proto/#deleteitemrequest","text":"<p>Request to delete an item in a wallet</p>    Field Type Description     item_id string ID of item to delete    <p></p>","title":"DeleteItemRequest"},{"location":"reference/proto/#deleteitemresponse","text":"<p>Response to <code>DeleteItemRequest</code></p> <p></p>","title":"DeleteItemResponse"},{"location":"reference/proto/#getitemrequest","text":"<p>Request to fetch an item from wallet</p>    Field Type Description     item_id string ID of item in wallet    <p></p>","title":"GetItemRequest"},{"location":"reference/proto/#getitemresponse","text":"<p>Response to <code>GetItemRequest</code></p>    Field Type Description     item_json string Item data as a JSON string   item_type string Type of item specified when item was inserted into wallet    <p></p>","title":"GetItemResponse"},{"location":"reference/proto/#insertitemrequest","text":"<p>Request to insert a JSON document into a wallet</p>    Field Type Description     item_json string Document to insert; must be stringified JSON   item_type string Item type (ex. \"VerifiableCredential\")    <p></p>","title":"InsertItemRequest"},{"location":"reference/proto/#insertitemresponse","text":"<p>Response to <code>InsertItemRequest</code></p>    Field Type Description     item_id string ID of item inserted into wallet    <p></p>","title":"InsertItemResponse"},{"location":"reference/proto/#searchrequest","text":"<p>Request to search items in wallet</p>    Field Type Description     query string SQL Query to execute against items in wallet   continuation_token string Token provided by previous <code>SearchResponse</code> if more data is available for query    <p></p>","title":"SearchRequest"},{"location":"reference/proto/#searchresponse","text":"<p>Response to <code>SearchRequest</code></p>    Field Type Description     items string[] Array of query results, as JSON strings   has_more bool Whether more results are available for this query via <code>continuation_token</code>   continuation_token string Token to fetch next set of results via <code>SearchRequest</code>    <p></p>","title":"SearchResponse"},{"location":"reference/proto/#updateitemrequest","text":"<p>Request to update item in wallet</p>    Field Type Description     item_id string ID of item in wallet   item_type string Item type (ex. \"VerifiableCredential\")    <p></p>","title":"UpdateItemRequest"},{"location":"reference/proto/#updateitemresponse","text":"<p>Response to <code>UpdateItemRequest</code></p>    <p></p> <p>Top</p>","title":"UpdateItemResponse"},{"location":"reference/proto/#servicesproviderv1providerproto","text":"<p></p>","title":"services/provider/v1/provider.proto"},{"location":"reference/proto/#service-provider","text":"Method Name Request Type Response Type Description     CreateEcosystem CreateEcosystemRequest CreateEcosystemResponse Create new ecosystem and assign the authenticated user as owner   GenerateToken GenerateTokenRequest GenerateTokenResponse Generates an unprotected authentication token that can be used to configure server side applications   Invite InviteRequest InviteResponse Invite a user to the ecosystem   InvitationStatus InvitationStatusRequest InvitationStatusResponse Check the invitation status   GetOberonKey GetOberonKeyRequest GetOberonKeyResponse Returns the public key being used to create/verify oberon tokens     <p></p>","title":"Service - Provider"},{"location":"reference/proto/#createecosystemrequest","text":"Field Type Description     name string Globally unique name for the Ecosystem. This name will be part of the ecosystem specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen.   description string Ecosystem description   uri string External URL associated with your organization or ecosystem entity   details services.account.v1.AccountDetails The account details of the owner of the ecosystem    <p></p>","title":"CreateEcosystemRequest"},{"location":"reference/proto/#createecosystemresponse","text":"Field Type Description     ecosystem Ecosystem Details of the created ecosystem   profile services.account.v1.AccountProfile Account profile for auth of the owner of the ecosystem   confirmation_method services.account.v1.ConfirmationMethod Indicates if confirmation of account is required. This setting is configured globally by the server administrator.    <p></p>","title":"CreateEcosystemResponse"},{"location":"reference/proto/#ecosystem","text":"Field Type Description     id string    name string    description string    uri string     <p></p>","title":"Ecosystem"},{"location":"reference/proto/#generatetokenrequest","text":"Field Type Description     description string Description to identify this token    <p></p>","title":"GenerateTokenRequest"},{"location":"reference/proto/#generatetokenresponse","text":"Field Type Description     profile services.account.v1.AccountProfile Account authentication profile that contains unprotected token    <p></p>","title":"GenerateTokenResponse"},{"location":"reference/proto/#getoberonkeyrequest","text":"<p>request message for GetOberonKey</p> <p></p>","title":"GetOberonKeyRequest"},{"location":"reference/proto/#getoberonkeyresponse","text":"<p>response message for GetOberonKey</p>    Field Type Description     key string Oberon Public Key as RAW base64 URL encoded string    <p></p>","title":"GetOberonKeyResponse"},{"location":"reference/proto/#invitationstatusrequest","text":"<p>Request details for the status of onboarding an individual or organization. The reference_id passed is the response from the <code>Onboard</code> method call</p>    Field Type Description     invitation_id string ID of invitation    <p></p>","title":"InvitationStatusRequest"},{"location":"reference/proto/#invitationstatusresponse","text":"Field Type Description     status InvitationStatusResponse.Status Status of invitation   status_details string Human-readable string with details about invitation status    <p></p>","title":"InvitationStatusResponse"},{"location":"reference/proto/#invite","text":"Field Type Description     id string    code string    created string    accepted string    expires string     <p></p>","title":"Invite"},{"location":"reference/proto/#inviterequest","text":"Field Type Description     participant ParticipantType Type of participant being invited (individual/organization)   description string Description of invitation   details services.account.v1.AccountDetails Account details of invitee    <p></p>","title":"InviteRequest"},{"location":"reference/proto/#inviterequestdidcomminvitation","text":"<p></p>","title":"InviteRequest.DidCommInvitation"},{"location":"reference/proto/#inviteresponse","text":"Field Type Description     invitation_id string ID of created invitation   invitation_code string Invitation Code that must be passed with the account 'SignIn' request to correlate this user with the invitation sent.     <p></p>","title":"InviteResponse"},{"location":"reference/proto/#invitationstatusresponsestatus","text":"Name Number Description     Error 0 Onboarding resulted in error   InvitationSent 1 The participant has been invited   Completed 2 The participant has been onboarded   Expired 3 The invite has expired    <p></p>","title":"InvitationStatusResponse.Status"},{"location":"reference/proto/#participanttype","text":"Name Number Description     participant_type_individual 0    participant_type_organization 1       <p></p> <p>Top</p>","title":"ParticipantType"},{"location":"reference/proto/#servicescommonv1commonproto","text":"<p></p>","title":"services/common/v1/common.proto"},{"location":"reference/proto/#nonce","text":"<p>Nonce used to generate an oberon proof</p>    Field Type Description     timestamp int64 UTC unix millisecond timestamp the request was made   request_hash bytes blake3256 hash of the request body    <p></p>","title":"Nonce"},{"location":"reference/proto/#serverconfig","text":"Field Type Description     endpoint string service endpoint   port int32 service port   use_tls bool indicates if tls is used     <p></p>","title":"ServerConfig"},{"location":"reference/proto/#responsestatus","text":"Name Number Description     SUCCESS 0    WALLET_ACCESS_DENIED 10    WALLET_EXISTS 11    ITEM_NOT_FOUND 20    SERIALIZATION_ERROR 200    UNKNOWN_ERROR 100       <p></p> <p>Top</p>","title":"ResponseStatus"},{"location":"reference/proto/#servicesoptionsfield-optionsproto","text":"<p></p>","title":"services/options/field-options.proto"},{"location":"reference/proto/#file-level-extensions","text":"Extension Type Base Number Description     optional bool .google.protobuf.FieldOptions 60000 Whether field is optional in Trinsic's backend. This is not the same as an <code>optional</code> protobuf label; it only impacts documentation generation for the field.     <p></p> <p>Top</p>","title":"File-level Extensions"},{"location":"reference/proto/#servicestrust-registryv1trust-registryproto","text":"<p></p>","title":"services/trust-registry/v1/trust-registry.proto"},{"location":"reference/proto/#service-trustregistry","text":"Method Name Request Type Response Type Description     AddFramework AddFrameworkRequest AddFrameworkResponse Adds a trust registry defintion to the ecosystem   RemoveFramework RemoveFrameworkRequest RemoveFrameworkResponse    SearchRegistry SearchRegistryRequest SearchRegistryResponse    RegisterMember RegisterMemberRequest RegisterMemberResponse Registers an authoritative issuer with a credential template   UnregisterMember UnregisterMemberRequest UnregisterMemberResponse Removes an authoritative issuer with a credential template from the trust registry   GetMembershipStatus GetMembershipStatusRequest GetMembershipStatusResponse    FetchData FetchDataRequest FetchDataResponse stream      <p></p>","title":"Service - TrustRegistry"},{"location":"reference/proto/#addframeworkrequest","text":"<p>Register new ecosystem governance framework</p>    Field Type Description     governance_framework_uri string    name string    description string     <p></p>","title":"AddFrameworkRequest"},{"location":"reference/proto/#addframeworkresponse","text":"Field Type Description     id string Unique framework identifier   governing_authority string    trust_registry string     <p></p>","title":"AddFrameworkResponse"},{"location":"reference/proto/#fetchdatarequest","text":"Field Type Description     governance_framework_uri string    query string     <p></p>","title":"FetchDataRequest"},{"location":"reference/proto/#fetchdataresponse","text":"Field Type Description     response_json string    has_more_results bool    continuation_token string     <p></p>","title":"FetchDataResponse"},{"location":"reference/proto/#getmembershipstatusrequest","text":"Field Type Description     governance_framework_uri string    did_uri string    x509_cert string    schema_uri string     <p></p>","title":"GetMembershipStatusRequest"},{"location":"reference/proto/#getmembershipstatusresponse","text":"Field Type Description     status RegistrationStatus     <p></p>","title":"GetMembershipStatusResponse"},{"location":"reference/proto/#governanceframework","text":"Field Type Description     governance_framework_uri string    trust_registry_uri string    description string     <p></p>","title":"GovernanceFramework"},{"location":"reference/proto/#registermemberrequest","text":"Field Type Description     did_uri string    wallet_id string    email string    schema_uri string    valid_from_utc uint64    valid_until_utc uint64    framework_id string the id of the governance framework    <p></p>","title":"RegisterMemberRequest"},{"location":"reference/proto/#registermemberresponse","text":"<p></p>","title":"RegisterMemberResponse"},{"location":"reference/proto/#removeframeworkrequest","text":"Field Type Description     id string     <p></p>","title":"RemoveFrameworkRequest"},{"location":"reference/proto/#removeframeworkresponse","text":"<p></p>","title":"RemoveFrameworkResponse"},{"location":"reference/proto/#searchregistryrequest","text":"Field Type Description     query string SELECT c from c where c.type == 'GovernanceFramework'   continuation_token string     <p></p>","title":"SearchRegistryRequest"},{"location":"reference/proto/#searchregistryresponse","text":"Field Type Description     items_json string    has_more bool    continuation_token string     <p></p>","title":"SearchRegistryResponse"},{"location":"reference/proto/#unregistermemberrequest","text":"Field Type Description     did_uri string    wallet_id string    email string    schema_uri string    framework_id string     <p></p>","title":"UnregisterMemberRequest"},{"location":"reference/proto/#unregistermemberresponse","text":"<p></p>","title":"UnregisterMemberResponse"},{"location":"reference/proto/#registrationstatus","text":"Name Number Description     CURRENT 0 - the entity is currently authorized, as of time of the query.   EXPIRED 1 - entity rights have expired.   TERMINATED 2 - entity has voluntarily ceased Issuer role under the specific EGF.   REVOKED 3 - entity authority under specific EGF was terminated by the governing authority.   NOT_FOUND 10       <p></p> <p>Top</p>","title":"RegistrationStatus"},{"location":"reference/proto/#servicesaccountv1accountproto","text":"<p></p>","title":"services/account/v1/account.proto"},{"location":"reference/proto/#service-account","text":"Method Name Request Type Response Type Description     SignIn SignInRequest SignInResponse Sign in to an already existing account    <p>rpc SIgnInConfirm (SignInConfirmRequest) returns (SignInConfirmResponse); | | Info | InfoRequest | InfoResponse | Get account information | | ListDevices | ListDevicesRequest | ListDevicesResponse | List all connected devices | | RevokeDevice | RevokeDeviceRequest | RevokeDeviceResponse | Revoke device access to the account's cloud wallet |</p>  <p></p>","title":"Service - Account"},{"location":"reference/proto/#accountdetails","text":"<p>Account registration details</p>    Field Type Description     name string Account name   email string Email account   sms string SMS number including country code    <p></p>","title":"AccountDetails"},{"location":"reference/proto/#accountecosystem","text":"Field Type Description     id string    name string    description string    uri string     <p></p>","title":"AccountEcosystem"},{"location":"reference/proto/#accountprofile","text":"<p>Device profile containing sensitive authentication data. This information should be stored securely</p>    Field Type Description     profile_type string The type of profile, used to differentiate between protocol schemes or versions   auth_data bytes Auth data containg information about the current device access   auth_token bytes Secure token issued by server used to generate zero-knowledge proofs   protection TokenProtection Token security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.    <p></p>","title":"AccountProfile"},{"location":"reference/proto/#inforequest","text":"<p>Request for information about the account used to make the request</p> <p></p>","title":"InfoRequest"},{"location":"reference/proto/#inforesponse","text":"<p>Information about the account used to make the request</p>    Field Type Description     details AccountDetails The account details associated with the calling request context   ecosystems AccountEcosystem[] Deprecated. Use <code>ecosystem_id</code> instead   wallet_id string The wallet ID associated with this account   device_id string The device ID associated with this account session   ecosystem_id string The ecosystem ID within which this account resides   public_did string The public DID associated with this account. This DID is used as \"issuer\" when signing verifiable credentials    <p></p>","title":"InfoResponse"},{"location":"reference/proto/#listdevicesrequest","text":"<p></p>","title":"ListDevicesRequest"},{"location":"reference/proto/#listdevicesresponse","text":"<p></p>","title":"ListDevicesResponse"},{"location":"reference/proto/#revokedevicerequest","text":"<p></p>","title":"RevokeDeviceRequest"},{"location":"reference/proto/#revokedeviceresponse","text":"<p></p>","title":"RevokeDeviceResponse"},{"location":"reference/proto/#signinrequest","text":"<p>Request for creating or signing into an account</p>    Field Type Description     details AccountDetails Account registration details   invitation_code string Invitation code associated with this registration   ecosystem_id string ID of Ecosystem to sign into. Ignored if <code>invitation_code</code> is passed    <p></p>","title":"SignInRequest"},{"location":"reference/proto/#signinresponse","text":"<p>Response for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc.</p>    Field Type Description     confirmation_method ConfirmationMethod Indicates if confirmation of account is required. This settings is configured globally by the server administrator.   profile AccountProfile Contains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data.    <p></p>","title":"SignInResponse"},{"location":"reference/proto/#tokenprotection","text":"<p>Token protection info</p>    Field Type Description     enabled bool Indicates if token is protected using a PIN, security code, HSM secret, etc.   method ConfirmationMethod The method used to protect the token     <p></p>","title":"TokenProtection"},{"location":"reference/proto/#confirmationmethod","text":"<p>Confirmation method type for two-factor workflows</p>    Name Number Description     None 0 No confirmation required   Email 1 Email confirmation required   Sms 2 SMS confirmation required   ConnectedDevice 3 Confirmation from a connected device is required   Other 10 Indicates third-party method of confirmation is required","title":"ConfirmationMethod"},{"location":"reference/proto/#scalar-value-types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby      double  double double float float64 double float Float    float  float float float float32 float float Float    int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)    int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum    uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)    uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)    sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)    sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum    fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)    fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum    sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)    sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum    bool  bool boolean boolean bool bool boolean TrueClass/FalseClass    string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)    bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Scalar Value Types"},{"location":"reference/services/account-service/","text":"<p>The Account Service allows you to create and sign in to accounts.</p>  <p>Wallets vs Accounts</p> <p>Wallets and accounts are related and often interchangeable -- each account has an associated wallet, and operations on a wallet are performed using an account's access token.</p> <p>Every account has exactly one wallet. </p>   <p>Authentication Tokens</p> <p>When you create or sign in to an account, the response is an authentication token string.</p> <p>This string is an encoded form of your account profile, as well as an access key to perform calls using the account.</p> <p>These are effectively API keys; they should be kept safe and never published.</p>","title":"Account Service"},{"location":"reference/services/account-service/#sign-in","text":"<p>Sign in to an existing account, or create a new one.</p> <p>If no account details are passed to this method, an anonymous account will be created.</p>  <p>SignInRequest   <p>Request for creating or signing into an account</p>    Field Type Description     details AccountDetails Account registration details   invitation_code string Invitation code associated with this registration   ecosystem_id string ID of Ecosystem to sign into. Ignored if <code>invitation_code</code> is passed    <p></p>    <p>AccountDetails   <p>Account registration details</p>    Field Type Description     name string Account name   email string Email account   sms string SMS number including country code    <p></p>   Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic account login --email &lt;PROFILE_EMAIL&gt; --name &lt;PROFILE_NAME&gt;\n</code></pre>   <pre><code>const allison = (await accountService.signIn()).getProfile();\n</code></pre>   <pre><code>var myProfile = await myAccountService.SignInAsync(new());\n</code></pre>   <pre><code>my_profile = await account_service.sign_in()\n</code></pre>   <pre><code>profile, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var myProfile = accountService.signIn().get();\n</code></pre>   <pre><code>allison = account_service.sign_in(nil).profile\n</code></pre>    <p>This operation, if successful, returns an authentication token string.</p>  <p>Protected Authentication Tokens</p> <p>If you are attempting to login to a non-anonymous account (by specifying an email address or phone number), the authentication token returned will be protected, and cannot be used until it has been unprotected.</p> <p>Trinsic will have sent a security code to the account's email address or phone number; this security code must be used with the Unprotect call to receive a usable authentication token.</p> <p>In the future, we will provide an SDK call to determine if an authentication token is protected.</p>","title":"Sign In"},{"location":"reference/services/account-service/#get-account-info","text":"<p>Returns the account information (name, email address, phone number, etc.) used to create the currently-active account profile.</p>  <p>Note</p> <p>This call returns the information associated with the authentication token used to create the request; therefore, it is not possible to pass a different authentication token to this call. Otherwise, Trinsic's zero-knowledge proof authentication scheme would be violated.</p> <p>When using the CLI, this will return information for the account most recently logged in to.</p> <p>When using the SDK, this will return information for the authentication token stored in the <code>AccountService</code> instance's <code>ServiceOptions.AuthToken</code> field, which will be the account most recently logged in to, unless you have manually set this value yourself.</p>  Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic account info\n</code></pre>   <pre><code>const info = await accountService.info();\n</code></pre>   <pre><code>var output = await myAccountService.GetInfoAsync();\n</code></pre>   <pre><code>info = await account_service.get_info()\n</code></pre>   <pre><code>info2, err2 := accountService.GetInfo(context.Background())\n</code></pre>   <pre><code>var info = accountService.getInfo().get();\n</code></pre>   <pre><code>info = account_service.get_info()\n</code></pre>     <p>InfoResponse   <p>Information about the account used to make the request</p>    Field Type Description     details AccountDetails The account details associated with the calling request context   ecosystems AccountEcosystem[] Deprecated. Use <code>ecosystem_id</code> instead   wallet_id string The wallet ID associated with this account   device_id string The device ID associated with this account session   ecosystem_id string The ecosystem ID within which this account resides   public_did string The public DID associated with this account. This DID is used as \"issuer\" when signing verifiable credentials    <p></p>","title":"Get Account Info"},{"location":"reference/services/account-service/#protect-account-profile","text":"<p>Protects the specified account profile with a security code. It is not possible to execute this call using the CLI.</p>  <p>Info</p> <p>In this context, \"protection\" refers to a cryptographic operation on the authorization token for an account.</p> <p>Protecting an account profile with code <code>c</code> returns a new access token which is unusable until it is unprotected with the same code <code>c</code>. It is not possible to reverse the protection process without the original protection code.</p> <p>You will receive a protected account profile from Trinsic if you attempt to sign in to an account via email, SMS, or any other method which requires authentication. Trinsic will send a security code to the email or phone number associated with the account, which can be used to unprotect the account profile.</p> <p>Specifically, Trinsic is using Oberon to handle access tokens; protection and unprotection is handled using the blinding/unblinding features of Oberon.</p>  TypeScriptC#PythonGoJavaRuby   <pre><code>const protectedProfile = await accountService.protect(accountProfile, \"1234\");\n</code></pre>   <pre><code>var securityCode = \"1234\";\nvar myProtectedProfile = AccountService.Protect(myProfile, securityCode);\nvar myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n</code></pre>   <pre><code>code = b\"1234\"\nmy_protected_profile = account_service.protect(\n    profile=my_profile, security_code=code\n)\nmy_unprotected_profile = account_service.unprotect(\n    profile=my_protected_profile, security_code=code\n)\n</code></pre>   <pre><code>securityCode := \"1234\"\nprotectedProfile, err := accountService.Protect(profile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\nunprotectedProfile, err := accountService.Unprotect(protectedProfile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var code = \"1234\";\nvar myProtectedProfile = AccountService.protect(myProfile, code);\nvar myUnprotectedProfile = AccountService.unprotect(myProtectedProfile, code);\n</code></pre>   <pre><code>protected_profile = account_service.protect(account_profile, '1234')\n</code></pre>","title":"Protect Account Profile"},{"location":"reference/services/account-service/#unprotect-account-profile","text":"<p>Unprotects the specified account profile using the given code. It is not possible to execute this call using the CLI.</p> <p>The profile must have been previously protected using the same code that is being used to unprotect it. Profiles can be protected using any arbitrary code via the Protect method.</p> <p>Most commonly, this method is used on a protected profile received from the Sign In method. The code to unprotect it will have been sent to the account owner via email or SMS.</p> TypeScriptC#PythonGoJavaRuby   <pre><code>const accountProfile = await accountService.unprotect(protectedProfile, \"1234\");\n</code></pre>   <pre><code>var securityCode = \"1234\";\nvar myProtectedProfile = AccountService.Protect(myProfile, securityCode);\nvar myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n</code></pre>   <pre><code>code = b\"1234\"\nmy_protected_profile = account_service.protect(\n    profile=my_profile, security_code=code\n)\nmy_unprotected_profile = account_service.unprotect(\n    profile=my_protected_profile, security_code=code\n)\n</code></pre>   <pre><code>securityCode := \"1234\"\nprotectedProfile, err := accountService.Protect(profile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\nunprotectedProfile, err := accountService.Unprotect(protectedProfile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var code = \"1234\";\nvar myProtectedProfile = AccountService.protect(myProfile, code);\nvar myUnprotectedProfile = AccountService.unprotect(myProtectedProfile, code);\n</code></pre>   <pre><code>account_profile = account_service.unprotect(protected_profile, '1234')\n</code></pre>","title":"Unprotect Account Profile"},{"location":"reference/services/credential-service/","text":"<p>The Credentials Service gives you the ability to manage complex workflows related to DIDs (contacts/Connections) and VCs (credential issuance, Revocation, Verification, etc). This is probably the service you will most interact with because VC Issuance and verification are at the core of every SSI use case.</p> <p>The Credential service supports signing data using BBS+ Signatures . The data is signed with a key unique to the owner's wallet. This key is also used as linked secret, when it comes to proof derivation.</p>","title":"Credential Service"},{"location":"reference/services/credential-service/#issue-credential","text":"<p>Issues a credential from a valid JSON-LD document. You can learn more about how creating these documents, and about VC data models in general, from W3C: VC Data Model v1.1. </p> <p><code>IssueCredential</code> requires a valid JSON-LD document to be provided. Do not confuse this operation with Issue Credential From Template.</p> Trinsic CLI   <pre><code>trinsic vc issue --document &lt;JSONLD_FILE&gt; --out &lt;OUTPUT_FILE&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Issue Request object. This object follows the model below:</p>  <p>IssueRequest   <p>Request to sign a JSON-LD Credential using public key tied to caller</p>    Field Type Description     document_json string Valid JSON-LD Credential document to be signed, in string form    <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>const issueResponse = await credentialService.issueCredential(\n    IssueRequest.fromPartial({ documentJson: credentialJSON })\n);\n</code></pre>   <pre><code>var credential = await credentialsService.IssueCredentialAsync(new() {DocumentJson = credentialJson});\n_testOutputHelper.WriteLine($\"Credential:\\n{credential.SignedDocumentJson}\");\n</code></pre>   <pre><code>issue_response = await credentials_service.issue_credential(\n    request=IssueRequest(document_json=credential_json)\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var issueResult = credentialService.issueCredential(\n        VerifiableCredentials.IssueRequest\n                .newBuilder()\n                .setDocumentJson(unsignedCredential)\n                .build()\n).get();\n\nvar signedCredentialJson = issueResult.getSignedDocumentJson();\n</code></pre>    <p>The output of this method will be a signed JSON document using BBS+ Signature Suite 2020. This document is not automatically stored in the wallet when issued. You need to call the insert record separately if you'd like to store a copy of this document.</p> <p>The response model is of type Issue Response:</p>  <p>IssueResponse   <p>Response to <code>IssueRequest</code></p>    Field Type Description     signed_document_json string Verifiable Credential document, signed with public key tied to caller of <code>IssueRequest</code>    <p></p>","title":"Issue Credential"},{"location":"reference/services/credential-service/#issue-credential-from-template","text":"<p>Issues a credential from a previously defined template through CreateCredential call. The template is specified by passing a JSON document that matches the structure of the template. For example:</p> <pre><code>{\n    \"field1\": \"value1\",\n    \"field2\": \"value2\",\n    ...\n}\n</code></pre> <p>Do not confuse this operation with Issue Credential where JSON-LD document is required..</p> Trinsic CLI   <pre><code>trinsic vc issue-from-template [OPTIONS] --template-id &lt;ID&gt;\n\n# OPTIONS\n# --out &lt;OUTPUT_FILE&gt;     (Optional) Output file to store the issued credential\n# --values-data &lt;JSON&gt;    The JSON values of the credential subject\n# --values-file &lt;FILE&gt;    The file with JSON values of the credential subject\n</code></pre>    <p>When using one of the SDKs, you must supply an Issue From Template Request object. This object follows the model below:</p>  <p>IssueFromTemplateRequest   <p>Request to create and sign a JSON-LD Verifiable Credential from a template using public key tied to caller</p>    Field Type Description     template_id string ID of template to use   values_json string JSON document string with keys corresponding to the fields of the template referenced by <code>template_id</code>   framework_id string Governance framework ID to use with issuance of this credential. If specified, the issued credential will contain extended issuer metadata with membership info for the given ecosystem governance framework (EGF)    <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>let request = IssueFromTemplateRequest.fromPartial({\n  templateId: templateResponse?.data?.id ?? \"\",\n  valuesJson: JSON.stringify({\n    name: \"Alice\",\n    numberOfBags: 2,\n    dateOfBirth: new Date(\"1/1/2000\").toISOString(),\n    vaccinated: true,\n  }),\n});\n\nlet response = await service.issueFromTemplate(request);\n</code></pre>   <pre><code>var credentialJson = await credentialService.IssueFromTemplateAsync(new() {\n    TemplateId = template.Data.Id,\n    ValuesJson = values\n});\n</code></pre>   <pre><code>values = json.dumps({\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"age\": \"42\"})\nissue_response = await credential_service.issue_from_template(\n    request=IssueFromTemplateRequest(\n        template_id=template.data.id, values_json=values\n    )\n)\n</code></pre>   <pre><code>credentialJSON, err := credentialService.IssueFromTemplate(context.Background(), &amp;credential.IssueFromTemplateRequest{\n    TemplateId: templateResponse.Data.Id,\n    ValuesJson: string(valuesString),\n})\n</code></pre>   <pre><code>var valuesMap = new HashMap&lt;String, Object&gt;();\nvaluesMap.put(\"firstName\", \"Jane\");\nvaluesMap.put(\"lastName\", \"Doe\");\nvaluesMap.put(\"age\", 42);\nvar valuesJson = new Gson().toJson(valuesMap);\nvar issueResponse = credentialService.issueCredentialFromTemplate(VerifiableCredentials.IssueFromTemplateRequest.newBuilder().setTemplateId(template.getData().getId()).setValuesJson(valuesJson).build()).get();\n</code></pre>    <p>The output of this method will be a signed JSON document using BBS+ Signature Suite 2020. This document is not automatically stored in the wallet when issued. You need to call the insert record separately if you'd like to store a copy of this document.</p> <p>The response model is of type Issue From Template Response:</p>  <p>IssueFromTemplateResponse   <p>Response to <code>IssueFromTemplateRequest</code></p>    Field Type Description     document_json string Verifiable Credential document, in JSON-LD form, constructed from the specified template and values; signed with public key tied to caller of <code>IssueFromTemplateRequest</code>    <p></p>","title":"Issue Credential from Template"},{"location":"reference/services/credential-service/#check-revocation-status","text":"<p>Get the credential status (revocation) of a previously issued credential. You must supply the credential id to this call.</p> Trinsic CLI   <pre><code>trinsic vc get-status --credential-status-id &lt;ID&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Check Status Request object. This object follows the model below:</p>  <p>CheckStatusRequest   <p>Request to check a credential's revocation status</p>    Field Type Description     credential_status_id string Credential Status ID to check    <p></p>   <p>Then you can supply it to SDK:</p> C#PythonGoJava   <pre><code>var checkResponse = await credentialService.CheckStatusAsync(new() {CredentialStatusId = \"\"});\n</code></pre>   <pre><code>#     check_response = await credential_service.check_status(\n#         request=CheckStatusRequest(credential_status_id=\"\")\n#     )\n</code></pre>   <pre><code>status, err := credentialService.CheckStatus(context.Background(), &amp;credential.CheckStatusRequest{CredentialStatusId: \"\"})\n</code></pre>   <pre><code>var checkStatusResponse = credentialService.checkStatus(VerifiableCredentials.CheckStatusRequest.newBuilder().build()).get();\n</code></pre>    <p>The response model is of type Check Status Response:</p>  <p>CheckStatusResponse   <p>Response to <code>CheckStatusRequest</code></p>    Field Type Description     revoked bool The credential's revocation status    <p></p>","title":"Check Revocation Status"},{"location":"reference/services/credential-service/#update-revocation-status","text":"<p>Update the credential status (revocation) of a previously issued credential. You must supply the credential id to this call.</p> Trinsic CLI   <pre><code># Revoke a credential\ntrinsic vc update-status --revoked --credential-status-id &lt;ID&gt;\n\n# Unrevoke a credential\ntrinsic vc update-status --unrevoked --credential-status-id &lt;ID&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Update Status Request object. This object follows the model below:</p>  <p>UpdateStatusRequest   <p>Request to update a credential's revocation status</p>    Field Type Description     credential_status_id string Credential Status ID to update   revoked bool New revocation status of credential    <p></p>   <p>Then you can supply it to SDK:</p> C#PythonGoJava   <pre><code>await credentialService.UpdateStatusAsync(new() {CredentialStatusId = \"\", Revoked = true});\n</code></pre>   <pre><code>#     update_response = await credential_service.update_status(\n#         request=UpdateStatusRequest(credential_status_id=\"\", revoked=True)\n#     )\n</code></pre>   <pre><code>updateResponse, err := credentialService.UpdateStatus(context.Background(), &amp;credential.UpdateStatusRequest{CredentialStatusId: \"\", Revoked: true})\n</code></pre>   <pre><code>credentialService.updateStatus(VerifiableCredentials.UpdateStatusRequest.newBuilder().build());\n</code></pre>    <p>The response model is of type Update Status Response:</p>  <p>UpdateStatusResponse   <p>Response to <code>UpdateStatusRequest</code></p> <p></p>","title":"Update Revocation Status"},{"location":"reference/services/credential-service/#create-proof","text":"<p>Wallets allow data to be shared between parties in a secure manner, using a technique called Zero Knowledge Proofs. Trinsic Ecosystems uses the BBS+ Signature Proof scheme to allow data to be selectively disclosed to the requesting party. This allows users to share only the requested subset of data, instead the entire document.</p> <p>The endpoint to create a proof requires two inputs:</p> <ul> <li>document in the wallet that is signed with the correct signature</li> <li>JSONLD frame that describes the data to be disclosed</li> </ul> Trinsic CLI   <pre><code>trinsic vc create-proof --document-id &lt;STRING&gt; --out &lt;OUTPUT_FILE&gt; --reveal-document &lt;JSONLD_FRAME_FILE&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Create Proof Request object. This object follows the model below:</p>  <p>CreateProofRequest   <p>Request to create a proof for a Verifiable Credential using public key tied to caller. Either <code>item_id</code> or <code>document_json</code> may be provided, not both.</p>    Field Type Description     reveal_document_json string A valid JSON-LD frame describing which fields should be revealed in the generated proof. If unspecified, all fields in the document will be revealed   item_id string ID of wallet item stored in a Trinsic cloud wallet   document_json string A valid JSON-LD Verifiable Credential document string with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet.    <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>let proof = await credentialService.createProof(\n  CreateProofRequest.fromPartial({\n    itemId: insertItemResponse.itemId,\n    revealDocumentJson: getVaccineCertFrameJSON(),\n  })\n);\n</code></pre>   <pre><code>var proof = await credentialService.CreateProofAsync(new() {\n    DocumentJson = credentialJson.DocumentJson,\n    RevealDocumentJson = frame.ToString(Formatting.None)\n});\n</code></pre>   <pre><code>proof_response = await credentials_service.create_proof(\n    request=CreateProofRequest(\n        reveal_document_json=proof_request_json, document_json=credential_json\n    )\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var createProofResponse = credentialService.createProof(\n        VerifiableCredentials.CreateProofRequest\n                .newBuilder()\n                .setDocumentJson(signedCredentialJson)\n                .setRevealDocumentJson(proofRequestJson)\n                .build()\n).get();\n\nvar credentialProof = createProofResponse.getProofDocumentJson();\n</code></pre>    <p>The response model is of type Create Proof Response:</p>  <p>CreateProofResponse   <p>Response to <code>CreateProofRequest</code></p>    Field Type Description     proof_document_json string Valid JSON-LD proof for the specified credential    <p></p>","title":"Create Proof"},{"location":"reference/services/credential-service/#verify-proof","text":"<p>This endpoint verifies if the submitted data contains a valid proof. The data to be verified must contain a Linked Data Proof with BBS+ signature scheme.</p> Trinsic CLI   <pre><code># The JSONLD_FILE refers to the proof document obtained from a CreateProofResponse\ntrinsic vc issuer verify-proof --proof-document &lt;JSONLD_FILE&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Verify Proof Request object. This object follows the model below:</p>  <p>VerifyProofRequest   <p>Request to verify a proof</p>    Field Type Description     proof_document_json string JSON-LD proof document string to verify    <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJavaRuby   <pre><code>let verifyResponse = await credentialService.verifyProof({\n  proofDocumentJson: proof.proofDocumentJson,\n});\n</code></pre>   <pre><code>var valid = await credentialService.VerifyProofAsync(new() {ProofDocumentJson = proof.ProofDocumentJson});\n</code></pre>   <pre><code>verify_result = await credentials_service.verify_proof(\n    request=VerifyProofRequest(proof_document_json=credential_proof)\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var verifyProofResponse = credentialService.verifyProof(\n        VerifiableCredentials.VerifyProofRequest\n                .newBuilder()\n                .setProofDocumentJson(credentialProof)\n                .build()\n).get();\n\nboolean isValid = verifyProofResponse.getIsValid();\n</code></pre>     <p>The response model is of type Verify Proof Response:</p>  <p>VerifyProofResponse   <p>Response to <code>VerifyProofRequest</code></p>    Field Type Description     is_valid bool Whether or not all validations in <code>validation_results</code> passed   validation_messages string[] Deprecated. Use <code>validation_results</code> instead   validation_results VerifyProofResponse.ValidationResultsEntry[] Results of each validation check performed, such as schema conformance, revocation status, signature, etc. Detailed results are provided for failed validations.    <p></p>","title":"Verify Proof"},{"location":"reference/services/credential-service/#exchange-credentials","text":"<p>Exchanging data securely is one of the fundamental functions of digital identity systems. There are many specifications with varying maturity that aim to provide interoperable and secure way of exchanging authentic data. We are commited to providing support for these methods.</p> <ul> <li>DIDComm Messaging </li> <li>Wallet And Credential Interactions </li> <li>OpenID Connect Credential Provider </li> </ul>  <p>During this beta period, we are only supporting exchanging data between users by using their email addresses. The messages are routed securely to the destination wallet without leaving the secure network of the ecosystem backend. Our goal is to provide basic ability to share data without affecting the user experience. As interoperable exchange methods become available, we will add this functionality in the SDK.</p>","title":"Exchange Credentials"},{"location":"reference/services/credential-service/#sending-documents-using-email-as-identifier","text":"<p>To send a document to another user, they must have created a wallet and associated their email address with that wallet.</p> Trinsic CLI   <pre><code>trinsic vc send --email &lt;EMAIL_ADDRESS&gt; --item &lt;FILE&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Send Request object. This object follows the model below:</p>  <p>SendRequest   <p>Request to send a document to another user's wallet</p>    Field Type Description     email string Email address of user to send item to   did_uri string DID of recipient (presently unsupported)   didcomm_invitation_json string DIDComm out-of-band invitation JSON (presently unsupported)   document_json string JSON document to send to recipient    <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>await credentialService.send(document, \"admin@example.com\");\n</code></pre>   <pre><code>await credentialsService.SendAsync(new() {Email = \"example@trinsic.id\"});\n</code></pre>   <pre><code>send_response = await credentials_service.send(\n    request=SendRequest(\n        document_json=credential_json, email=\"example@trinsic.id\"\n    )\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>credentialService.send(\n        VerifiableCredentials.SendRequest\n                .newBuilder()\n                .setDocumentJson(signedCredentialJson)\n                .setEmail(recipientEmail)\n                .build()\n);\n</code></pre>    <p>The response model is of type Send Response:</p>  <p>SendResponse   <p>Response to <code>SendRequest</code></p> <p></p>","title":"Sending documents using Email as identifier"},{"location":"reference/services/provider-service/","text":"<p>The Provider Service helps ecosystem providers with data management and onboarding. This service requires a security profile with administrative authorization access. This can be obtained during the deployment of your ecosystem infrastructure.</p>","title":"Provider Service"},{"location":"reference/services/provider-service/#create-ecosystem","text":"<p>Creates a new provider ecosystem</p> Trinsic CLI   <pre><code>trinsic provider create-ecosystem --name &lt;ECOSYSTEM_NAME&gt; --email &lt;OWNER_EMAIL&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply a Create Ecosystem Request object.</p>  <p>CreateEcosystemRequest      Field Type Description     name string Globally unique name for the Ecosystem. This name will be part of the ecosystem specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen.   description string Ecosystem description   uri string External URL associated with your organization or ecosystem entity   details services.account.v1.AccountDetails The account details of the owner of the ecosystem    <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>let actualCreate = await providerService.createEcosystem(\n  CreateEcosystemRequest.fromPartial({\n    description: \"Test ecosystem from Node\",\n    uri: \"https://example.com\",\n  })\n);\n</code></pre>   <pre><code>var (actualCreate, _) = await service.CreateEcosystemAsync(new() {\n    Description = \"My ecosystem\",\n    Uri = \"https://example.com\"\n});\n</code></pre>   <pre><code>actual_create = await provider_service.create_ecosystem(\n    request=CreateEcosystemRequest(\n        description=\"My ecosystem\", uri=\"https://example.com\"\n    )\n)\n</code></pre>   <pre><code>actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n    Description: \"My ecosystem\",\n    Uri:         \"https://example.com\",\n})\n</code></pre>   <pre><code>var response = service.createEcosystem(ProviderOuterClass.CreateEcosystemRequest.newBuilder().setDescription(\"My ecosystem\").setUri(\"https://example.com\").build()).get();\n</code></pre>    <p>The response model is of type Create Ecosystem Response:</p>  <p>CreateEcosystemResponse      Field Type Description     ecosystem Ecosystem Details of the created ecosystem   profile services.account.v1.AccountProfile Account profile for auth of the owner of the ecosystem   confirmation_method services.account.v1.ConfirmationMethod Indicates if confirmation of account is required. This setting is configured globally by the server administrator.    <p></p>","title":"Create Ecosystem"},{"location":"reference/services/provider-service/#onboarding","text":"","title":"Onboarding"},{"location":"reference/services/provider-service/#invite-participant","text":"<p>Users can be added as participants in an ecosystem by sending an invitation and a security code. This code can be sent directly to the invitee using existing platforms or via email, SMS, etc. When users accept this invitation, they should do so using the service methods as described in creating wallet with provider invitation</p> <p>In Trinsic Ecosystems, participants can be Individuals or Organizations. This distinction is important, as providers have the ability to apply restrictions on what functionalities can be invoked by these participants. Additionally, Organizations have the ability to write their DID Document to a public ledger. Currently, the supported ledger is Sovrin, with ION and Element still in development.</p> Trinsic CLI   <pre><code>trinsic provider invite --organization --method-email admin@faber.edu\n\ntrinsic provider invite --person --method-email alice@faber.edu\n</code></pre>    <p>When using one of the SDKs, you must supply an Invite Request object. This object follows the model below:</p>  <p>InviteRequest      Field Type Description     participant ParticipantType Type of participant being invited (individual/organization)   description string Description of invitation   details services.account.v1.AccountDetails Account details of invitee    <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>import { ProviderService, ParticipantType } from \"@trinsic/trinsic\";\n\nconst providerService = new ProviderService();\n\nlet inviteRequest = new InviteRequest();\ninviteRequest.setParticipant(ParticipantType.PARTICIPANT_TYPE_ORGANIZATION);\ninviteRequest.setEmail(\"admin@faber.edu\");\n\nconst inviteResponse = await providerService.inviteParticipant(inviteRequest);\n\nconsole.log(inviteResponse.getInvitationId());\n</code></pre>   <pre><code>var inviteResponse = await service.InviteParticipantAsync(new() {\n    Participant = ParticipantType.Individual,\n    Description = \"Doc sample\",\n    Details = new() {\n        Email = \"example@trinsic.id\"\n    }\n});\n</code></pre>   <pre><code>invite_response = await provider_service.invite_participant(\n    request=InviteRequest(\n        participant=ParticipantType.participant_type_individual,\n        description=\"Doc sample\",\n        details=AccountDetails(email=\"example@trinsic.id\"),\n    )\n)\n</code></pre>   <pre><code>inviteResponse, err := service.InviteParticipant(context.Background(),\n    &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n        Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n</code></pre>   <pre><code>inviteResponse = service.inviteParticipant(ProviderOuterClass.InviteRequest.newBuilder().setParticipant(ProviderOuterClass.ParticipantType.participant_type_individual).setDetails(AccountOuterClass.AccountDetails.newBuilder().setEmail(\"example@trinsic.id\").build()).build()).get();\n</code></pre>    <p>The response model is of type Invite Response:</p>  <p>InviteResponse      Field Type Description     invitation_id string ID of created invitation   invitation_code string Invitation Code that must be passed with the account 'SignIn' request to correlate this user with the invitation sent.     <p></p>   <p>The <code>invitation_code</code> in the response contains is security code that users must supply when creating their wallet. If the email method is used during onboarding, participants will receive this code in their email.</p>","title":"Invite Participant"},{"location":"reference/services/provider-service/#check-invitation-status","text":"<p>User invitation status can be checked with the provided <code>invitation id</code>. It returns an <code>InvitationStatusResponse</code> object.</p> Trinsic CLI   <pre><code>trinsic provider invitation_status &lt;INVITATION_ID&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Invitation Status Request object. This object follows the model below:</p>  <p>InvitationStatusRequest   <p>Request details for the status of onboarding an individual or organization. The reference_id passed is the response from the <code>Onboard</code> method call</p>    Field Type Description     invitation_id string ID of invitation    <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>import { ProviderService, ParticipantType } from \"@trinsic/trinsic\";\n\nconst providerService = new ProviderService();\n\nconst inviteResponse = await providerService.invitationStatus(\"INVITATION ID\");\n\nconsole.log(inviteResponse.getInvitationId());\n</code></pre>   <pre><code>var inviteStatus = await service.InvitationStatusAsync(new() {InvitationId = invitationId});\n</code></pre>   <pre><code>invite_status = await provider_service.invitation_status(\n    request=InvitationStatusRequest(invitation_id=invite_id)\n)\n</code></pre>   <pre><code>inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n</code></pre>   <pre><code>var invitationStatus = service.invitationStatus(ProviderOuterClass.InvitationStatusRequest.newBuilder().setInvitationId(inviteResponse.getInvitationId()).build()).get();\n</code></pre>    <p>The response model is of type Invitation Status Response:</p>  <p>InvitationStatusResponse      Field Type Description     status InvitationStatusResponse.Status Status of invitation   status_details string Human-readable string with details about invitation status    <p></p>","title":"Check Invitation Status"},{"location":"reference/services/template-service/","text":"<p>Credential Templates are JSON templates that help issuers save context when issuing credentials. </p> <p>When issuing a credential through Trinsic, it's as simple as adding the attributes to the credential template and then issuing it. </p> <p>These credential templates can be shared between issuers in an ecosystem. </p>","title":"Template Service"},{"location":"reference/services/template-service/#create-template","text":"<p>Creates a new credential template. Once created, the template is saved in JSON-LD format that can be used to issue and verify credentials.</p> Trinsic CLI   <pre><code>trinsic template create --name 'My Credential' --fields-data '{\\\"field1\\\":{}}'\n</code></pre>    <p>When using one of the SDKs, you must supply a Create Credential Template Request object. This object follows the model below:</p>  <p>CreateCredentialTemplateRequest   <p>Request to create a new template</p>    Field Type Description     name string Name of new template   fields CreateCredentialTemplateRequest.FieldsEntry[] Fields which compose the template   allow_additional_fields bool Whether credentials may be issued against this template which have fields not specified in <code>fields</code>    <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>const credentialTemplateName = `My First Credential Template-${uuid()}`;\nconst nameField = TemplateField.fromPartial({\n  description: \"The name of the person\",\n  type: FieldType.STRING,\n  optional: false,\n});\n\nconst numberOfBags = TemplateField.fromPartial({\n  type: FieldType.NUMBER,\n  description: \"The number of bags the person is taking on the trip\",\n  optional: false,\n});\n\nconst dateOfBirth = TemplateField.fromPartial({\n  type: FieldType.DATETIME,\n  description: \"The date of birth of the person\",\n  optional: false,\n});\n\nconst isVaccinated = TemplateField.fromPartial({\n  type: FieldType.BOOL,\n  description: \"Whether or not the person has been vaccinated\",\n  optional: false,\n});\n</code></pre>   <pre><code>CreateCredentialTemplateRequest templateRequest = new() {\n    Name = \"An Example Credential\",\n    AllowAdditionalFields = false\n};\ntemplateRequest.Fields.Add(\"firstName\", new() {Description = \"Given name\"});\ntemplateRequest.Fields.Add(\"lastName\", new());\ntemplateRequest.Fields.Add(\"age\", new() {Optional = true}); // TODO - use FieldType.NUMBER once schema validation is fixed.\n\nvar template = await templateService.CreateAsync(templateRequest);\n</code></pre>   <pre><code>template = await template_service.create(\n    request=CreateCredentialTemplateRequest(\n        name=f\"An Example Credential: {uuid.uuid4()}\",\n        allow_additional_fields=False,\n        fields={\n            \"firstName\": TemplateField(description=\"Given name\"),\n            \"lastName\": TemplateField(),\n            \"age\": TemplateField(optional=True, type=FieldType.NUMBER),\n        },\n    )\n)\n</code></pre>   <pre><code>templateRequest := &amp;template.CreateCredentialTemplateRequest{Name: fmt.Sprintf(\"Example Template - %s\", uuid.New()), AllowAdditionalFields: false, Fields: make(map[string]*template.TemplateField)}\ntemplateRequest.Fields[\"firstName\"] = &amp;template.TemplateField{Description: \"Given name\"}\ntemplateRequest.Fields[\"lastName\"] = &amp;template.TemplateField{}\ntemplateRequest.Fields[\"age\"] = &amp;template.TemplateField{Type: template.FieldType_NUMBER, Optional: true}\n\ntemplateResponse, err := templateService.Create(context.Background(), templateRequest)\n</code></pre>   <pre><code>var fields = new HashMap&lt;String, Templates.TemplateField&gt;();\nfields.put(\"firstName\", Templates.TemplateField.newBuilder().setDescription(\"Given name\").build());\nfields.put(\"lastName\", Templates.TemplateField.newBuilder().build());\nfields.put(\"age\", Templates.TemplateField.newBuilder().setType(Templates.FieldType.NUMBER).setOptional(true).build());\nvar templateRequest = Templates.CreateCredentialTemplateRequest.newBuilder().setName(\"My Example Credential-\" + UUID.randomUUID()).setAllowAdditionalFields(false).putAllFields(fields).build();\nvar template = templateService.create(templateRequest).get();\n</code></pre>    <p>The response model is of type Create Credential Template Response:</p>  <p>CreateCredentialTemplateResponse   <p>Response to <code>CreateCredentialTemplateRequest</code></p>    Field Type Description     data TemplateData Created template    <p></p>  <p> </p>","title":"Create Template"},{"location":"reference/services/template-service/#get","text":"<p>Get the specified credential template through the supplied template/definition ID.</p> Trinsic CLI   <pre><code>trinsic template get --id &lt;TEMPLATE_ID&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply a Get Credential Template Request object. This object follows the model below:</p>  <p>GetCredentialTemplateRequest   <p>Request to fetch a template by ID</p>    Field Type Description     id string ID of template to fetch    <p></p>   <p>Then you can supply it to SDK:</p> C#PythonGoJava   <pre><code>var getTemplateResponse = await templateService.GetAsync(new() {Id = template.Data.Id});\n</code></pre>   <pre><code>get_template_response = await template_service.get(\n    request=GetCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre>   <pre><code>getResponse, err := templateService.Get(context.Background(), &amp;template.GetCredentialTemplateRequest{Id: templateResponse.Data.Id})\n</code></pre>   <pre><code>var getResponse = templateService.get(Templates.GetCredentialTemplateRequest.newBuilder().setId(id).build()).get();\n</code></pre>    <p>The response model is of type Get Credential Template Response:</p>  <p>GetCredentialTemplateResponse   <p>Response to <code>GetCredentialTemplateRequest</code></p>    Field Type Description     template TemplateData Template fetched by ID    <p></p>","title":"Get"},{"location":"reference/services/template-service/#search-query","text":"<p>Querying template data in our SDK is enabled through the use of familiar SQL syntax. All data is stored in JSON-LD format, so it can be easily searched. This approach allows us to give developers full control over how data is retrieved. In addition to customizable sorting, paging and filtering, developers have the ability to construct projections, combine result sets, and even run user-defined functions over their queries.</p> <p>Template searching works very similarly to Wallet searching. Please refer to Wallet Service &gt; Search / Query for more information.</p>","title":"Search / Query"},{"location":"reference/services/template-service/#basic-search","text":"<p>The default query used in the commands below returns the first 100 items in the template result set. The query is <code>SELECT * FROM c OFFSET 0 LIMIT 100</code>.</p> Trinsic CLI   <pre><code>trinsic template search\n</code></pre>","title":"Basic Search"},{"location":"reference/services/template-service/#sql-search","text":"<p>To pass custom query to the search function, use the query parameter or the available overload.</p> Trinsic CLIC#PythonGoJava   <pre><code>trinsic wallet search \\\n    --query \"SELECT * FROM c\"\n</code></pre>   <pre><code>var searchTemplateResponse = await templateService.SearchAsync(new() {Query = \"SELECT * FROM c\"});\n</code></pre>   <pre><code>search_template_response = await template_service.search(\n    request=SearchCredentialTemplatesRequest(query=\"SELECT * FROM c\")\n)\n</code></pre>   <pre><code>searchResponse, err := templateService.Search(context.Background(), &amp;template.SearchCredentialTemplatesRequest{Query: \"SELECT * FROM c\"})\n</code></pre>   <pre><code>var searchResponse = templateService.search(Templates.SearchCredentialTemplatesRequest.newBuilder().setQuery(\"SELECT * FROM c WHERE c.id = '\" + id + \"'\").build()).get();\n</code></pre>","title":"SQL Search"},{"location":"reference/services/template-service/#delete","text":"<p>Deletes a credential template.</p> Trinsic CLI   <pre><code>trinsic tamplate delete --id &lt;TEMPLATE_ID&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply a Delete Credential Template Request object. This object follows the model below:</p>  <p>DeleteCredentialTemplateRequest   <p>Request to delete a template by ID</p>    Field Type Description     id string ID of template to delete    <p></p>   <p>Then you can supply it to SDK:</p> C#PythonGoJava   <pre><code>var deleteTemplateResponse = await templateService.DeleteAsync(new() {Id = template.Data.Id});\n</code></pre>   <pre><code>delete_template_response = await template_service.delete(\n    request=DeleteCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre>   <pre><code>deleteResponse, err := templateService.Delete(context.Background(), &amp;template.DeleteCredentialTemplateRequest{Id: templateResponse.Data.Id})\n</code></pre>   <pre><code>var deleteResponse = templateService.delete(Templates.DeleteCredentialTemplateRequest.newBuilder().setId(id).build()).get();\n</code></pre>","title":"Delete"},{"location":"reference/services/trust-registry-service/","text":"<p>In many real-world credential exchange scenarios, a credential holder or verifier has the question \u201cHow do I know the issuer of this credential is trustworthy?\u201d</p> <p>Credential holders may also be uneasy about sharing information with a verifier if trust in the verifier has not been established.</p> <p>These problems can be solved by having a trusted third party vouch for the trustworthiness of a credential exchange participant.</p> <p>A trust registry is a list of authorized issuers and verifiers in the ecosystem and the types of credentials and passes they are authorized to issue and verify.</p> <p></p>","title":"Trust Registry"},{"location":"reference/services/trust-registry-service/#specification","text":"<p>The Trust over IP Foundation has a specification for an interoperable trust registry.  This defines an API interface so that trust registries can be queried in the same way. Our implementation is based off of this trust registry spec.</p>","title":"Specification"},{"location":"reference/services/trust-registry-service/#api-reference","text":"","title":"API Reference"},{"location":"reference/services/trust-registry-service/#create-a-ecosystem-governance-framework","text":"<p>An ecosystem governance framework is useful because it provides a good basis for verifying issuers and verifiers. It's a json-ld document that lists the issuers and verifiers. These issuers and verifiers are identified by a decentralized identifier. The governance framework is signified by an identifier as well. This can be used to represent the governance framework outside in the credential that it comes in. </p> Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry register-efg\n</code></pre>   <pre><code>var schemaUri = \"https://schema.org/Card\";\nvar frameworkUri = \"https://example.com\";\nvar registerFrameworkResponse = await service.AddFrameworkAsync(new() {\n    Name = $\"Demo framework-{Guid.NewGuid()}\",\n    GovernanceFrameworkUri = frameworkUri,\n    Description = schemaUri\n});\n</code></pre>   <pre><code>register_framework_response = await service.add_framework(\n    request=AddFrameworkRequest(\n        governance_framework_uri=https_example_com,\n        description=\"Demo framework\",\n        name=framework_name,\n    )\n)\n</code></pre>   <pre><code>newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n    GovernanceFrameworkUri: frameworkURI,\n    Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n})\n</code></pre>   <pre><code>package trinsic;\n\nimport org.junit.jupiter.api.Assertions;\nimport trinsic.okapi.DidException;\nimport trinsic.services.AccountService;\nimport trinsic.services.TrustRegistryService;\nimport trinsic.services.trustregistry.v1.TrustRegistryOuterClass;\n\nimport java.io.IOException;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutionException;\n\npublic class TrustRegistryDemo {\n    public static void main(String[] args) throws IOException, DidException, ExecutionException, InterruptedException {\n        run();\n    }\n\n    public static void run() throws IOException, DidException, ExecutionException, InterruptedException {\n        var accountService = new AccountService(TrinsicUtilities.getTrinsicServiceOptions());\n        var account = accountService.signIn().get();\n        var service = new TrustRegistryService(TrinsicUtilities.getTrinsicServiceOptions(account));\n\n        final String didUri = \"did:example:test\";\n        final String frameworkUri = \"https://example.com/\" + UUID.randomUUID();\n        final String typeUri = \"https://schema.org/Card\";\n\n        // addFramework() {\n        var frameworkResponse = service.addFramework(TrustRegistryOuterClass.AddFrameworkRequest.newBuilder().setGovernanceFrameworkUri(frameworkUri).setName(\"Example Framework\" + UUID.randomUUID()).build()).get();\n        // }\n\n        // registerIssuerSample() {\n        service.registerMember(TrustRegistryOuterClass.RegisterMemberRequest.newBuilder().setDidUri(didUri).setFrameworkId(frameworkResponse.getId()).setSchemaUri(typeUri).build());\n        // }\n        // checkIssuerStatus() {\n        var issuerStatus = service.checkIssuerStatus(TrustRegistryOuterClass.GetMembershipStatusRequest.newBuilder().setDidUri(didUri).setGovernanceFrameworkUri(frameworkUri).setSchemaUri(typeUri).build()).get();\n        // }\n        Assertions.assertEquals(TrustRegistryOuterClass.RegistrationStatus.CURRENT, issuerStatus.getStatus());\n\n        // searchTrustRegistry() {\n        var searchResult = service.searchRegistry().get();\n        // }\n        Assertions.assertNotNull(searchResult);\n        Assertions.assertNotNull(searchResult.getItemsJson());\n        Assertions.assertTrue(searchResult.getItemsJson().length() &gt; 0);\n\n        // unregisterIssuer() {\n        service.unregisterIssuer(TrustRegistryOuterClass.UnregisterMemberRequest.newBuilder().setFrameworkId(frameworkResponse.getId()).setDidUri(didUri).setSchemaUri(typeUri).build());\n        // }\n    }\n}\n</code></pre>","title":"Create a Ecosystem Governance Framework"},{"location":"reference/services/trust-registry-service/#register-issuers","text":"<p>Each entity on the governance framework, whether an issuer or a verifier, is represented by a decentralized identifier. These entities are registered to either issue or verify specific credential types. A credential type is represented as a fully qualified <code>type</code> URI, of the kind found in a JSON-LD Verifiable Credential. Finally, each entity must be registered on a specific governance framework. </p> Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry register-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>var didUri = \"did:example:test\";\nvar registerMemberResponse = await service.RegisterMemberAsync(new() {\n    DidUri = didUri,\n    FrameworkId = registerFrameworkResponse.Id,\n    SchemaUri = schemaUri\n});\n</code></pre>   <pre><code>await service.register_member(\n    request=RegisterMemberRequest(\n        did_uri=did_example_test,\n        framework_id=register_framework_response.id,\n        schema_uri=https_schema_org,\n    )\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>service.registerMember(TrustRegistryOuterClass.RegisterMemberRequest.newBuilder().setDidUri(didUri).setFrameworkId(frameworkResponse.getId()).setSchemaUri(typeUri).build());\n</code></pre>","title":"Register Issuers"},{"location":"reference/services/trust-registry-service/#register-verifiers","text":"Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry register-verifier \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>using System;\nusing System.Diagnostics.CodeAnalysis;\nusing System.IO;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing FluentAssertions;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing Trinsic;\nusing Trinsic.Sdk.Options.V1;\nusing Trinsic.Services.Common.V1;\nusing Trinsic.Services.Provider.V1;\nusing Trinsic.Services.TrustRegistry.V1;\nusing Trinsic.Services.VerifiableCredentials.Templates.V1;\nusing Xunit;\nusing Xunit.Abstractions;\nusing JsonSerializer = System.Text.Json.JsonSerializer;\n\n#pragma warning disable CS0618\n\nnamespace Tests;\n\n[SuppressMessage(\"ReSharper\", \"MethodHasAsyncOverload\")]\npublic class Tests\n{\n#if DEBUG\n    private const string DefaultEndpoint = \"localhost\";\n    private const int DefaultPort = 5000;\n    private const bool DefaultUseTls = false;\n#else\n    private const string DefaultEndpoint = \"staging-internal.trinsic.cloud\";\n    private const int DefaultPort = 443;\n    private const bool DefaultUseTls = true;\n#endif\n\n    private readonly ITestOutputHelper _testOutputHelper;\n    private readonly ServiceOptions _options;\n\n    public Tests(ITestOutputHelper testOutputHelper) {\n        _testOutputHelper = testOutputHelper;\n\n        _options = new() {\n            ServerEndpoint = Environment.GetEnvironmentVariable(\"TEST_SERVER_ENDPOINT\") ?? DefaultEndpoint,\n            ServerPort = int.TryParse(Environment.GetEnvironmentVariable(\"TEST_SERVER_PORT\"), out var port) ? port : DefaultPort,\n            ServerUseTls = bool.TryParse(Environment.GetEnvironmentVariable(\"TEST_SERVER_USE_TLS\"), out var tls) ? tls : DefaultUseTls\n        };\n\n        _testOutputHelper.WriteLine($\"Testing endpoint: {_options.FormatUrl()}\");\n    }\n\n    private const string VaccinationCertificateUnsigned = \"TestData/vaccination-certificate-unsigned.jsonld\";\n    private const string VaccinationCertificateFrame = \"TestData/vaccination-certificate-frame.jsonld\";\n\n    [Fact(DisplayName = \"Demo: wallet and credential sample\")]\n    public async Task TestWalletService() {\n        // createAccountService() {\n        var providerService = new ProviderService(_options.Clone());\n        var accountService = new AccountService(_options.Clone());\n        var (ecosystem, _) = providerService.CreateEcosystem(new());\n        var ecosystemId = ecosystem.Id;\n        // }\n\n        // SETUP ACTORS\n        // Create 3 different profiles for each participant in the scenario\n        // setupActors() {\n        var allison = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\n        var clinic = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\n        var airline = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\n        // }\n\n        accountService.Options.AuthToken = clinic;\n        var info = await accountService.GetInfoAsync();\n        info.Should().NotBeNull();\n\n        // createService() {\n        var walletService = new WalletService(_options.CloneWithAuthToken(allison));\n        var credentialsService = new CredentialService(_options.CloneWithAuthToken(clinic));\n        // }\n\n        // ISSUE CREDENTIAL\n        // Sign a credential as the clinic and send it to Allison\n        // issueCredential() {\n        // Set active profile to 'clinic' so we can issue credential signed\n        // with the clinic's signing keys\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = clinic;\n\n        // Read the JSON credential data\n        var credentialJson = await File.ReadAllTextAsync(VaccinationCertificateUnsigned);\n        // Sign the credential using BBS+ signature scheme\n        // issueCredentialSample() {\n        var credential = await credentialsService.IssueCredentialAsync(new() {DocumentJson = credentialJson});\n        _testOutputHelper.WriteLine($\"Credential:\\n{credential.SignedDocumentJson}\");\n        // }\n        // }\n\n        // storeAndRecallProfile {\n        // Serialize auth token by exporting it to file\n        File.WriteAllText(\"allison.txt\", allison);\n        // Create auth token from existing data\n        allison = File.ReadAllText(\"allison.txt\");\n        // }\n\n        try {\n            // sendCredential() {\n            await credentialsService.SendAsync(new() {Email = \"example@trinsic.id\"});\n            // }\n        } catch { } // We expect this to fail\n\n        // STORE CREDENTIAL\n        // Allison stores the credential in her cloud wallet.\n\n        // storeCredential() {\n        // Set active profile to 'allison' so we can manage her cloud wallet\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = allison;\n\n        var insertItemResponse = await walletService.InsertItemAsync(new() {ItemJson = credential.SignedDocumentJson});\n        var itemId = insertItemResponse.ItemId;\n        // }\n        // searchWalletBasic() {\n        var walletItems = await walletService.SearchAsync(new());\n        // }\n        _testOutputHelper.WriteLine($\"Last wallet item:\\n{walletItems.Items.Last()}\");\n\n        // searchWalletSQL() { \n        var walletItems2 = await walletService.SearchAsync(new() {Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"});\n        // }\n\n        // SHARE CREDENTIAL\n        // Allison shares the credential with the venue.\n        // The venue has communicated with Allison the details of the credential\n        // that they require expressed as a JSON-LD frame.\n        // shareCredential() {\n        // We'll read the request frame from a file and communicate this with Allison\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = allison;\n\n        var proofRequestJson = await File.ReadAllTextAsync(VaccinationCertificateFrame);\n\n        // Build a proof for the given request and the `itemId` we previously received\n        // which points to the stored credential\n        var credentialProof = await credentialsService.CreateProofAsync(new() {\n            ItemId = itemId,\n            RevealDocumentJson = proofRequestJson\n        });\n        _testOutputHelper.WriteLine(\"Proof:\");\n        _testOutputHelper.WriteLine(credentialProof.ProofDocumentJson);\n        // }\n\n\n        // VERIFY CREDENTIAL\n        // verifyCredential() {\n        // The airline verifies the credential\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = airline;\n\n        // Check for valid signature\n        var valid = await credentialsService.VerifyProofAsync(new() {\n            ProofDocumentJson = credentialProof.ProofDocumentJson\n        });\n        _testOutputHelper.WriteLine($\"Verification result: {valid.IsValid}\");\n        Assert.True(valid.IsValid);\n        // }\n    }\n\n    [Fact(DisplayName = \"Demo: trust registries\")]\n    public async Task TestTrustRegistry() {\n        var governanceUri = $\"https://example.com/{Guid.NewGuid():N}\";\n\n        // setup\n        var providerService = new ProviderService(_options.Clone());\n        var (_, authToken) = await providerService.CreateEcosystemAsync(new());\n        var service = new TrustRegistryService(_options.CloneWithAuthToken(authToken));\n\n        // registerGovernanceFramework() {\n        var schemaUri = \"https://schema.org/Card\";\n        var frameworkUri = \"https://example.com\";\n        var registerFrameworkResponse = await service.AddFrameworkAsync(new() {\n            Name = $\"Demo framework-{Guid.NewGuid()}\",\n            GovernanceFrameworkUri = frameworkUri,\n            Description = schemaUri\n        });\n        // }\n\n\n        // registerIssuerSample() {\n        var didUri = \"did:example:test\";\n        var registerMemberResponse = await service.RegisterMemberAsync(new() {\n            DidUri = didUri,\n            FrameworkId = registerFrameworkResponse.Id,\n            SchemaUri = schemaUri\n        });\n        // }\n\n        // checkIssuerStatus() {\n        var issuerStatus = await service.GetMembershipStatusAsync(new() {\n            DidUri = didUri,\n            GovernanceFrameworkUri = frameworkUri,\n            SchemaUri = schemaUri\n        });\n        // }\n        issuerStatus.Should().NotBeNull();\n        issuerStatus.Status.Should().Be(RegistrationStatus.Current);\n\n        // searchTrustRegistry() {\n        var searchResult = await service.SearchRegistryAsync(new());\n        // }\n\n        searchResult.Should().NotBeNull();\n        searchResult.ItemsJson.Should().NotBeNull().And.NotBeEmpty();\n\n        // unregisterIssuer() {\n        await service.UnregisterMemberAsync(new() {\n            DidUri = didUri,\n            FrameworkId = registerFrameworkResponse.Id,\n            SchemaUri = schemaUri\n        });\n        // }\n    }\n\n    [Fact(DisplayName = \"Demo: ecosystem creation and listing\")]\n    public async Task EcosystemTests() {\n        // setup\n        var accountService = new AccountService(_options);\n        var account = await accountService.SignInAsync(new());\n        var service = new ProviderService(_options.CloneWithAuthToken(account));\n\n        // test create ecosystem\n        // createEcosystem() {\n        var (actualCreate, _) = await service.CreateEcosystemAsync(new() {\n            Description = \"My ecosystem\",\n            Uri = \"https://example.com\"\n        });\n        // }\n\n        actualCreate.Should().NotBeNull();\n        actualCreate.Id.Should().NotBeNull();\n        actualCreate.Id.Should().StartWith(\"urn:trinsic:ecosystems:\");\n\n        try {\n            // inviteParticipant() {\n            var inviteResponse = await service.InviteParticipantAsync(new() {\n                Participant = ParticipantType.Individual,\n                Description = \"Doc sample\",\n                Details = new() {\n                    Email = \"example@trinsic.id\"\n                }\n            });\n            // }\n        } catch(Exception) { } // This is expected as a doc sample\n\n        var invitationId = \"N/A\";\n        try {\n            // invitationStatus() {\n            var inviteStatus = await service.InvitationStatusAsync(new() {InvitationId = invitationId});\n            // }\n        } catch(Exception) { } // This is expected as a doc sample\n    }\n\n    [Fact]\n    public async Task TestProtectUnprotectProfile() {\n        // testSignInAndGetInfo() {\n        // accountServiceConstructor() {\n        var myAccountService = new AccountService(_options);\n        // }\n        // accountServiceSignIn() {\n        var myProfile = await myAccountService.SignInAsync(new());\n        // }\n        myAccountService.Options.AuthToken = myProfile;\n        // accountServiceGetInfo() {\n        var output = await myAccountService.GetInfoAsync();\n        // }\n        Assert.NotNull(output);\n        // }\n\n        // protectUnprotectProfile() {\n        var securityCode = \"1234\";\n        var myProtectedProfile = AccountService.Protect(myProfile, securityCode);\n        var myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n        // }\n        myAccountService.Options.AuthToken = myProtectedProfile;\n        await Assert.ThrowsAsync&lt;Exception&gt;(myAccountService.GetInfoAsync);\n        myAccountService.Options.AuthToken = myUnprotectedProfile;\n        Assert.NotNull(await myAccountService.GetInfoAsync());\n        Assert.NotNull(myAccountService.GetInfo());\n    }\n\n    [Fact]\n    public async Task TestInvitationIdSet() {\n        var providerService = new ProviderService(_options.Clone());\n        _ = await providerService.CreateEcosystemAsync(new());\n\n        var invitationResponse = await providerService.InviteParticipantAsync(new());\n\n        invitationResponse.Should().NotBeNull();\n        invitationResponse.InvitationCode.Should().NotBeEmpty();\n\n        await Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; await providerService.InvitationStatusAsync(new()));\n    }\n\n    [Fact(Skip = \"Ecosystem support not complete yet\")]\n    public async Task TestInviteParticipant() {\n        var myAccountService = new AccountService(_options);\n        var myProfile = await myAccountService.SignInAsync(new());\n        var myProviderService = new ProviderService(_options.CloneWithAuthToken(myProfile));\n        var invite = new InviteRequest {Description = \"Test invitation\"};\n        var response = await myProviderService.InviteParticipantAsync(invite);\n        Assert.NotNull(response);\n\n        var statusResponse = await myProviderService.InvitationStatusAsync(new() {InvitationId = response.InvitationId});\n        Assert.NotNull(statusResponse);\n    }\n\n    [Fact]\n    public async Task TestGovernanceFrameworkUriParse() {\n        var myAccountService = new AccountService(_options);\n        var myProfile = await myAccountService.SignInAsync(new());\n        var myTrustRegistryService = new TrustRegistryService(_options.CloneWithAuthToken(myProfile));\n        await Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; await myTrustRegistryService.AddFrameworkAsync(new() {\n            Description = \"invalid uri\",\n            GovernanceFrameworkUri = \"\"\n        }));\n    }\n\n    [Fact(DisplayName = \"Demo: template management and credential issuance from template\")]\n    public async Task DemoTemplatesWithIssuance() {\n        var providerService = new ProviderService(_options.Clone());\n        var (_, authToken) = await providerService.CreateEcosystemAsync(new());\n        var options = _options.CloneWithAuthToken(authToken);\n\n        var templateService = new TemplateService(options);\n        var credentialService = new CredentialService(options);\n        var walletService = new WalletService(options);\n\n        // create example template\n        // createTemplate() {\n        CreateCredentialTemplateRequest templateRequest = new() {\n            Name = \"An Example Credential\",\n            AllowAdditionalFields = false\n        };\n        templateRequest.Fields.Add(\"firstName\", new() {Description = \"Given name\"});\n        templateRequest.Fields.Add(\"lastName\", new());\n        templateRequest.Fields.Add(\"age\", new() {Optional = true}); // TODO - use FieldType.NUMBER once schema validation is fixed.\n\n        var template = await templateService.CreateAsync(templateRequest);\n        // }\n\n        template.Should().NotBeNull();\n        template.Data.Should().NotBeNull();\n        template.Data.Id.Should().NotBeNull();\n        template.Data.SchemaUri.Should().NotBeNull();\n\n        // issue credential from this template\n        var values = JsonSerializer.Serialize(new {\n            firstName = \"Jane\",\n            lastName = \"Doe\",\n            age = \"42\"\n        });\n\n        // issueFromTemplate() {\n        var credentialJson = await credentialService.IssueFromTemplateAsync(new() {\n            TemplateId = template.Data.Id,\n            ValuesJson = values\n        });\n        // }\n\n        credentialJson.Should().NotBeNull();\n\n        var jsonDocument = JsonDocument.Parse(credentialJson.DocumentJson).RootElement.EnumerateObject();\n\n        jsonDocument.Should().Contain(x =&gt; x.Name == \"id\");\n        jsonDocument.Should().Contain(x =&gt; x.Name == \"credentialSubject\");\n\n        // insertItemWallet() {\n        var insertItemResponse = await walletService.InsertItemAsync(new() {ItemJson = credentialJson.DocumentJson});\n        // }\n        var itemId = insertItemResponse.ItemId;\n\n        var frame = new JObject {\n            {\"@context\", \"https://www.w3.org/2018/credentials/v1\"},\n            {\"type\", new JArray(\"VerifiableCredential\")}\n        };\n\n        // Create proof from input document\n        // createProof() {\n        var proof = await credentialService.CreateProofAsync(new() {\n            DocumentJson = credentialJson.DocumentJson,\n            RevealDocumentJson = frame.ToString(Formatting.None)\n        });\n        // }\n        // verifyProof() {\n        var valid = await credentialService.VerifyProofAsync(new() {ProofDocumentJson = proof.ProofDocumentJson});\n        // }\n        valid.IsValid.Should().BeTrue();\n\n        // Create proof from item id\n        var proof2 = await credentialService.CreateProofAsync(new() {\n            ItemId = itemId,\n            RevealDocumentJson = frame.ToString(Formatting.None)\n        });\n\n        var valid2 = await credentialService.VerifyProofAsync(new() {ProofDocumentJson = proof2.ProofDocumentJson});\n\n        valid2.IsValid.Should().BeTrue();\n\n        try {\n            // checkCredentialStatus() {\n            var checkResponse = await credentialService.CheckStatusAsync(new() {CredentialStatusId = \"\"});\n            // }\n        } catch { } // We expect this to fail\n\n        try {\n            // updateCredentialStatus() {\n            await credentialService.UpdateStatusAsync(new() {CredentialStatusId = \"\", Revoked = true});\n            // }\n        } catch { } // We expect this to fail\n\n        // getCredentialTemplate() {\n        var getTemplateResponse = await templateService.GetAsync(new() {Id = template.Data.Id});\n        // }\n        // searchCredentialTemplate() {\n        var searchTemplateResponse = await templateService.SearchAsync(new() {Query = \"SELECT * FROM c\"});\n        // }\n        // deleteCredentialTemplate() {\n        var deleteTemplateResponse = await templateService.DeleteAsync(new() {Id = template.Data.Id});\n        // }\n    }\n\n    [Fact(DisplayName = \"Decode base64 url encoded string\")]\n    public void DecodeBase64UrlString() {\n        const string encoded =\n            \"CiVodHRwczovL3RyaW5zaWMuaWQvc2VjdXJpdHkvdjEvb2Jlcm9uEnIKKnVybjp0cmluc2ljOndhbGxldHM6Vzl1dG9pVmhDZHp2RXJZRGVyOGlrRxIkODBkMTVlYTYtMTIxOS00MGZmLWE4NTQtZGI1NmZhOTlmNjMwIh51cm46dHJpbnNpYzplY29zeXN0ZW1zOmRlZmF1bHQaMJRXhevRbornRpA-HJ86WaTLGmQlOuoXSnDT_W2O3u3bV5rS5nKpgrfGKFEbRtIgjyIA\";\n\n        var actual = Base64Url.Decode(encoded);\n\n        actual.Should().NotBeEmpty();\n    }\n}\n</code></pre>   <pre><code>import asyncio\nimport uuid\n\nfrom trinsic.account_service import AccountService\nfrom trinsic.proto.services.trustregistry.v1 import (\n    RegistrationStatus,\n    AddFrameworkRequest,\n    UnregisterMemberRequest,\n    GetMembershipStatusRequest,\n    RegisterMemberRequest,\n)\nfrom trinsic.trinsic_util import trinsic_config\nfrom trinsic.trustregistry_service import TrustRegistryService\n\n\nasync def trustregistry_demo():\n    # setup\n    account_service = AccountService(server_config=trinsic_config())\n    account = await account_service.sign_in()\n    service = TrustRegistryService(server_config=trinsic_config(account))\n\n    # data\n    https_schema_org = \"https://schema.org/Card\"\n    https_example_com = f\"https://example.com/{uuid.uuid4()}\"\n    did_example_test = \"did:example:test\"\n    framework_name = f\"Example Framework: {uuid.uuid4()}\"\n\n    # registerGovernanceFramework() {\n    register_framework_response = await service.add_framework(\n        request=AddFrameworkRequest(\n            governance_framework_uri=https_example_com,\n            description=\"Demo framework\",\n            name=framework_name,\n        )\n    )\n    # }\n\n    # registerIssuerSample() {\n    await service.register_member(\n        request=RegisterMemberRequest(\n            did_uri=did_example_test,\n            framework_id=register_framework_response.id,\n            schema_uri=https_schema_org,\n        )\n    )\n    # }\n\n    # checkIssuerStatus() {\n    check_response = await service.get_membership_status(\n        request=GetMembershipStatusRequest(\n            did_uri=did_example_test,\n            governance_framework_uri=https_example_com,\n            schema_uri=https_schema_org,\n        )\n    )\n    # }\n    issuer_status = check_response.status\n    assert issuer_status == RegistrationStatus.CURRENT\n\n    # searchTrustRegistry() {\n    search_result = await service.search_registry()\n    # }\n    assert search_result is not None\n    assert search_result.items_json is not None\n    assert len(search_result.items_json) &gt; 0\n\n    # unregisterIssuer() {\n    unregister_issuer_response = await service.unregister_member(\n        request=UnregisterMemberRequest(\n            framework_id=register_framework_response.id,\n            schema_uri=https_schema_org,\n            did_uri=did_example_test,\n        )\n    )\n    # }\n\n\nif __name__ == \"__main__\":\n    asyncio.run(trustregistry_demo())\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>package trinsic;\n\nimport org.junit.jupiter.api.Assertions;\nimport trinsic.okapi.DidException;\nimport trinsic.services.AccountService;\nimport trinsic.services.TrustRegistryService;\nimport trinsic.services.trustregistry.v1.TrustRegistryOuterClass;\n\nimport java.io.IOException;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutionException;\n\npublic class TrustRegistryDemo {\n    public static void main(String[] args) throws IOException, DidException, ExecutionException, InterruptedException {\n        run();\n    }\n\n    public static void run() throws IOException, DidException, ExecutionException, InterruptedException {\n        var accountService = new AccountService(TrinsicUtilities.getTrinsicServiceOptions());\n        var account = accountService.signIn().get();\n        var service = new TrustRegistryService(TrinsicUtilities.getTrinsicServiceOptions(account));\n\n        final String didUri = \"did:example:test\";\n        final String frameworkUri = \"https://example.com/\" + UUID.randomUUID();\n        final String typeUri = \"https://schema.org/Card\";\n\n        // addFramework() {\n        var frameworkResponse = service.addFramework(TrustRegistryOuterClass.AddFrameworkRequest.newBuilder().setGovernanceFrameworkUri(frameworkUri).setName(\"Example Framework\" + UUID.randomUUID()).build()).get();\n        // }\n\n        // registerIssuerSample() {\n        service.registerMember(TrustRegistryOuterClass.RegisterMemberRequest.newBuilder().setDidUri(didUri).setFrameworkId(frameworkResponse.getId()).setSchemaUri(typeUri).build());\n        // }\n        // checkIssuerStatus() {\n        var issuerStatus = service.checkIssuerStatus(TrustRegistryOuterClass.GetMembershipStatusRequest.newBuilder().setDidUri(didUri).setGovernanceFrameworkUri(frameworkUri).setSchemaUri(typeUri).build()).get();\n        // }\n        Assertions.assertEquals(TrustRegistryOuterClass.RegistrationStatus.CURRENT, issuerStatus.getStatus());\n\n        // searchTrustRegistry() {\n        var searchResult = service.searchRegistry().get();\n        // }\n        Assertions.assertNotNull(searchResult);\n        Assertions.assertNotNull(searchResult.getItemsJson());\n        Assertions.assertTrue(searchResult.getItemsJson().length() &gt; 0);\n\n        // unregisterIssuer() {\n        service.unregisterIssuer(TrustRegistryOuterClass.UnregisterMemberRequest.newBuilder().setFrameworkId(frameworkResponse.getId()).setDidUri(didUri).setSchemaUri(typeUri).build());\n        // }\n    }\n}\n</code></pre>","title":"Register Verifiers"},{"location":"reference/services/trust-registry-service/#unregister-issuers","text":"<p>To unregister an issuer, include the credential type, the did, and the ecosystem governance framework. The credential type will be unregistered from that issuer.</p> Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry unregister-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>await service.UnregisterMemberAsync(new() {\n    DidUri = didUri,\n    FrameworkId = registerFrameworkResponse.Id,\n    SchemaUri = schemaUri\n});\n</code></pre>   <pre><code>unregister_issuer_response = await service.unregister_member(\n    request=UnregisterMemberRequest(\n        framework_id=register_framework_response.id,\n        schema_uri=https_schema_org,\n        did_uri=did_example_test,\n    )\n)\n</code></pre>   <pre><code>unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n    SchemaUri:   schemaURI,\n    FrameworkId: newFramework.Id,\n})\n</code></pre>   <pre><code>service.unregisterIssuer(TrustRegistryOuterClass.UnregisterMemberRequest.newBuilder().setFrameworkId(frameworkResponse.getId()).setDidUri(didUri).setSchemaUri(typeUri).build());\n</code></pre>","title":"Unregister Issuers"},{"location":"reference/services/trust-registry-service/#unregister-verifiers","text":"<p>To unregister a verifier, include the credential type, the did, and the ecosystem governance framework. The credential type will be unregistered from that verifier.</p> Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry unregister-verifier \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>using System;\nusing System.Diagnostics.CodeAnalysis;\nusing System.IO;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing FluentAssertions;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing Trinsic;\nusing Trinsic.Sdk.Options.V1;\nusing Trinsic.Services.Common.V1;\nusing Trinsic.Services.Provider.V1;\nusing Trinsic.Services.TrustRegistry.V1;\nusing Trinsic.Services.VerifiableCredentials.Templates.V1;\nusing Xunit;\nusing Xunit.Abstractions;\nusing JsonSerializer = System.Text.Json.JsonSerializer;\n\n#pragma warning disable CS0618\n\nnamespace Tests;\n\n[SuppressMessage(\"ReSharper\", \"MethodHasAsyncOverload\")]\npublic class Tests\n{\n#if DEBUG\n    private const string DefaultEndpoint = \"localhost\";\n    private const int DefaultPort = 5000;\n    private const bool DefaultUseTls = false;\n#else\n    private const string DefaultEndpoint = \"staging-internal.trinsic.cloud\";\n    private const int DefaultPort = 443;\n    private const bool DefaultUseTls = true;\n#endif\n\n    private readonly ITestOutputHelper _testOutputHelper;\n    private readonly ServiceOptions _options;\n\n    public Tests(ITestOutputHelper testOutputHelper) {\n        _testOutputHelper = testOutputHelper;\n\n        _options = new() {\n            ServerEndpoint = Environment.GetEnvironmentVariable(\"TEST_SERVER_ENDPOINT\") ?? DefaultEndpoint,\n            ServerPort = int.TryParse(Environment.GetEnvironmentVariable(\"TEST_SERVER_PORT\"), out var port) ? port : DefaultPort,\n            ServerUseTls = bool.TryParse(Environment.GetEnvironmentVariable(\"TEST_SERVER_USE_TLS\"), out var tls) ? tls : DefaultUseTls\n        };\n\n        _testOutputHelper.WriteLine($\"Testing endpoint: {_options.FormatUrl()}\");\n    }\n\n    private const string VaccinationCertificateUnsigned = \"TestData/vaccination-certificate-unsigned.jsonld\";\n    private const string VaccinationCertificateFrame = \"TestData/vaccination-certificate-frame.jsonld\";\n\n    [Fact(DisplayName = \"Demo: wallet and credential sample\")]\n    public async Task TestWalletService() {\n        // createAccountService() {\n        var providerService = new ProviderService(_options.Clone());\n        var accountService = new AccountService(_options.Clone());\n        var (ecosystem, _) = providerService.CreateEcosystem(new());\n        var ecosystemId = ecosystem.Id;\n        // }\n\n        // SETUP ACTORS\n        // Create 3 different profiles for each participant in the scenario\n        // setupActors() {\n        var allison = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\n        var clinic = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\n        var airline = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\n        // }\n\n        accountService.Options.AuthToken = clinic;\n        var info = await accountService.GetInfoAsync();\n        info.Should().NotBeNull();\n\n        // createService() {\n        var walletService = new WalletService(_options.CloneWithAuthToken(allison));\n        var credentialsService = new CredentialService(_options.CloneWithAuthToken(clinic));\n        // }\n\n        // ISSUE CREDENTIAL\n        // Sign a credential as the clinic and send it to Allison\n        // issueCredential() {\n        // Set active profile to 'clinic' so we can issue credential signed\n        // with the clinic's signing keys\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = clinic;\n\n        // Read the JSON credential data\n        var credentialJson = await File.ReadAllTextAsync(VaccinationCertificateUnsigned);\n        // Sign the credential using BBS+ signature scheme\n        // issueCredentialSample() {\n        var credential = await credentialsService.IssueCredentialAsync(new() {DocumentJson = credentialJson});\n        _testOutputHelper.WriteLine($\"Credential:\\n{credential.SignedDocumentJson}\");\n        // }\n        // }\n\n        // storeAndRecallProfile {\n        // Serialize auth token by exporting it to file\n        File.WriteAllText(\"allison.txt\", allison);\n        // Create auth token from existing data\n        allison = File.ReadAllText(\"allison.txt\");\n        // }\n\n        try {\n            // sendCredential() {\n            await credentialsService.SendAsync(new() {Email = \"example@trinsic.id\"});\n            // }\n        } catch { } // We expect this to fail\n\n        // STORE CREDENTIAL\n        // Allison stores the credential in her cloud wallet.\n\n        // storeCredential() {\n        // Set active profile to 'allison' so we can manage her cloud wallet\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = allison;\n\n        var insertItemResponse = await walletService.InsertItemAsync(new() {ItemJson = credential.SignedDocumentJson});\n        var itemId = insertItemResponse.ItemId;\n        // }\n        // searchWalletBasic() {\n        var walletItems = await walletService.SearchAsync(new());\n        // }\n        _testOutputHelper.WriteLine($\"Last wallet item:\\n{walletItems.Items.Last()}\");\n\n        // searchWalletSQL() { \n        var walletItems2 = await walletService.SearchAsync(new() {Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"});\n        // }\n\n        // SHARE CREDENTIAL\n        // Allison shares the credential with the venue.\n        // The venue has communicated with Allison the details of the credential\n        // that they require expressed as a JSON-LD frame.\n        // shareCredential() {\n        // We'll read the request frame from a file and communicate this with Allison\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = allison;\n\n        var proofRequestJson = await File.ReadAllTextAsync(VaccinationCertificateFrame);\n\n        // Build a proof for the given request and the `itemId` we previously received\n        // which points to the stored credential\n        var credentialProof = await credentialsService.CreateProofAsync(new() {\n            ItemId = itemId,\n            RevealDocumentJson = proofRequestJson\n        });\n        _testOutputHelper.WriteLine(\"Proof:\");\n        _testOutputHelper.WriteLine(credentialProof.ProofDocumentJson);\n        // }\n\n\n        // VERIFY CREDENTIAL\n        // verifyCredential() {\n        // The airline verifies the credential\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = airline;\n\n        // Check for valid signature\n        var valid = await credentialsService.VerifyProofAsync(new() {\n            ProofDocumentJson = credentialProof.ProofDocumentJson\n        });\n        _testOutputHelper.WriteLine($\"Verification result: {valid.IsValid}\");\n        Assert.True(valid.IsValid);\n        // }\n    }\n\n    [Fact(DisplayName = \"Demo: trust registries\")]\n    public async Task TestTrustRegistry() {\n        var governanceUri = $\"https://example.com/{Guid.NewGuid():N}\";\n\n        // setup\n        var providerService = new ProviderService(_options.Clone());\n        var (_, authToken) = await providerService.CreateEcosystemAsync(new());\n        var service = new TrustRegistryService(_options.CloneWithAuthToken(authToken));\n\n        // registerGovernanceFramework() {\n        var schemaUri = \"https://schema.org/Card\";\n        var frameworkUri = \"https://example.com\";\n        var registerFrameworkResponse = await service.AddFrameworkAsync(new() {\n            Name = $\"Demo framework-{Guid.NewGuid()}\",\n            GovernanceFrameworkUri = frameworkUri,\n            Description = schemaUri\n        });\n        // }\n\n\n        // registerIssuerSample() {\n        var didUri = \"did:example:test\";\n        var registerMemberResponse = await service.RegisterMemberAsync(new() {\n            DidUri = didUri,\n            FrameworkId = registerFrameworkResponse.Id,\n            SchemaUri = schemaUri\n        });\n        // }\n\n        // checkIssuerStatus() {\n        var issuerStatus = await service.GetMembershipStatusAsync(new() {\n            DidUri = didUri,\n            GovernanceFrameworkUri = frameworkUri,\n            SchemaUri = schemaUri\n        });\n        // }\n        issuerStatus.Should().NotBeNull();\n        issuerStatus.Status.Should().Be(RegistrationStatus.Current);\n\n        // searchTrustRegistry() {\n        var searchResult = await service.SearchRegistryAsync(new());\n        // }\n\n        searchResult.Should().NotBeNull();\n        searchResult.ItemsJson.Should().NotBeNull().And.NotBeEmpty();\n\n        // unregisterIssuer() {\n        await service.UnregisterMemberAsync(new() {\n            DidUri = didUri,\n            FrameworkId = registerFrameworkResponse.Id,\n            SchemaUri = schemaUri\n        });\n        // }\n    }\n\n    [Fact(DisplayName = \"Demo: ecosystem creation and listing\")]\n    public async Task EcosystemTests() {\n        // setup\n        var accountService = new AccountService(_options);\n        var account = await accountService.SignInAsync(new());\n        var service = new ProviderService(_options.CloneWithAuthToken(account));\n\n        // test create ecosystem\n        // createEcosystem() {\n        var (actualCreate, _) = await service.CreateEcosystemAsync(new() {\n            Description = \"My ecosystem\",\n            Uri = \"https://example.com\"\n        });\n        // }\n\n        actualCreate.Should().NotBeNull();\n        actualCreate.Id.Should().NotBeNull();\n        actualCreate.Id.Should().StartWith(\"urn:trinsic:ecosystems:\");\n\n        try {\n            // inviteParticipant() {\n            var inviteResponse = await service.InviteParticipantAsync(new() {\n                Participant = ParticipantType.Individual,\n                Description = \"Doc sample\",\n                Details = new() {\n                    Email = \"example@trinsic.id\"\n                }\n            });\n            // }\n        } catch(Exception) { } // This is expected as a doc sample\n\n        var invitationId = \"N/A\";\n        try {\n            // invitationStatus() {\n            var inviteStatus = await service.InvitationStatusAsync(new() {InvitationId = invitationId});\n            // }\n        } catch(Exception) { } // This is expected as a doc sample\n    }\n\n    [Fact]\n    public async Task TestProtectUnprotectProfile() {\n        // testSignInAndGetInfo() {\n        // accountServiceConstructor() {\n        var myAccountService = new AccountService(_options);\n        // }\n        // accountServiceSignIn() {\n        var myProfile = await myAccountService.SignInAsync(new());\n        // }\n        myAccountService.Options.AuthToken = myProfile;\n        // accountServiceGetInfo() {\n        var output = await myAccountService.GetInfoAsync();\n        // }\n        Assert.NotNull(output);\n        // }\n\n        // protectUnprotectProfile() {\n        var securityCode = \"1234\";\n        var myProtectedProfile = AccountService.Protect(myProfile, securityCode);\n        var myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n        // }\n        myAccountService.Options.AuthToken = myProtectedProfile;\n        await Assert.ThrowsAsync&lt;Exception&gt;(myAccountService.GetInfoAsync);\n        myAccountService.Options.AuthToken = myUnprotectedProfile;\n        Assert.NotNull(await myAccountService.GetInfoAsync());\n        Assert.NotNull(myAccountService.GetInfo());\n    }\n\n    [Fact]\n    public async Task TestInvitationIdSet() {\n        var providerService = new ProviderService(_options.Clone());\n        _ = await providerService.CreateEcosystemAsync(new());\n\n        var invitationResponse = await providerService.InviteParticipantAsync(new());\n\n        invitationResponse.Should().NotBeNull();\n        invitationResponse.InvitationCode.Should().NotBeEmpty();\n\n        await Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; await providerService.InvitationStatusAsync(new()));\n    }\n\n    [Fact(Skip = \"Ecosystem support not complete yet\")]\n    public async Task TestInviteParticipant() {\n        var myAccountService = new AccountService(_options);\n        var myProfile = await myAccountService.SignInAsync(new());\n        var myProviderService = new ProviderService(_options.CloneWithAuthToken(myProfile));\n        var invite = new InviteRequest {Description = \"Test invitation\"};\n        var response = await myProviderService.InviteParticipantAsync(invite);\n        Assert.NotNull(response);\n\n        var statusResponse = await myProviderService.InvitationStatusAsync(new() {InvitationId = response.InvitationId});\n        Assert.NotNull(statusResponse);\n    }\n\n    [Fact]\n    public async Task TestGovernanceFrameworkUriParse() {\n        var myAccountService = new AccountService(_options);\n        var myProfile = await myAccountService.SignInAsync(new());\n        var myTrustRegistryService = new TrustRegistryService(_options.CloneWithAuthToken(myProfile));\n        await Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; await myTrustRegistryService.AddFrameworkAsync(new() {\n            Description = \"invalid uri\",\n            GovernanceFrameworkUri = \"\"\n        }));\n    }\n\n    [Fact(DisplayName = \"Demo: template management and credential issuance from template\")]\n    public async Task DemoTemplatesWithIssuance() {\n        var providerService = new ProviderService(_options.Clone());\n        var (_, authToken) = await providerService.CreateEcosystemAsync(new());\n        var options = _options.CloneWithAuthToken(authToken);\n\n        var templateService = new TemplateService(options);\n        var credentialService = new CredentialService(options);\n        var walletService = new WalletService(options);\n\n        // create example template\n        // createTemplate() {\n        CreateCredentialTemplateRequest templateRequest = new() {\n            Name = \"An Example Credential\",\n            AllowAdditionalFields = false\n        };\n        templateRequest.Fields.Add(\"firstName\", new() {Description = \"Given name\"});\n        templateRequest.Fields.Add(\"lastName\", new());\n        templateRequest.Fields.Add(\"age\", new() {Optional = true}); // TODO - use FieldType.NUMBER once schema validation is fixed.\n\n        var template = await templateService.CreateAsync(templateRequest);\n        // }\n\n        template.Should().NotBeNull();\n        template.Data.Should().NotBeNull();\n        template.Data.Id.Should().NotBeNull();\n        template.Data.SchemaUri.Should().NotBeNull();\n\n        // issue credential from this template\n        var values = JsonSerializer.Serialize(new {\n            firstName = \"Jane\",\n            lastName = \"Doe\",\n            age = \"42\"\n        });\n\n        // issueFromTemplate() {\n        var credentialJson = await credentialService.IssueFromTemplateAsync(new() {\n            TemplateId = template.Data.Id,\n            ValuesJson = values\n        });\n        // }\n\n        credentialJson.Should().NotBeNull();\n\n        var jsonDocument = JsonDocument.Parse(credentialJson.DocumentJson).RootElement.EnumerateObject();\n\n        jsonDocument.Should().Contain(x =&gt; x.Name == \"id\");\n        jsonDocument.Should().Contain(x =&gt; x.Name == \"credentialSubject\");\n\n        // insertItemWallet() {\n        var insertItemResponse = await walletService.InsertItemAsync(new() {ItemJson = credentialJson.DocumentJson});\n        // }\n        var itemId = insertItemResponse.ItemId;\n\n        var frame = new JObject {\n            {\"@context\", \"https://www.w3.org/2018/credentials/v1\"},\n            {\"type\", new JArray(\"VerifiableCredential\")}\n        };\n\n        // Create proof from input document\n        // createProof() {\n        var proof = await credentialService.CreateProofAsync(new() {\n            DocumentJson = credentialJson.DocumentJson,\n            RevealDocumentJson = frame.ToString(Formatting.None)\n        });\n        // }\n        // verifyProof() {\n        var valid = await credentialService.VerifyProofAsync(new() {ProofDocumentJson = proof.ProofDocumentJson});\n        // }\n        valid.IsValid.Should().BeTrue();\n\n        // Create proof from item id\n        var proof2 = await credentialService.CreateProofAsync(new() {\n            ItemId = itemId,\n            RevealDocumentJson = frame.ToString(Formatting.None)\n        });\n\n        var valid2 = await credentialService.VerifyProofAsync(new() {ProofDocumentJson = proof2.ProofDocumentJson});\n\n        valid2.IsValid.Should().BeTrue();\n\n        try {\n            // checkCredentialStatus() {\n            var checkResponse = await credentialService.CheckStatusAsync(new() {CredentialStatusId = \"\"});\n            // }\n        } catch { } // We expect this to fail\n\n        try {\n            // updateCredentialStatus() {\n            await credentialService.UpdateStatusAsync(new() {CredentialStatusId = \"\", Revoked = true});\n            // }\n        } catch { } // We expect this to fail\n\n        // getCredentialTemplate() {\n        var getTemplateResponse = await templateService.GetAsync(new() {Id = template.Data.Id});\n        // }\n        // searchCredentialTemplate() {\n        var searchTemplateResponse = await templateService.SearchAsync(new() {Query = \"SELECT * FROM c\"});\n        // }\n        // deleteCredentialTemplate() {\n        var deleteTemplateResponse = await templateService.DeleteAsync(new() {Id = template.Data.Id});\n        // }\n    }\n\n    [Fact(DisplayName = \"Decode base64 url encoded string\")]\n    public void DecodeBase64UrlString() {\n        const string encoded =\n            \"CiVodHRwczovL3RyaW5zaWMuaWQvc2VjdXJpdHkvdjEvb2Jlcm9uEnIKKnVybjp0cmluc2ljOndhbGxldHM6Vzl1dG9pVmhDZHp2RXJZRGVyOGlrRxIkODBkMTVlYTYtMTIxOS00MGZmLWE4NTQtZGI1NmZhOTlmNjMwIh51cm46dHJpbnNpYzplY29zeXN0ZW1zOmRlZmF1bHQaMJRXhevRbornRpA-HJ86WaTLGmQlOuoXSnDT_W2O3u3bV5rS5nKpgrfGKFEbRtIgjyIA\";\n\n        var actual = Base64Url.Decode(encoded);\n\n        actual.Should().NotBeEmpty();\n    }\n}\n</code></pre>   <pre><code>import asyncio\nimport uuid\n\nfrom trinsic.account_service import AccountService\nfrom trinsic.proto.services.trustregistry.v1 import (\n    RegistrationStatus,\n    AddFrameworkRequest,\n    UnregisterMemberRequest,\n    GetMembershipStatusRequest,\n    RegisterMemberRequest,\n)\nfrom trinsic.trinsic_util import trinsic_config\nfrom trinsic.trustregistry_service import TrustRegistryService\n\n\nasync def trustregistry_demo():\n    # setup\n    account_service = AccountService(server_config=trinsic_config())\n    account = await account_service.sign_in()\n    service = TrustRegistryService(server_config=trinsic_config(account))\n\n    # data\n    https_schema_org = \"https://schema.org/Card\"\n    https_example_com = f\"https://example.com/{uuid.uuid4()}\"\n    did_example_test = \"did:example:test\"\n    framework_name = f\"Example Framework: {uuid.uuid4()}\"\n\n    # registerGovernanceFramework() {\n    register_framework_response = await service.add_framework(\n        request=AddFrameworkRequest(\n            governance_framework_uri=https_example_com,\n            description=\"Demo framework\",\n            name=framework_name,\n        )\n    )\n    # }\n\n    # registerIssuerSample() {\n    await service.register_member(\n        request=RegisterMemberRequest(\n            did_uri=did_example_test,\n            framework_id=register_framework_response.id,\n            schema_uri=https_schema_org,\n        )\n    )\n    # }\n\n    # checkIssuerStatus() {\n    check_response = await service.get_membership_status(\n        request=GetMembershipStatusRequest(\n            did_uri=did_example_test,\n            governance_framework_uri=https_example_com,\n            schema_uri=https_schema_org,\n        )\n    )\n    # }\n    issuer_status = check_response.status\n    assert issuer_status == RegistrationStatus.CURRENT\n\n    # searchTrustRegistry() {\n    search_result = await service.search_registry()\n    # }\n    assert search_result is not None\n    assert search_result.items_json is not None\n    assert len(search_result.items_json) &gt; 0\n\n    # unregisterIssuer() {\n    unregister_issuer_response = await service.unregister_member(\n        request=UnregisterMemberRequest(\n            framework_id=register_framework_response.id,\n            schema_uri=https_schema_org,\n            did_uri=did_example_test,\n        )\n    )\n    # }\n\n\nif __name__ == \"__main__\":\n    asyncio.run(trustregistry_demo())\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>package trinsic;\n\nimport org.junit.jupiter.api.Assertions;\nimport trinsic.okapi.DidException;\nimport trinsic.services.AccountService;\nimport trinsic.services.TrustRegistryService;\nimport trinsic.services.trustregistry.v1.TrustRegistryOuterClass;\n\nimport java.io.IOException;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutionException;\n\npublic class TrustRegistryDemo {\n    public static void main(String[] args) throws IOException, DidException, ExecutionException, InterruptedException {\n        run();\n    }\n\n    public static void run() throws IOException, DidException, ExecutionException, InterruptedException {\n        var accountService = new AccountService(TrinsicUtilities.getTrinsicServiceOptions());\n        var account = accountService.signIn().get();\n        var service = new TrustRegistryService(TrinsicUtilities.getTrinsicServiceOptions(account));\n\n        final String didUri = \"did:example:test\";\n        final String frameworkUri = \"https://example.com/\" + UUID.randomUUID();\n        final String typeUri = \"https://schema.org/Card\";\n\n        // addFramework() {\n        var frameworkResponse = service.addFramework(TrustRegistryOuterClass.AddFrameworkRequest.newBuilder().setGovernanceFrameworkUri(frameworkUri).setName(\"Example Framework\" + UUID.randomUUID()).build()).get();\n        // }\n\n        // registerIssuerSample() {\n        service.registerMember(TrustRegistryOuterClass.RegisterMemberRequest.newBuilder().setDidUri(didUri).setFrameworkId(frameworkResponse.getId()).setSchemaUri(typeUri).build());\n        // }\n        // checkIssuerStatus() {\n        var issuerStatus = service.checkIssuerStatus(TrustRegistryOuterClass.GetMembershipStatusRequest.newBuilder().setDidUri(didUri).setGovernanceFrameworkUri(frameworkUri).setSchemaUri(typeUri).build()).get();\n        // }\n        Assertions.assertEquals(TrustRegistryOuterClass.RegistrationStatus.CURRENT, issuerStatus.getStatus());\n\n        // searchTrustRegistry() {\n        var searchResult = service.searchRegistry().get();\n        // }\n        Assertions.assertNotNull(searchResult);\n        Assertions.assertNotNull(searchResult.getItemsJson());\n        Assertions.assertTrue(searchResult.getItemsJson().length() &gt; 0);\n\n        // unregisterIssuer() {\n        service.unregisterIssuer(TrustRegistryOuterClass.UnregisterMemberRequest.newBuilder().setFrameworkId(frameworkResponse.getId()).setDidUri(didUri).setSchemaUri(typeUri).build());\n        // }\n    }\n}\n</code></pre>","title":"Unregister Verifiers"},{"location":"reference/services/trust-registry-service/#check-issuer-status","text":"<p>Check the status of an issuer for a credential type within a given governance framework. Returns all historical data for the given input parameter.</p> Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry check-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>var issuerStatus = await service.GetMembershipStatusAsync(new() {\n    DidUri = didUri,\n    GovernanceFrameworkUri = frameworkUri,\n    SchemaUri = schemaUri\n});\n</code></pre>   <pre><code>check_response = await service.get_membership_status(\n    request=GetMembershipStatusRequest(\n        did_uri=did_example_test,\n        governance_framework_uri=https_example_com,\n        schema_uri=https_schema_org,\n    )\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var issuerStatus = service.checkIssuerStatus(TrustRegistryOuterClass.GetMembershipStatusRequest.newBuilder().setDidUri(didUri).setGovernanceFrameworkUri(frameworkUri).setSchemaUri(typeUri).build()).get();\n</code></pre>","title":"Check Issuer Status"},{"location":"reference/services/trust-registry-service/#check-verifier-status","text":"<p>Check the status of an issuer for a credential type within a given governance framework. Returns all historical data for the given input parameter.</p> Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry check-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>   <pre><code>using System;\nusing System.Diagnostics.CodeAnalysis;\nusing System.IO;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing FluentAssertions;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing Trinsic;\nusing Trinsic.Sdk.Options.V1;\nusing Trinsic.Services.Common.V1;\nusing Trinsic.Services.Provider.V1;\nusing Trinsic.Services.TrustRegistry.V1;\nusing Trinsic.Services.VerifiableCredentials.Templates.V1;\nusing Xunit;\nusing Xunit.Abstractions;\nusing JsonSerializer = System.Text.Json.JsonSerializer;\n\n#pragma warning disable CS0618\n\nnamespace Tests;\n\n[SuppressMessage(\"ReSharper\", \"MethodHasAsyncOverload\")]\npublic class Tests\n{\n#if DEBUG\n    private const string DefaultEndpoint = \"localhost\";\n    private const int DefaultPort = 5000;\n    private const bool DefaultUseTls = false;\n#else\n    private const string DefaultEndpoint = \"staging-internal.trinsic.cloud\";\n    private const int DefaultPort = 443;\n    private const bool DefaultUseTls = true;\n#endif\n\n    private readonly ITestOutputHelper _testOutputHelper;\n    private readonly ServiceOptions _options;\n\n    public Tests(ITestOutputHelper testOutputHelper) {\n        _testOutputHelper = testOutputHelper;\n\n        _options = new() {\n            ServerEndpoint = Environment.GetEnvironmentVariable(\"TEST_SERVER_ENDPOINT\") ?? DefaultEndpoint,\n            ServerPort = int.TryParse(Environment.GetEnvironmentVariable(\"TEST_SERVER_PORT\"), out var port) ? port : DefaultPort,\n            ServerUseTls = bool.TryParse(Environment.GetEnvironmentVariable(\"TEST_SERVER_USE_TLS\"), out var tls) ? tls : DefaultUseTls\n        };\n\n        _testOutputHelper.WriteLine($\"Testing endpoint: {_options.FormatUrl()}\");\n    }\n\n    private const string VaccinationCertificateUnsigned = \"TestData/vaccination-certificate-unsigned.jsonld\";\n    private const string VaccinationCertificateFrame = \"TestData/vaccination-certificate-frame.jsonld\";\n\n    [Fact(DisplayName = \"Demo: wallet and credential sample\")]\n    public async Task TestWalletService() {\n        // createAccountService() {\n        var providerService = new ProviderService(_options.Clone());\n        var accountService = new AccountService(_options.Clone());\n        var (ecosystem, _) = providerService.CreateEcosystem(new());\n        var ecosystemId = ecosystem.Id;\n        // }\n\n        // SETUP ACTORS\n        // Create 3 different profiles for each participant in the scenario\n        // setupActors() {\n        var allison = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\n        var clinic = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\n        var airline = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\n        // }\n\n        accountService.Options.AuthToken = clinic;\n        var info = await accountService.GetInfoAsync();\n        info.Should().NotBeNull();\n\n        // createService() {\n        var walletService = new WalletService(_options.CloneWithAuthToken(allison));\n        var credentialsService = new CredentialService(_options.CloneWithAuthToken(clinic));\n        // }\n\n        // ISSUE CREDENTIAL\n        // Sign a credential as the clinic and send it to Allison\n        // issueCredential() {\n        // Set active profile to 'clinic' so we can issue credential signed\n        // with the clinic's signing keys\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = clinic;\n\n        // Read the JSON credential data\n        var credentialJson = await File.ReadAllTextAsync(VaccinationCertificateUnsigned);\n        // Sign the credential using BBS+ signature scheme\n        // issueCredentialSample() {\n        var credential = await credentialsService.IssueCredentialAsync(new() {DocumentJson = credentialJson});\n        _testOutputHelper.WriteLine($\"Credential:\\n{credential.SignedDocumentJson}\");\n        // }\n        // }\n\n        // storeAndRecallProfile {\n        // Serialize auth token by exporting it to file\n        File.WriteAllText(\"allison.txt\", allison);\n        // Create auth token from existing data\n        allison = File.ReadAllText(\"allison.txt\");\n        // }\n\n        try {\n            // sendCredential() {\n            await credentialsService.SendAsync(new() {Email = \"example@trinsic.id\"});\n            // }\n        } catch { } // We expect this to fail\n\n        // STORE CREDENTIAL\n        // Allison stores the credential in her cloud wallet.\n\n        // storeCredential() {\n        // Set active profile to 'allison' so we can manage her cloud wallet\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = allison;\n\n        var insertItemResponse = await walletService.InsertItemAsync(new() {ItemJson = credential.SignedDocumentJson});\n        var itemId = insertItemResponse.ItemId;\n        // }\n        // searchWalletBasic() {\n        var walletItems = await walletService.SearchAsync(new());\n        // }\n        _testOutputHelper.WriteLine($\"Last wallet item:\\n{walletItems.Items.Last()}\");\n\n        // searchWalletSQL() { \n        var walletItems2 = await walletService.SearchAsync(new() {Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"});\n        // }\n\n        // SHARE CREDENTIAL\n        // Allison shares the credential with the venue.\n        // The venue has communicated with Allison the details of the credential\n        // that they require expressed as a JSON-LD frame.\n        // shareCredential() {\n        // We'll read the request frame from a file and communicate this with Allison\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = allison;\n\n        var proofRequestJson = await File.ReadAllTextAsync(VaccinationCertificateFrame);\n\n        // Build a proof for the given request and the `itemId` we previously received\n        // which points to the stored credential\n        var credentialProof = await credentialsService.CreateProofAsync(new() {\n            ItemId = itemId,\n            RevealDocumentJson = proofRequestJson\n        });\n        _testOutputHelper.WriteLine(\"Proof:\");\n        _testOutputHelper.WriteLine(credentialProof.ProofDocumentJson);\n        // }\n\n\n        // VERIFY CREDENTIAL\n        // verifyCredential() {\n        // The airline verifies the credential\n        walletService.Options.AuthToken = credentialsService.Options.AuthToken = airline;\n\n        // Check for valid signature\n        var valid = await credentialsService.VerifyProofAsync(new() {\n            ProofDocumentJson = credentialProof.ProofDocumentJson\n        });\n        _testOutputHelper.WriteLine($\"Verification result: {valid.IsValid}\");\n        Assert.True(valid.IsValid);\n        // }\n    }\n\n    [Fact(DisplayName = \"Demo: trust registries\")]\n    public async Task TestTrustRegistry() {\n        var governanceUri = $\"https://example.com/{Guid.NewGuid():N}\";\n\n        // setup\n        var providerService = new ProviderService(_options.Clone());\n        var (_, authToken) = await providerService.CreateEcosystemAsync(new());\n        var service = new TrustRegistryService(_options.CloneWithAuthToken(authToken));\n\n        // registerGovernanceFramework() {\n        var schemaUri = \"https://schema.org/Card\";\n        var frameworkUri = \"https://example.com\";\n        var registerFrameworkResponse = await service.AddFrameworkAsync(new() {\n            Name = $\"Demo framework-{Guid.NewGuid()}\",\n            GovernanceFrameworkUri = frameworkUri,\n            Description = schemaUri\n        });\n        // }\n\n\n        // registerIssuerSample() {\n        var didUri = \"did:example:test\";\n        var registerMemberResponse = await service.RegisterMemberAsync(new() {\n            DidUri = didUri,\n            FrameworkId = registerFrameworkResponse.Id,\n            SchemaUri = schemaUri\n        });\n        // }\n\n        // checkIssuerStatus() {\n        var issuerStatus = await service.GetMembershipStatusAsync(new() {\n            DidUri = didUri,\n            GovernanceFrameworkUri = frameworkUri,\n            SchemaUri = schemaUri\n        });\n        // }\n        issuerStatus.Should().NotBeNull();\n        issuerStatus.Status.Should().Be(RegistrationStatus.Current);\n\n        // searchTrustRegistry() {\n        var searchResult = await service.SearchRegistryAsync(new());\n        // }\n\n        searchResult.Should().NotBeNull();\n        searchResult.ItemsJson.Should().NotBeNull().And.NotBeEmpty();\n\n        // unregisterIssuer() {\n        await service.UnregisterMemberAsync(new() {\n            DidUri = didUri,\n            FrameworkId = registerFrameworkResponse.Id,\n            SchemaUri = schemaUri\n        });\n        // }\n    }\n\n    [Fact(DisplayName = \"Demo: ecosystem creation and listing\")]\n    public async Task EcosystemTests() {\n        // setup\n        var accountService = new AccountService(_options);\n        var account = await accountService.SignInAsync(new());\n        var service = new ProviderService(_options.CloneWithAuthToken(account));\n\n        // test create ecosystem\n        // createEcosystem() {\n        var (actualCreate, _) = await service.CreateEcosystemAsync(new() {\n            Description = \"My ecosystem\",\n            Uri = \"https://example.com\"\n        });\n        // }\n\n        actualCreate.Should().NotBeNull();\n        actualCreate.Id.Should().NotBeNull();\n        actualCreate.Id.Should().StartWith(\"urn:trinsic:ecosystems:\");\n\n        try {\n            // inviteParticipant() {\n            var inviteResponse = await service.InviteParticipantAsync(new() {\n                Participant = ParticipantType.Individual,\n                Description = \"Doc sample\",\n                Details = new() {\n                    Email = \"example@trinsic.id\"\n                }\n            });\n            // }\n        } catch(Exception) { } // This is expected as a doc sample\n\n        var invitationId = \"N/A\";\n        try {\n            // invitationStatus() {\n            var inviteStatus = await service.InvitationStatusAsync(new() {InvitationId = invitationId});\n            // }\n        } catch(Exception) { } // This is expected as a doc sample\n    }\n\n    [Fact]\n    public async Task TestProtectUnprotectProfile() {\n        // testSignInAndGetInfo() {\n        // accountServiceConstructor() {\n        var myAccountService = new AccountService(_options);\n        // }\n        // accountServiceSignIn() {\n        var myProfile = await myAccountService.SignInAsync(new());\n        // }\n        myAccountService.Options.AuthToken = myProfile;\n        // accountServiceGetInfo() {\n        var output = await myAccountService.GetInfoAsync();\n        // }\n        Assert.NotNull(output);\n        // }\n\n        // protectUnprotectProfile() {\n        var securityCode = \"1234\";\n        var myProtectedProfile = AccountService.Protect(myProfile, securityCode);\n        var myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n        // }\n        myAccountService.Options.AuthToken = myProtectedProfile;\n        await Assert.ThrowsAsync&lt;Exception&gt;(myAccountService.GetInfoAsync);\n        myAccountService.Options.AuthToken = myUnprotectedProfile;\n        Assert.NotNull(await myAccountService.GetInfoAsync());\n        Assert.NotNull(myAccountService.GetInfo());\n    }\n\n    [Fact]\n    public async Task TestInvitationIdSet() {\n        var providerService = new ProviderService(_options.Clone());\n        _ = await providerService.CreateEcosystemAsync(new());\n\n        var invitationResponse = await providerService.InviteParticipantAsync(new());\n\n        invitationResponse.Should().NotBeNull();\n        invitationResponse.InvitationCode.Should().NotBeEmpty();\n\n        await Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; await providerService.InvitationStatusAsync(new()));\n    }\n\n    [Fact(Skip = \"Ecosystem support not complete yet\")]\n    public async Task TestInviteParticipant() {\n        var myAccountService = new AccountService(_options);\n        var myProfile = await myAccountService.SignInAsync(new());\n        var myProviderService = new ProviderService(_options.CloneWithAuthToken(myProfile));\n        var invite = new InviteRequest {Description = \"Test invitation\"};\n        var response = await myProviderService.InviteParticipantAsync(invite);\n        Assert.NotNull(response);\n\n        var statusResponse = await myProviderService.InvitationStatusAsync(new() {InvitationId = response.InvitationId});\n        Assert.NotNull(statusResponse);\n    }\n\n    [Fact]\n    public async Task TestGovernanceFrameworkUriParse() {\n        var myAccountService = new AccountService(_options);\n        var myProfile = await myAccountService.SignInAsync(new());\n        var myTrustRegistryService = new TrustRegistryService(_options.CloneWithAuthToken(myProfile));\n        await Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; await myTrustRegistryService.AddFrameworkAsync(new() {\n            Description = \"invalid uri\",\n            GovernanceFrameworkUri = \"\"\n        }));\n    }\n\n    [Fact(DisplayName = \"Demo: template management and credential issuance from template\")]\n    public async Task DemoTemplatesWithIssuance() {\n        var providerService = new ProviderService(_options.Clone());\n        var (_, authToken) = await providerService.CreateEcosystemAsync(new());\n        var options = _options.CloneWithAuthToken(authToken);\n\n        var templateService = new TemplateService(options);\n        var credentialService = new CredentialService(options);\n        var walletService = new WalletService(options);\n\n        // create example template\n        // createTemplate() {\n        CreateCredentialTemplateRequest templateRequest = new() {\n            Name = \"An Example Credential\",\n            AllowAdditionalFields = false\n        };\n        templateRequest.Fields.Add(\"firstName\", new() {Description = \"Given name\"});\n        templateRequest.Fields.Add(\"lastName\", new());\n        templateRequest.Fields.Add(\"age\", new() {Optional = true}); // TODO - use FieldType.NUMBER once schema validation is fixed.\n\n        var template = await templateService.CreateAsync(templateRequest);\n        // }\n\n        template.Should().NotBeNull();\n        template.Data.Should().NotBeNull();\n        template.Data.Id.Should().NotBeNull();\n        template.Data.SchemaUri.Should().NotBeNull();\n\n        // issue credential from this template\n        var values = JsonSerializer.Serialize(new {\n            firstName = \"Jane\",\n            lastName = \"Doe\",\n            age = \"42\"\n        });\n\n        // issueFromTemplate() {\n        var credentialJson = await credentialService.IssueFromTemplateAsync(new() {\n            TemplateId = template.Data.Id,\n            ValuesJson = values\n        });\n        // }\n\n        credentialJson.Should().NotBeNull();\n\n        var jsonDocument = JsonDocument.Parse(credentialJson.DocumentJson).RootElement.EnumerateObject();\n\n        jsonDocument.Should().Contain(x =&gt; x.Name == \"id\");\n        jsonDocument.Should().Contain(x =&gt; x.Name == \"credentialSubject\");\n\n        // insertItemWallet() {\n        var insertItemResponse = await walletService.InsertItemAsync(new() {ItemJson = credentialJson.DocumentJson});\n        // }\n        var itemId = insertItemResponse.ItemId;\n\n        var frame = new JObject {\n            {\"@context\", \"https://www.w3.org/2018/credentials/v1\"},\n            {\"type\", new JArray(\"VerifiableCredential\")}\n        };\n\n        // Create proof from input document\n        // createProof() {\n        var proof = await credentialService.CreateProofAsync(new() {\n            DocumentJson = credentialJson.DocumentJson,\n            RevealDocumentJson = frame.ToString(Formatting.None)\n        });\n        // }\n        // verifyProof() {\n        var valid = await credentialService.VerifyProofAsync(new() {ProofDocumentJson = proof.ProofDocumentJson});\n        // }\n        valid.IsValid.Should().BeTrue();\n\n        // Create proof from item id\n        var proof2 = await credentialService.CreateProofAsync(new() {\n            ItemId = itemId,\n            RevealDocumentJson = frame.ToString(Formatting.None)\n        });\n\n        var valid2 = await credentialService.VerifyProofAsync(new() {ProofDocumentJson = proof2.ProofDocumentJson});\n\n        valid2.IsValid.Should().BeTrue();\n\n        try {\n            // checkCredentialStatus() {\n            var checkResponse = await credentialService.CheckStatusAsync(new() {CredentialStatusId = \"\"});\n            // }\n        } catch { } // We expect this to fail\n\n        try {\n            // updateCredentialStatus() {\n            await credentialService.UpdateStatusAsync(new() {CredentialStatusId = \"\", Revoked = true});\n            // }\n        } catch { } // We expect this to fail\n\n        // getCredentialTemplate() {\n        var getTemplateResponse = await templateService.GetAsync(new() {Id = template.Data.Id});\n        // }\n        // searchCredentialTemplate() {\n        var searchTemplateResponse = await templateService.SearchAsync(new() {Query = \"SELECT * FROM c\"});\n        // }\n        // deleteCredentialTemplate() {\n        var deleteTemplateResponse = await templateService.DeleteAsync(new() {Id = template.Data.Id});\n        // }\n    }\n\n    [Fact(DisplayName = \"Decode base64 url encoded string\")]\n    public void DecodeBase64UrlString() {\n        const string encoded =\n            \"CiVodHRwczovL3RyaW5zaWMuaWQvc2VjdXJpdHkvdjEvb2Jlcm9uEnIKKnVybjp0cmluc2ljOndhbGxldHM6Vzl1dG9pVmhDZHp2RXJZRGVyOGlrRxIkODBkMTVlYTYtMTIxOS00MGZmLWE4NTQtZGI1NmZhOTlmNjMwIh51cm46dHJpbnNpYzplY29zeXN0ZW1zOmRlZmF1bHQaMJRXhevRbornRpA-HJ86WaTLGmQlOuoXSnDT_W2O3u3bV5rS5nKpgrfGKFEbRtIgjyIA\";\n\n        var actual = Base64Url.Decode(encoded);\n\n        actual.Should().NotBeEmpty();\n    }\n}\n</code></pre>   <pre><code>import asyncio\nimport uuid\n\nfrom trinsic.account_service import AccountService\nfrom trinsic.proto.services.trustregistry.v1 import (\n    RegistrationStatus,\n    AddFrameworkRequest,\n    UnregisterMemberRequest,\n    GetMembershipStatusRequest,\n    RegisterMemberRequest,\n)\nfrom trinsic.trinsic_util import trinsic_config\nfrom trinsic.trustregistry_service import TrustRegistryService\n\n\nasync def trustregistry_demo():\n    # setup\n    account_service = AccountService(server_config=trinsic_config())\n    account = await account_service.sign_in()\n    service = TrustRegistryService(server_config=trinsic_config(account))\n\n    # data\n    https_schema_org = \"https://schema.org/Card\"\n    https_example_com = f\"https://example.com/{uuid.uuid4()}\"\n    did_example_test = \"did:example:test\"\n    framework_name = f\"Example Framework: {uuid.uuid4()}\"\n\n    # registerGovernanceFramework() {\n    register_framework_response = await service.add_framework(\n        request=AddFrameworkRequest(\n            governance_framework_uri=https_example_com,\n            description=\"Demo framework\",\n            name=framework_name,\n        )\n    )\n    # }\n\n    # registerIssuerSample() {\n    await service.register_member(\n        request=RegisterMemberRequest(\n            did_uri=did_example_test,\n            framework_id=register_framework_response.id,\n            schema_uri=https_schema_org,\n        )\n    )\n    # }\n\n    # checkIssuerStatus() {\n    check_response = await service.get_membership_status(\n        request=GetMembershipStatusRequest(\n            did_uri=did_example_test,\n            governance_framework_uri=https_example_com,\n            schema_uri=https_schema_org,\n        )\n    )\n    # }\n    issuer_status = check_response.status\n    assert issuer_status == RegistrationStatus.CURRENT\n\n    # searchTrustRegistry() {\n    search_result = await service.search_registry()\n    # }\n    assert search_result is not None\n    assert search_result.items_json is not None\n    assert len(search_result.items_json) &gt; 0\n\n    # unregisterIssuer() {\n    unregister_issuer_response = await service.unregister_member(\n        request=UnregisterMemberRequest(\n            framework_id=register_framework_response.id,\n            schema_uri=https_schema_org,\n            did_uri=did_example_test,\n        )\n    )\n    # }\n\n\nif __name__ == \"__main__\":\n    asyncio.run(trustregistry_demo())\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>package trinsic;\n\nimport org.junit.jupiter.api.Assertions;\nimport trinsic.okapi.DidException;\nimport trinsic.services.AccountService;\nimport trinsic.services.TrustRegistryService;\nimport trinsic.services.trustregistry.v1.TrustRegistryOuterClass;\n\nimport java.io.IOException;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutionException;\n\npublic class TrustRegistryDemo {\n    public static void main(String[] args) throws IOException, DidException, ExecutionException, InterruptedException {\n        run();\n    }\n\n    public static void run() throws IOException, DidException, ExecutionException, InterruptedException {\n        var accountService = new AccountService(TrinsicUtilities.getTrinsicServiceOptions());\n        var account = accountService.signIn().get();\n        var service = new TrustRegistryService(TrinsicUtilities.getTrinsicServiceOptions(account));\n\n        final String didUri = \"did:example:test\";\n        final String frameworkUri = \"https://example.com/\" + UUID.randomUUID();\n        final String typeUri = \"https://schema.org/Card\";\n\n        // addFramework() {\n        var frameworkResponse = service.addFramework(TrustRegistryOuterClass.AddFrameworkRequest.newBuilder().setGovernanceFrameworkUri(frameworkUri).setName(\"Example Framework\" + UUID.randomUUID()).build()).get();\n        // }\n\n        // registerIssuerSample() {\n        service.registerMember(TrustRegistryOuterClass.RegisterMemberRequest.newBuilder().setDidUri(didUri).setFrameworkId(frameworkResponse.getId()).setSchemaUri(typeUri).build());\n        // }\n        // checkIssuerStatus() {\n        var issuerStatus = service.checkIssuerStatus(TrustRegistryOuterClass.GetMembershipStatusRequest.newBuilder().setDidUri(didUri).setGovernanceFrameworkUri(frameworkUri).setSchemaUri(typeUri).build()).get();\n        // }\n        Assertions.assertEquals(TrustRegistryOuterClass.RegistrationStatus.CURRENT, issuerStatus.getStatus());\n\n        // searchTrustRegistry() {\n        var searchResult = service.searchRegistry().get();\n        // }\n        Assertions.assertNotNull(searchResult);\n        Assertions.assertNotNull(searchResult.getItemsJson());\n        Assertions.assertTrue(searchResult.getItemsJson().length() &gt; 0);\n\n        // unregisterIssuer() {\n        service.unregisterIssuer(TrustRegistryOuterClass.UnregisterMemberRequest.newBuilder().setFrameworkId(frameworkResponse.getId()).setDidUri(didUri).setSchemaUri(typeUri).build());\n        // }\n    }\n}\n</code></pre>","title":"Check Verifier Status"},{"location":"reference/services/trust-registry-service/#search","text":"<p>Search the registry for authoritative issuer and verifiers using a custom query in a SQL format.</p> Trinsic CLIC#PythonGoJava   <pre><code>trinsic trust-registry search --query &lt;SQL query&gt;\n</code></pre>   <pre><code>var searchResult = await service.SearchRegistryAsync(new());\n</code></pre>   <pre><code>search_result = await service.search_registry()\n</code></pre>   <pre><code>ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n</code></pre>   <pre><code>var searchResult = service.searchRegistry().get();\n</code></pre>","title":"Search"},{"location":"reference/services/trust-registry-service/#cache-offline-registry-file","text":"Trinsic CLI   <pre><code>trinsic trust-registry download \n</code></pre>","title":"Cache Offline Registry File"},{"location":"reference/services/wallet-service/","text":"<p>The wallet service is the main interface for interacting with a cloud wallet. The service endpoints are designed to closely match the recommendations of the Universal Wallet 2020  specification by W3C Community Credentials Group. The service exposes a gRPC interface and a set of data contracts as described in the specification. Our intention with this design is to bring it closer to interoperability as more implementations of this wallet appear in production.</p>  <p>Wallets vs Accounts</p> <p>Wallets and accounts are related and often interchangeable -- each account has an associated wallet, and operations on a wallet are performed using an account's access token.</p> <p>Every account has exactly one wallet. </p>","title":"Wallet Service"},{"location":"reference/services/wallet-service/#create-wallet","text":"<p>Wallets can be created directly by the user or through an invitation by the ecosystem provider. Depending on the ecosystem settings, direct wallet creation may not be enabled for your provider. The wallet is created automatically upon user signin. For more information on that, see the link below:</p> <ul> <li>Account Sign In</li> </ul>","title":"Create Wallet"},{"location":"reference/services/wallet-service/#insert-item","text":"<p>Trinsic supports the ability to insert verifiable credentials into a wallet simply using JSON data.</p> Trinsic CLI   <pre><code>trinsic wallet insert-item --item &lt;INPUT_JSON_FILE&gt;\n</code></pre>    <p>When using an SDK to perform this operation, you will need to supply an Insert Item Request object that follows the structure below:</p>  <p>InsertItemRequest   <p>Request to insert a JSON document into a wallet</p>    Field Type Description     item_json string Document to insert; must be stringified JSON   item_type string Item type (ex. \"VerifiableCredential\")    <p></p>   <p>Then you can supply it to the SDKs:</p> TypeScriptC#PythonGoJava   <pre><code>let insertItemResponse = await walletService.insertItem(\n  InsertItemRequest.fromPartial({\n    itemJson: issueResponse.signedDocumentJson,\n  })\n);\n</code></pre>   <pre><code>var insertItemResponse = await walletService.InsertItemAsync(new() {ItemJson = credentialJson.DocumentJson});\n</code></pre>   <pre><code>insert_response = await wallet_service.insert_item(\n    request=InsertItemRequest(\n        item_json=credential, item_type=\"VerifiableCredential\"\n    )\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var insertResponse = walletService.insertItem(\n        UniversalWalletOuterClass.InsertItemRequest\n                .newBuilder()\n                .setItemJson(credentialJson)\n                .setItemType(\"VerifiableCredential\")\n                .build()\n).get();\n</code></pre>    <p>The output of this method will be a unique <code>itemId</code> that can be used as input where required. The response model looks like this:</p>  <p>InsertItemResponse   <p>Response to <code>InsertItemRequest</code></p>    Field Type Description     item_id string ID of item inserted into wallet    <p></p>","title":"Insert Item"},{"location":"reference/services/wallet-service/#search-query","text":"<p>Querying wallet data in our SDK is enabled through the use of familiar SQL syntax. All data is stored in JSON-LD format, so it can be easily searched. This approach allows us to give developers full control over how data is retrieved. In addition to customizable sorting, paging and filtering, developers have the ability to construct projections, combine result sets, and even run user-defined functions over their queries.</p>  <p>This endpoint will support querying using Verifiable Presentation Request Spec . This feature is still in development.</p>","title":"Search / Query"},{"location":"reference/services/wallet-service/#basic-search","text":"<p>The default query used in the commands below returns the first 100 items in the wallet result set. The query is <code>SELECT * FROM c OFFSET 0 LIMIT 100</code>.</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic wallet search\n</code></pre>   <pre><code>let items = await walletService.search();\n</code></pre>   <pre><code>var walletItems = await walletService.SearchAsync(new());\n</code></pre>   <pre><code>wallet_items = await wallet_service.search()\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var walletItems = walletService.search().get();\n</code></pre>","title":"Basic Search"},{"location":"reference/services/wallet-service/#sql-search","text":"<p>To pass custom query to the search function, use the query parameter or the available overload.</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic wallet search \\\n    --query \"SELECT * FROM c WHERE c.type = 'VerifiableCredential'\"\n</code></pre>   <pre><code>let items2 = await walletService.search(\n  SearchRequest.fromPartial({\n    query:\n      \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\",\n  })\n);\n</code></pre>   <pre><code>var walletItems2 = await walletService.SearchAsync(new() {Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"});\n</code></pre>   <pre><code>wallet_items = await wallet_service.search(\n    request=SearchRequest(\n        query=\"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"\n    )\n)\n</code></pre>   <pre><code>package services\n\nimport (\n    \"context\"\n    \"fmt\"\n    account \"github.com/trinsic-id/sdk/go/proto/account/v1\"\n    options \"github.com/trinsic-id/sdk/go/proto/options/v1\"\n    provider \"github.com/trinsic-id/sdk/go/proto/provider/v1\"\n    trustregistry \"github.com/trinsic-id/sdk/go/proto/trustregistry/v1\"\n    \"path/filepath\"\n    \"runtime\"\n    \"testing\"\n\n    \"github.com/google/uuid\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// pathData() {\nfunc GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n\n// }\n\nfunc TestServiceOptions(t *testing.T) {\n    assert := assert.New(t)\n\n    opts, err := NewServiceOptions()\n    assert.Nil(err)\n\n    prodOpts := &amp;Options{ServiceOptions: &amp;options.ServiceOptions{}}\n    err = WithProductionEnv()(prodOpts)\n    assert.Nil(err, \"production options should return\")\n\n    prodOpts.ServiceOptions.DefaultEcosystem = \"default\"\n    assert.Equal(prodOpts, opts, \"should default to production env\")\n    assert.Equal(\"prod.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect prod url\")\n\n    err = WithAuthToken(\"test token\")(opts)\n    assert.Nil(err, \"should not error on test token\")\n    assert.Equal(\"test token\", opts.ServiceOptions.AuthToken, \"test token not applied\")\n\n    err = WithDevEnv()(opts)\n    assert.Nil(err, \"should not error on dev env\")\n    assert.Equal(\"dev-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect dev url\")\n\n    err = WithStagingEnv()(opts)\n    assert.Nil(err, \"should not error on staging env\")\n    assert.Equal(\"staging-internal.trinsic.cloud\", opts.ServiceOptions.ServerEndpoint, \"incorrect staging url\")\n\n    err = WithDefaultEcosystem(\"test1\")(opts)\n    assert.Nil(err, \"should not error on setting default ecosystem\")\n    assert.Equal(\"test1\", opts.ServiceOptions.DefaultEcosystem, \"default ecosystem not updated\")\n}\n\nfunc TestTrustRegistryDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, _ := NewTrustRegistryService(opts)\n\n    // register issuer\n    didURI := \"did:example:test\"\n    schemaURI := \"https://schema.org/Card\"\n    frameworkURI := fmt.Sprintf(\"https://example.com/%s\", uuid.New())\n\n    // registerGovernanceFramework() {\n    newFramework, err := service.AddFramework(context.Background(), &amp;trustregistry.AddFrameworkRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Name:                   fmt.Sprintf(\"Example Framework - %s\", uuid.New()),\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // registerMemberSample() {\n    registerMemberResponse, err := service.RegisterMember(context.Background(), &amp;trustregistry.RegisterMemberRequest{\n        FrameworkId: newFramework.Id,\n        SchemaUri:   schemaURI,\n        Member:      &amp;trustregistry.RegisterMemberRequest_DidUri{DidUri: didURI},\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // getMembershipStatus() {\n    getMembershipStatusResponse, err := service.GetMembershipStatus(context.Background(), &amp;trustregistry.GetMembershipStatusRequest{\n        GovernanceFrameworkUri: frameworkURI,\n        Member:                 &amp;trustregistry.GetMembershipStatusRequest_DidUri{DidUri: didURI},\n        SchemaUri:              schemaURI,\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.Equal(trustregistry.RegistrationStatus_CURRENT, getMembershipStatusResponse.Status, \"Member status should be current\")\n\n    // searchTrustRegistry() {\n    ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(ecosystemList)\n    assert2.NotEmpty(ecosystemList)\n\n    // unregisterIssuer() {\n    unregisterMemberResponse, err := service.UnregisterMember(context.Background(), &amp;trustregistry.UnregisterMemberRequest{\n        SchemaUri:   schemaURI,\n        FrameworkId: newFramework.Id,\n    })\n    // }\n\n    // This is for the variables used for demos above, so they appear \"used\".\n    if unregisterMemberResponse == nil || registerMemberResponse == nil || getMembershipStatusResponse == nil {\n        // Do absolutely nothing\n    }\n}\n\nfunc createAccountAndSignIn(t *testing.T) (*assert.Assertions, string, error) {\n    assert2 := assert.New(t)\n    opts, err := NewServiceOptions(WithTestEnv())\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    // Open in background\n    accountService, err := NewAccountService(opts)\n    if !assert2.Nil(err) {\n        return assert2, \"\", err\n    }\n    authtoken, _, err := accountService.SignIn(context.Background(), &amp;account.SignInRequest{})\n    if !assert2.Nil(err) {\n        fmt.Println(err)\n        return assert2, \"\", err\n    }\n    return assert2, authtoken, nil\n}\n\nfunc createRandomEcosystem() error {\n    opts, err := NewServiceOptions(WithTestEnv())\n    if err != nil {\n        return err\n    }\n\n    ps, err := NewProviderService(opts)\n    if err != nil {\n        return err\n    }\n\n    _, err = ps.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{Name: \"test-sdk-\" + uuid.New().String()})\n\n    return err\n}\nfunc TestEcosystemDemo(t *testing.T) {\n    assert2, authtoken, err := createAccountAndSignIn(t)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    opts, err := NewServiceOptions(WithTestEnv(), WithAuthToken(authtoken))\n    if !assert2.Nil(err) {\n        return\n    }\n\n    service, err := NewProviderService(opts)\n    if !assert2.Nil(err) {\n        return\n    }\n\n    // createEcosystem() {\n    actualCreate, err := service.CreateEcosystem(context.Background(), &amp;provider.CreateEcosystemRequest{\n        Description: \"My ecosystem\",\n        Uri:         \"https://example.com\",\n    })\n    // }\n    if !assert2.Nil(err) {\n        return\n    }\n    assert2.NotNil(actualCreate)\n    // assert2.NotNil(actualCreate.Id)\n    // assert2.True(strings.HasPrefix(actualCreate.Id, \"urn:trinsic:ecosystems:\"))\n\n    // inviteParticipant() {\n    inviteResponse, err := service.InviteParticipant(context.Background(),\n        &amp;provider.InviteRequest{Participant: provider.ParticipantType_participant_type_individual,\n            Details: &amp;account.AccountDetails{Email: \"example@trinsic.id\"}})\n    // }\n    if inviteResponse == nil {\n        inviteResponse = &amp;provider.InviteResponse{InvitationId: \"NA\"}\n    }\n    // invitationStatus() {\n    inviteStatus, err := service.InvitationStatus(context.Background(), &amp;provider.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n    // }\n    if inviteStatus != nil {\n    }\n\n}\n\n// func TestCreateChannelUrlFromConfig(t *testing.T) {\n//  assert2 := assert.New(t)\n//  if !assert2.Equalf(CreateChannelUrlFromConfig(TrinsicProductionConfig()), CreateChannelUrlFromConfig(nil), \"Default is production stack\") {\n//      return\n//  }\n// }\n\nfunc failError(t *testing.T, message string, err error) {\n    if err != nil {\n        t.Helper()\n        t.Errorf(\"%s: %v\", message, err)\n        t.FailNow()\n    }\n}\n</code></pre>   <pre><code>var walletItems = walletService.search(\n        UniversalWalletOuterClass.SearchRequest\n                .newBuilder()\n                .setQuery(\"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\")\n                .build()\n).get();\n</code></pre>","title":"SQL Search"},{"location":"reference/services/wallet-service/#common-sql-queries","text":"","title":"Common SQL Queries"},{"location":"reference/services/wallet-service/#paging","text":"<p>Paging uses the <code>OFFSET</code> clause that takes in a value indicating how many records should be skipped in the returned query. To specify the size of the result set (page size) use the <code>LIMIT</code> clause.</p> <pre><code>SELECT * FROM c OFFSET 10 LIMIT 5\n</code></pre>","title":"Paging"},{"location":"reference/services/wallet-service/#sorting","text":"<p>The optional <code>ORDER BY</code> clause specifies the sorting order for results returned by the query. To control sorting order, specify <code>ASC</code> or <code>DESC</code> at the end; if not specified ascending order is used by default.</p> <pre><code>SELECT * FROM c ORDER BY c.credential.issued DESC\n</code></pre>","title":"Sorting"},{"location":"reference/services/wallet-service/#filtering","text":"<p>The optional WHERE clause (<code>WHERE &lt;filter_condition&gt;</code>) specifies condition(s) that the source JSON items must satisfy for the query to include them in results. A JSON item must evaluate the specified conditions to true to be considered for the result. The index layer uses the <code>WHERE</code> clause to determine the smallest subset of source items that can be part of the result.</p> <pre><code>SELECT * FROM c WHERE c.name = 'Trinsic' AND c.dateCreated &gt;= \"2020-09-30T23:14:25.7251173Z\"\n</code></pre>","title":"Filtering"},{"location":"reference/services/wallet-service/#grouping","text":"<p>The <code>GROUP BY</code> clause divides the query's results according to the values of one or more specified properties. Examples and detailed description on working with grouped results can be found here </p>","title":"Grouping"},{"location":"reference/services/wallet-service/#additional-resources","text":"<p>You can read the full documentation on working with SQL queries on the Azure Cosmos DB website .</p>","title":"Additional Resources"},{"location":"ruby/","text":"<p>The Trinsic Ruby SDK makes it easy to interact with the Trinsic API from any Ruby application. The most recent version of the library can be found on RubyGems. You can find the SDKs source on Github.</p>","title":"The Trinsic Ruby SDK"},{"location":"ruby/#installation-and-configuration","text":"<ul> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>RUBY_DLL_PATH</code> on windows. <code>LD_LIBRARY_PATH</code> for Ruby on Mac/Linux <pre><code>gem install trinsic-services\n</code></pre></li> <li>Test installation by running the following Ruby script: <pre><code>require 'trinsic_services'\n\naccount_service = Trinsic::AccountService.new(nil, Trinsic::trinsic_prod_server)\naccount_profile = account_service.sign_in(nil).profile\nputs account_profile\n</code></pre></li> <li>Output should look something like this: <pre><code>&lt;Services::Account::V1::AccountProfile: profile_type: \"https://trinsic.id/security/v1/oberon\", auth_data: \")urn:trinsic:wallets:bbBEp9EmV1NNWMadBhit2$19ac25ae-2fd0-44d1-9ef7-73cc668e8f7d\", auth_token: \"\u2592\", protection: &lt;Services::Account::V1::TokenProtection: enabled: false, method: :None&gt;&gt;\n</code></pre></li> </ul>","title":"Installation and Configuration"},{"location":"ruby/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API </p>","title":"Next Steps"},{"location":"walkthroughs/vaccination/","text":"<p>This walkthrough demonstrates how a vaccination card can be issued, held, and shared using Verifiable Credentials with Trinsic.</p>","title":"Walkthrough: Build a Vaccine Card"},{"location":"walkthroughs/vaccination/#meet-allison","text":"<p>We'll follow Allison as she obtains a vaccine certificate, stores it in her digital wallet, and presents it to board an airplane.</p> <p>In most credential exchange scenarios, there are three primary roles: Issuer, Holder, and Verifier.</p> <p>Holder: Stores credentials received from issuers, and presents them to verifiers. (Said credentials are often, but not always, attesting information about the holder)</p> <p>Issuer: Signs and issues credentials which attest information about a credential subject.</p> <p>Verifier: Verifies credentials presented by holders.</p> <p>In this case, Allison will be the holder, a vaccination clinic will be the issuer, and an airline will be the verifier. </p>","title":"Meet Allison"},{"location":"walkthroughs/vaccination/#our-sdks","text":"<p>You can follow along using one of our SDKs, or use the Trinsic CLI, which implements full platform functionality.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>Click here for installation instructions for the Trinsic CLI.</p>    <p>Click here for installation instructions for the Node/Browser SDK.</p>   <p>Click here for installation instructions for the .NET SDK.</p>   <p>Click here for installation instructions for the Python SDK.</p>   <p>Click here for installation instructions for the Java SDK.</p>   <p>Click here for installation instructions for the Go SDK.</p>   <p>Click here for installation instructions for the Ruby   SDK.</p>","title":"Our SDKs"},{"location":"walkthroughs/vaccination/#create-an-ecosystem","text":"<p>The first step is to create an ecosystem, within which everything else (wallets, templates, and credentials) will live.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic provider create-ecosystem\n</code></pre>   <pre><code>const ecosystem = await providerService.createEcosystem(CreateEcosystemRequest.fromPartial({}));\nconst ecosystemId = ecosystem.ecosystem!.id;\n</code></pre>   <pre><code>var providerService = new ProviderService(_options);\n\nvar (ecosystem, _) = await providerService.CreateEcosystemAsync(new());\nvar ecosystemId = ecosystem?.Id;\n</code></pre>   <pre><code>ecosystem = await provider_service.create_ecosystem()\necosystem_id = ecosystem.ecosystem.id\n</code></pre>   <pre><code>var ecosystemResponse = providerService.createEcosystem(\n        ProviderOuterClass.CreateEcosystemRequest.getDefaultInstance()\n).get();\n\nvar ecosystemId = ecosystemResponse.getEcosystem().getId();\n</code></pre>   <pre><code>ecosystem, _ := providerService.CreateEcosystem(context.Background(), nil)\necosystemId := ecosystem.Ecosystem.Id\n</code></pre>   <pre><code>ecosystem = provider_service.create_ecosystem\necosystem_id = ecosystem.ecosystem.id\n</code></pre>    <p>The response to this call contains the name and ID of your newly-created ecosystem; copy either of these down.</p>","title":"Create an Ecosystem"},{"location":"walkthroughs/vaccination/#configure-sdk-for-created-ecosystem","text":"<p>Once we've created our ecosystem, we need to configure our SDK client (or CLI) to use it as the default ecosystem for all service calls in the rest of the walkthrough.</p> Trinsic CLITypescriptC#PythonJavaGo   <pre><code>trinsic config --default-ecosystem \"{ECOSYSTEM_NAME_OR_ID}\"\n</code></pre>   <pre><code>// Either configure defaultEcosystem during instantiation of an SDK service...\nconst options = ServiceOptions.fromPartial({\n    defaultEcosystem: \"{ECOSYSTEM_NAME_OR_ID}\"\n});\n\nconst providerService = new ProviderService(options); \n\n//...or after instantiation\nproviderService.options.defaultEcosystem = \"{ECOSYSTEM_NAME_OR_ID}\";\n</code></pre>   <pre><code>// Either configure DefaultEcosystem during instantiation of an SDK service...\nvar providerService = new ProviderService(new()\n{\n    DefaultEcosystem = \"{ECOSYSTEM_NAME_OR_ID}\"\n});\n\n//...or after instantiation\nproviderService.Options.DefaultEcosystem = \"{ECOSYSTEM_NAME_OR_ID}\";\n</code></pre>   <pre><code>from trinsic.trinsic_util import trinsic_config\n\n# Either configure default_ecosystem during instantiation of an SDK service...\nconfig = trinsic_config()\nconfig.default_ecosystem = \"{ECOSYSTEM_NAME_OR_ID}\"\nprovider_service = ProviderService(server_config=config)\n\n# ...or after instantiation\nprovider_service.service_options.default_ecosystem = \"{ECOSYSTEM_NAME_OR_ID}\"\n</code></pre>   <pre><code>var options = TrinsicUtilities.getTrinsicServiceOptions();\noptions = options\n          .toBuilder()\n          .setDefaultEcosystem(\"ECOSYSTEM_ID_OR_NAME\")\n          .build();\nvar accountService = new AccountService(options);\n</code></pre>   <pre><code>///Either configure DefaultEcosystem during instantiation of an SDK service...\nopts, _ := sdk.NewServiceOptions()\nproviderService, _ := sdk.NewProviderService(opts)\n\n//...or after instantiation\nproviderService.options.ServiceOptions.DefaultEcosystem = \"{ECOSYSTEM_NAME_OR_ID}\"\n</code></pre>     <p>Further Reading: Ecosystems</p> <ul> <li>Learn more about Ecosystems</li> <li>Browse the Provider API reference</li> </ul>","title":"Configure SDK for Created Ecosystem"},{"location":"walkthroughs/vaccination/#create-accounts","text":"<p>We need to create Trinsic accounts for the participants in this credential exchange. Accounts and wallets can be considered interchangeably; all accounts have exactly one associated wallet.</p> <p>Accounts can be created with a single call; they're designed to minimize onboarding friction for your users.</p> <p>The clinic's account will issue the credential, Allison's account will hold it, and the airline's account will verify its contents.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>The CLI makes it easy to create wallets. For demo purposes, we'll create all three on the same machine.</p> <p>When using the CLI, the authentication token of the most recently used account is saved in <code>~/.trinsic</code>. In a real-world scenario, you should back this token up securely.</p> <pre><code>trinsic account login --name \"Allison\"\n# Save auth token in `allison.txt` before continuing\n\ntrinsic account login --name \"Airline\"\n# Save auth token in `airline.txt` before continuing\n\ntrinsic account login --name \"Vaccination Clinic\"\n# Save auth token in `clinic.txt` before continuing\n</code></pre>   <pre><code>// Create 3 different profiles for each participant in the scenario\nconst allison = await accountService.signIn();\nconst clinic = await accountService.signIn();\nconst airline = await accountService.signIn();\n</code></pre> <p>If you would like to save the account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code>var accountService = new AccountService(_options);\n\nvar allison = await accountService.SignInAsync(new() { EcosystemId = ecosystemId });\nvar clinic = await accountService.SignInAsync(new() { EcosystemId = ecosystemId });\nvar airline = await accountService.SignInAsync(new() { EcosystemId = ecosystemId });\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code># Create an account for each participant in the scenario\nallison = await account_service.sign_in()\nairline = await account_service.sign_in()\nclinic = await account_service.sign_in()\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code>// Create an account for each participant in the scenario\nvar allison = accountService.signIn().get();\nvar clinic = accountService.signIn().get();\nvar airline = accountService.signIn().get();\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code>// Create an account for each participant in the scenario\nallison, _, _ := accountService.SignIn(context.Background(), nil)\nairline, _, _ := accountService.SignIn(context.Background(), nil)\nclinic, _, _ := accountService.SignIn(context.Background(), nil)\n</code></pre> <p>If you would like to save an account for future use, simply write the auth token to storage. Take care to store it in a secure location.</p>   <pre><code># Create an account for each participant in the scenario\nallison = account_service.sign_in\nclinic = account_service.sign_in\nairline = account_service.sign_in\n</code></pre>     <p>Production Usage</p> <p>In this example, we've created anonymous accounts; the only way to access them is by saving the authentication token generated on account creation.</p> <p>In a production scenario, you may want to create accounts tied to a user's email address or phone number. This allows users to securely access their Trinsic cloud wallets at any time.</p> <p>Note that accounts are tied to their ecosystem. If you create an account tied to <code>bob@example.com</code> in the <code>example1</code> ecosystem, it will not be visible in any other ecosystem. The same email address can be used to create accounts in multiple ecosystems.</p>   <p>Further Reading: Accounts and Wallets</p> <ul> <li>Learn more about Wallets</li> <li>Browse the Account API reference</li> <li>Read about authentication tokens and security</li> </ul>","title":"Create Accounts"},{"location":"walkthroughs/vaccination/#define-a-template","text":"<p>Before we can issue a credential, we need to create a Template for it. </p> <p>Templates are simply a list of the fields that a credential can have.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>First, prepare a JSON file which describes your template:</p> templateData.json     <pre><code>{\n    \"firstName\": {\n        \"type\": \"string\",\n        \"description\": \"First name of vaccine recipient\"\n    },\n    \"lastName\": {\n        \"type\": \"string\",\n        \"description\": \"Last name of vaccine recipient\"\n    },\n    \"batchNumber\":{\n        \"type\": \"string\",\n        \"description\": \"Batch number of vaccine\"\n    },\n    \"countryOfVaccination\":{\n        \"type\": \"string\",\n        \"description\": \"Country in which the subject was vaccinated\"\n    }\n}\n</code></pre> <p>Then create the template:</p> <pre><code>trinsic template create -n \"VaccinationCertificate\" --fields-file templateData.json \n</code></pre> <p>The output of this command will include a template ID; copy this down for later use.</p>   <pre><code>//Define all fields\nconst firstNameField = TemplateField.fromPartial({\n  description: \"First name of vaccine recipient\",\n  type: FieldType.STRING\n});\n\nconst lastNameField = TemplateField.fromPartial({\n  type: FieldType.STRING,\n  description: \"Last name of vaccine recipient\"\n});\n\nconst batchNumberField = TemplateField.fromPartial({\n  type: FieldType.STRING,\n  description: \"Batch number of vaccine\"\n});\n\nconst countryOfVaccinationField = TemplateField.fromPartial({\n  type: FieldType.STRING,\n  description: \"Country in which the subject was vaccinated\"\n});\n\n//Create request\nlet request = CreateCredentialTemplateRequest.fromPartial({\n  name: \"VaccinationCertificate\",\n  fields: {\n    firstName: firstNameField,\n    lastName: lastNameField,\n    batchNumber: batchNumberField,\n    countryOfVaccination: countryOfVaccinationField,\n  },\n});\n\n//Create template\nconst response = await templateService.createCredentialTemplate(request);\nconst template = response.data;\n</code></pre>   <pre><code>// Create a TemplateService instance\nvar templateService = new TemplateService(_options);\n\n// Prepare request to create template\nCreateCredentialTemplateRequest templateRequest = new() {\n    Name = \"VaccinationCertificate\",\n    AllowAdditionalFields = false\n};\n\ntemplateRequest.Fields.Add(\"firstName\", new() { Description = \"First name of vaccine recipient\" });\ntemplateRequest.Fields.Add(\"lastName\", new() { Description = \"Last name of vaccine recipient\" });\ntemplateRequest.Fields.Add(\"batchNumber\", new() { Description = \"Batch number of vaccine\", Type = FieldType.String });\ntemplateRequest.Fields.Add(\"countryOfVaccination\", new() { Description = \"Country in which the subject was vaccinated\" });\n\n// Create template\nvar template = await templateService.CreateAsync(templateRequest);\nvar templateId = template?.Data?.Id;\n</code></pre>   <pre><code>template = await template_service.create(\n    request=CreateCredentialTemplateRequest(\n        name=\"VaccinationCertificate\",\n        allow_additional_fields=False,\n        fields={\n            \"firstName\": TemplateField(description=\"First name of vaccine recipient\"),\n            \"lastName\": TemplateField(description=\"Last name of vaccine recipient\"),\n            \"batchNumber\": TemplateField(description=\"Batch number of vaccine\", type=FieldType.STRING),\n            \"countryOfVaccination\": TemplateField(description=\"Country in which the subject was vaccinated\"),\n        },\n    )\n)\n\ntemplate_id = template.data.id\n</code></pre>   <pre><code>//Set active profile to 'clinic'\ntemplateService.setProfile(clinic);\n\n//Define fields for template\nvar fields = new HashMap&lt;String, Templates.TemplateField&gt;();\nfields.put(\"firstName\", Templates.TemplateField.newBuilder()\n        .setDescription(\"First name of vaccine recipient\")\n        .build());\nfields.put(\"lastName\", Templates.TemplateField.newBuilder()\n        .setDescription(\"Last name of vaccine recipient\")\n        .build());\nfields.put(\"batchNumber\", Templates.TemplateField.newBuilder()\n        .setType(Templates.FieldType.STRING)\n        .setDescription(\"Batch number of vaccine\")\n        .build());\nfields.put(\"countryOfVaccination\", Templates.TemplateField.newBuilder()\n        .setDescription(\"Country in which the subject was vaccinated\")\n        .build());\n\n//Create template request\nvar templateRequest = Templates.CreateCredentialTemplateRequest\n        .newBuilder()\n        .setName(\"VaccinationCertificate\")\n        .setAllowAdditionalFields(false)\n        .putAllFields(fields)\n        .build();\n\n//Execute template creation\nvar template = templateService.create(templateRequest).get();\nvar templateId = template.getData().getId();\n</code></pre>   <pre><code>templateRequest := &amp;template.CreateCredentialTemplateRequest{Name: \"VaccinationCertificate\", AllowAdditionalFields: false, Fields: make(map[string]*template.TemplateField)}\ntemplateRequest.Fields[\"firstName\"] = &amp;template.TemplateField{Description: \"First name of vaccine recipient\"}\ntemplateRequest.Fields[\"lastName\"] = &amp;template.TemplateField{Description: \"Last name of vaccine recipient\"}\ntemplateRequest.Fields[\"batchNumber\"] = &amp;template.TemplateField{Description: \"Batch number of vaccine\", Type: template.FieldType_STRING}\ntemplateRequest.Fields[\"countryOfVaccination\"] = &amp;template.TemplateField{Description: \"Country in which the subject was vaccinated\"}\n\ncreatedTemplate, _ := templateService.Create(context.Background(), templateRequest)\n\ntemplateId := createdTemplate.Data.Id\n</code></pre>   <pre><code>request = Trinsic::Template_V1::CreateCredentialTemplateRequest.new(name: 'VaccinationCertificate',\n                                                                    allow_additional_fields: false)\nrequest.fields['firstName'] = Trinsic::Template_V1::TemplateField.new(description: 'First name of vaccine recipient')\nrequest.fields['lastName'] = Trinsic::Template_V1::TemplateField.new(description: 'Last name of vaccine recipient')\nrequest.fields['batchNumber'] =\n  Trinsic::Template_V1::TemplateField.new(description: 'Batch number of vaccine',\n                                          type: Trinsic::Template_V1::FieldType::STRING)\nrequest.fields['countryOfVaccination'] =\n  Trinsic::Template_V1::TemplateField.new(description: 'Country in which the subject was vaccinated')\n\ntemplate = template_service.create(request)\ntemplate_id = template.data.id\n</code></pre>     <p>Templates are Optional</p> <p>Templates are an optional helpful abstraction which removes the need to work directly with complex data formats such as JSON-LD.</p> <p>When a template is used to issue a credential, the result is a valid, interoperable JSON-LD Verifiable Credential.</p> <p>Trinsic's SDKs support issuing JSON-LD credentials that you create yourself, should you choose not to use templates.</p>   <p>Further Reading: Templates</p> <ul> <li>Learn more about Templates</li> <li>Browse the Template API reference</li> </ul>","title":"Define a Template"},{"location":"walkthroughs/vaccination/#issue-a-credential","text":"<p>Upon receiving her vaccine, the clinic issues Allison a Verifiable Credential, which proves that she was given the vaccine by the clinic.</p> <p>A credential is a JSON document that has been cryptographically signed; this signature enables verifiers to trust that the data comes a trusted source, and has not been tampered with.</p> <p>To issue a vaccine certificate, we'll use the template we created in the last step.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <p>First, prepare a file named <code>values.json</code> with the following content:</p> values.json     <pre><code>{\n    \"firstName\": \"Allison\",\n    \"lastName\": \"Allisonne\",\n    \"batchNumber\": \"123454321\",\n    \"countryOfVaccination\": \"US\"\n}\n</code></pre> <p>Then issue the credential:</p> <pre><code>trinsic config --auth-token $(cat clinic.txt)\ntrinsic vc issue-from-template --template-id {TEMPLATE_ID} --values-file values.json --out credential.json\n</code></pre> <p>The output of this command will contain a signed JSON document, which has been saved to <code>credential.json</code>.</p>   <pre><code>// Prepare the credential values JSON document\nconst credentialValues = JSON.stringify({\n  \"firstName\": \"Allison\",\n  \"lastName\": \"Allisonne\",\n  \"batchNumber\": \"123454321\",\n  \"countryOfVaccination\": \"US\"\n});\n\n// Sign a credential as the clinic and send it to Allison\ncredentialService.options.authToken = clinic;\nconst issueResponse = await credentialService.issueFromTemplate(\n  IssueFromTemplateRequest.fromPartial({ templateId: template.id, valuesJson: credentialValues })\n);\n</code></pre>   <pre><code>var credentialService = new CredentialService(_options);\n\n// Set active profile to 'clinic' so we can issue credential signed\n// with the clinic's signing keys\ncredentialService.Options.AuthToken = clinic;\n\n// Prepare credential values\nvar credentialValues = new Dictionary&lt;string, string&gt;() {\n    { \"firstName\", \"Allison\" },\n    { \"lastName\", \"Allisonne\" },\n    { \"batchNumber\", \"123454321\" },\n    { \"countryOfVaccination\", \"US\" }\n};\n\n// Issue credential\nvar issueResponse = await credentialService.IssueFromTemplateAsync(new() {\n    TemplateId = templateId,\n    ValuesJson = JsonSerializer.Serialize(credentialValues)\n});\n\nvar signedCredential = issueResponse?.DocumentJson;\n</code></pre>   <pre><code># Prepare values for credential\nvalues = json.dumps(\n    {\n        \"firstName\": \"Allison\",\n        \"lastName\": \"Allisonne\",\n        \"batchNumber\": \"123454321\",\n        \"countryOfVaccination\": \"US\",\n    }\n)\n\n# Issue credential\nissue_response = await credential_service.issue_from_template(\n    request=IssueFromTemplateRequest(template_id=template.id, values_json=values)\n)\n\ncredential = issue_response.document_json\n</code></pre>   <pre><code>// Set active profile to 'clinic' so we can issue credential signed\n// with the clinic's signing keys\ncredentialService.setProfile(clinic);\n\n//Prepare credential values\nvar valuesMap = new HashMap&lt;String, Object&gt;();\nvaluesMap.put(\"firstName\", \"Allison\");\nvaluesMap.put(\"lastName\", \"Allissonne\");\nvaluesMap.put(\"batchNumber\", \"123454321\");\nvaluesMap.put(\"countryOfVaccination\", \"US\");\n\n//Serialize values to JSON\nvar valuesJson = new Gson().toJson(valuesMap);\n\n//Issue credential\nvar issueResponse = credentialService.issueCredentialFromTemplate(\n        VerifiableCredentials.IssueFromTemplateRequest.newBuilder()\n                .setTemplateId(templateId)\n                .setValuesJson(valuesJson)\n                .build()\n).get();\n\nvar credential = issueResponse.getDocumentJson();\n</code></pre>   <pre><code>// Prepare values for credential\nvaluesStruct := struct {\n    FirstName            string\n    LastName             string\n    batchNumber          string\n    countryOfVaccination string\n}{\n    FirstName:            \"Allison\",\n    LastName:             \"Allisonne\",\n    batchNumber:          \"123454321\",\n    countryOfVaccination: \"US\",\n}\nvalues, _ := json.Marshal(valuesStruct)\n\n// Issue credential\nissueResponse, _ := credentialService.IssueFromTemplate(context.Background(), &amp;credential.IssueFromTemplateRequest{\n    TemplateId: createdTemplate.Id,\n    ValuesJson: string(values),\n})\n\nissuedCredential := issueResponse.DocumentJson\n</code></pre>   <pre><code># Prepares values for credential\nvalues = JSON.generate({ \"firstName\": 'Allison', \"lastName\": 'Allisonne', \"batchNumber\": '123454321',\n                         \"countryOfVaccination\": 'US' })\n\n# Issue credential\nissue_response = credential_service.issue_from_template(Trinsic::Credentials_V1::IssueFromTemplateRequest.new(\n                                                          template_id: template.id, values_json: values\n                                                        ))\ncredential = issue_response.document_json\n</code></pre>     <p>Further Reading: Issuance and Credentials</p> <ul> <li>Learn more about Verifiable Credentials</li> <li>Browse the Credential API reference</li> </ul>","title":"Issue a Credential"},{"location":"walkthroughs/vaccination/#send-credential-to-allison","text":"<p>Now that the clinic has a signed credential, it must be securely transmitted to Allison, so she can store it in her wallet.</p> <p>Because it's just a JSON string, it could be delivered in many ways -- for example, in the response to an HTTPS request which triggered the issuance process.</p>  <p>Send via Trinsic</p> <p>In the future, we will offer the ability to send a credential directly to a Trinsic user's wallet.</p> <p>Click here to learn more about this feature.</p>","title":"Send Credential to Allison"},{"location":"walkthroughs/vaccination/#store-credential-in-wallet","text":"<p>Once Allison receives the credential, it must be stored in her wallet.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic config --auth-token $(cat allison.txt)\ntrinsic wallet insert-item --item credential.json\n</code></pre>   <pre><code>// Alice stores the credential in her cloud wallet.\nwalletService.options.authToken = allison;\nconst insertResponse = await walletService.insertItem(\n  InsertItemRequest.fromPartial({\n    itemJson: issueResponse.documentJson,\n  })\n);\n</code></pre>   <pre><code>var walletService = new WalletService(_options);\n\n// Set active profile to 'allison' so we can manage her cloud wallet\nwalletService.Options.AuthToken = allison;\n\n// Insert credential into Allison's wallet\nvar insertItemResponse = await walletService.InsertItemAsync(new() {\n    ItemJson = signedCredential\n});\n\nvar itemId = insertItemResponse?.ItemId;\n</code></pre>   <pre><code># Allison stores the credential in her cloud wallet\nwallet_service.service_options.auth_token = allison\n\ninsert_response = await wallet_service.insert_item(\n    request=InsertItemRequest(item_json=credential)\n)\n\nitem_id = insert_response.item_id\n</code></pre>   <pre><code>// Set active profile to 'allison' so we can manage her cloud wallet\nwalletService.setProfile(allison);\n\n// Allison stores the credential in her cloud wallet.\nvar insertItemResponse = walletService.insertItem(\n        UniversalWalletOuterClass.InsertItemRequest\n                .newBuilder()\n                .setItemJson(credential)\n                .build()\n).get();\n\nfinal var itemId = insertItemResponse.getItemId();\n</code></pre>   <pre><code>// Allison stores the credential in her cloud wallet\nwalletService.SetToken(allison)\ninsertResponse, _ := walletService.InsertItem(context.Background(), &amp;wallet.InsertItemRequest{ItemJson: issuedCredential})\n\nitemId := insertResponse.ItemId\n</code></pre>   <pre><code># Allison stores the credential in her cloud wallet\nwallet_service.auth_token = allison\ninsert_response = wallet_service.insert_item(Trinsic::Wallet_V1::InsertItemRequest.new(item_json: credential))\nitem_id = insert_response.item_id\n</code></pre>    <p>The response to this call contains an Item ID; copy this down.</p>  <p>Further Reading: Wallets</p> <ul> <li>Learn more about Wallets</li> <li>Browse the Wallet API reference</li> </ul>","title":"Store Credential in Wallet"},{"location":"walkthroughs/vaccination/#create-a-proof-of-vaccination","text":"<p>Before boarding, the airline requests proof of vaccination from Allison. Specifically, they want to see proof that she holds a <code>VaccinationCertificate</code> credential.</p> <p>Let's use the CreateProof call to build a proof for Allison's held credential.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic config --auth-token $(cat allison.txt)\ntrinsic vc create-proof --item-id \"{ITEM_ID}\" --out proof.json\n</code></pre>   <pre><code>// Allison shares the credential with the venue.\ncredentialService.options.authToken = allison;\nconst proofResponse = await credentialService.createProof(\n  CreateProofRequest.fromPartial({\n    itemId: insertResponse.itemId\n  })\n);\n</code></pre>   <pre><code>// Set active profile to 'allison' so we can create a proof using her key\ncredentialService.Options.AuthToken = allison;\n\n// Build a proof for the signed credential\nvar proofResponse = await credentialService.CreateProofAsync(new() {\n    ItemId = itemId\n});\n\nvar proofJSON = proofResponse?.ProofDocumentJson;\n</code></pre>   <pre><code># Allison shares the credential with the airline\ncredential_service.service_options.auth_token = allison\n\nproof_response = await credential_service.create_proof(\n    request=CreateProofRequest(item_id=item_id)\n)\n\ncredential_proof = proof_response.proof_document_json\n</code></pre>   <pre><code>// Set active profile to 'allison' so we can create a proof using her key\ncredentialService.setProfile(allison);\n\n// Allison shares the credential with the venue\nvar createProofResponse = credentialService.createProof(\n        VerifiableCredentials.CreateProofRequest\n                .newBuilder()\n                .setItemId(itemId)\n                .build()\n).get();\n\nvar credentialProof = createProofResponse.getProofDocumentJson();\n</code></pre>   <pre><code>// Allison shares the credential with the airline\ncredentialService.SetToken(allison)\nproofResponse, _ := credentialService.CreateProof(context.Background(), &amp;credential.CreateProofRequest{\n    Proof: &amp;credential.CreateProofRequest_ItemId{ItemId: itemId},\n})\n\ncredentialProof := proofResponse.ProofDocumentJson\n</code></pre>   <pre><code># Allison shares the credential with the airline\ncredential_service.auth_token = allison\nproof_response = credential_service.create_proof(Trinsic::Credentials_V1::CreateProofRequest.new(item_id: item_id))\ncredential_proof = proof_response.proof_document_json\n</code></pre>    <p>Allison sends this proof to the airline for them to verify.</p>  <p>Partial Proofs</p> <p>In this example, the proof is being created over the entire credential; all of its fields are revealed to the verifier.</p> <p>It is possible for the airline to send Allison a frame which requests only certain fields of the credential. The airline would not be able to see other fields of the credential, but cryptographic guarantees would still hold over the revealed fields.</p> <p>See the CreateProof reference for more information.</p>   <p>OpenID Connect for Presentation</p> <p>Trinsic offers an OpenID Connect service as an alternative flow for the exchange of a credential between a holder and a verifier.</p> <p>In this flow, a holder simply clicks a link (or scans a QR code), logs into their Trinsic cloud wallet, and selects a credential to share. </p>","title":"Create a Proof of Vaccination"},{"location":"walkthroughs/vaccination/#verify-proof","text":"<p>Once the airline receives the proof, they can use the VerifyProof call to ensure its authenticity.</p> Trinsic CLITypescriptC#PythonJavaGoRuby   <pre><code>trinsic config --auth-token $(cat airline.txt)\ntrinsic vc verify-proof --proof-document proof.json\n</code></pre>   <pre><code>// The airline verifies the credential\ncredentialService.options.authToken = airline;\nconst verifyResponse = await credentialService.verifyProof(\n  VerifyProofRequest.fromPartial({\n    proofDocumentJson: proofResponse.proofDocumentJson,\n  })\n);\n</code></pre>   <pre><code>// Verify that Allison has provided a valid proof\nvar verifyResponse = await credentialService.VerifyProofAsync(new() {\n    ProofDocumentJson = proofJSON\n});\n\nbool credentialValid = verifyResponse?.IsValid ?? false;\n</code></pre>   <pre><code># The airline verifies the credential\ncredential_service.service_options.auth_token = airline\n\nverify_result = await credential_service.verify_proof(\n    request=VerifyProofRequest(proof_document_json=credential_proof)\n)\n\nvalid = verify_result.is_valid\n</code></pre>   <pre><code>credentialService.setProfile(airline);\n\n// Verify that Allison has provided a valid proof\nvar verifyProofResponse = credentialService.verifyProof(\n        VerifiableCredentials.VerifyProofRequest\n                .newBuilder()\n                .setProofDocumentJson(credentialProof)\n                .build()\n).get();\n\nboolean isValid = verifyProofResponse.getIsValid();\n</code></pre>   <pre><code>// The airline verifies the credential\ncredentialService.SetToken(airline)\nverifyResult, _ := credentialService.VerifyProof(context.Background(), &amp;credential.VerifyProofRequest{ProofDocumentJson: credentialProof})\nvalid := verifyResult.IsValid\n</code></pre>   <pre><code># The airline verifies the credential\ncredential_service.auth_token = airline\n\nverify_result = credential_service.verify_proof(Trinsic::Credentials_V1::VerifyProofRequest.new(proof_document_json: credential_proof))\n\nvalid = verify_result.is_valid\n</code></pre>     <p>Interoperability</p> <p>The Verifiable Credentials and Proofs that Trinsic's platform produces are based on open standards.</p> <p>Although we use the VerifyProof call in this example, the proof could be verified using any standards-compliant software.</p>","title":"Verify Proof"},{"location":"walkthroughs/vaccination/#full-source-code","text":"TypescriptC#PythonJavaGoRuby   <p>This sample is available as <code>VaccineDemoShared.ts</code> in our SDK repository.</p>   <p>This sample is available as <code>VaccineWalkthroughTests.cs</code> in our SDK repository.</p>   <p>This sample is available as <code>vaccine_demo.py</code> in our SDK repository.</p>   <p>This sample is available as <code>VaccineDemo.java</code> in our SDK repository.</p>   <p>This sample is available as <code>vaccine_test.go</code> in our SDK repository.</p>   <p>This sample is available as <code>vaccine_demo.rb</code> in our SDK repository.</p>","title":"Full Source Code"},{"location":"walkthroughs/vaccination/#next-steps","text":"<p>Congratulations! If you've completed all the steps of this walkthrough, you've just created a mini ecosystem of issuers, verifiers, and holders all exchanging credentials. Depending on your goals, there are a couple of possible next steps to take. </p> <ul> <li>Try out a sample app</li> <li>Browse the Service Reference</li> <li>Read more about the key concepts and technologies at play</li> </ul>","title":"Next Steps"},{"location":"web/","text":"<p>The Trinsic Web SDK makes it easy to interact with the Trinsic API from any client-side web application. You can find the SDKs source on Github.</p>","title":"The Trinsic Javascript / Web SDK"},{"location":"web/#installation","text":"<p>Install the package for Node or Browser from npmjs.com </p> Install   <pre><code>npm i @trinsic/trinsic\n</code></pre>","title":"Installation"},{"location":"web/#create-new-project","text":"<p>Let's create a new console app that we will use to add our sample code</p> <pre><code>mkdir web-sample &amp;&amp; cd web-sample &amp;&amp; npm init\n</code></pre> <p>You can select all the defaults for the node project.</p> <p>Add the required dependencies</p> <pre><code>npm i @trinsic/trinsic-web\n</code></pre> <pre><code>npm i --save-dev http-server webpack webpack-cli\n</code></pre>","title":"Create new project"},{"location":"web/#configure-webpack","text":"<p>After installing the dependencies you'll need a configuration file for webpack. Create a file called webpack.config.js at the root of your project and then copy and paste this into that file <pre><code>const path = require('path');\n\nmodule.exports = {\n  mode: 'development',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, './src'),\n    filename: 'bundle.js',\n  }\n};\n</code></pre></p>","title":"Configure Webpack"},{"location":"web/#configure-webpack-for-react","text":"<p>If using React you may need to start your project with craco</p> <p>Install Craco <pre><code>npm i @craco/craco\n</code></pre></p> <p>Next change your react scripts in your package.json file <pre><code>\"scripts\": {\n-   \"start\": \"react-scripts start\",\n+   \"start\": \"craco start\",\n-   \"build\": \"react-scripts build\",\n+   \"build\": \"craco build\"\n-   \"test\": \"react-scripts test\",\n+   \"test\": \"craco test\"\n}\n</code></pre> Finally you will need to add a craco configuration file called <code>craco.config.js</code> and add the following:</p> <pre><code>// craco.config.js\n\nconst { addBeforeLoader, loaderByName } = require('@craco/craco');\n\nmodule.exports = {\n  webpack: {\n    configure: (webpackConfig) =&gt; {\n      const wasmExtensionRegExp = /\\.wasm$/;\n      webpackConfig.resolve.extensions.push('.wasm');\n\n      webpackConfig.module.rules.forEach((rule) =&gt; {\n        (rule.oneOf || []).forEach((oneOf) =&gt; {\n          if (oneOf.loader &amp;&amp; oneOf.loader.indexOf('file-loader') &gt;= 0) {\n            oneOf.exclude.push(wasmExtensionRegExp);\n          }\n        });\n      });\n\n      const wasmLoader = {\n        test: /\\.wasm$/,\n        exclude: /node_modules/,\n        loaders: ['wasm-loader'],\n      };\n\n      addBeforeLoader(webpackConfig, loaderByName('file-loader'), wasmLoader);\n\n      return webpackConfig;\n    }\n  }\n}\n</code></pre> <p>This allows react loaders to properly load in some of our needed .wasm files.</p>","title":"Configure Webpack for React"},{"location":"web/#set-up-website","text":"<p>Create a simple html page with a script tag referencing the webpack bundle that will be built after completing the sample code. Note that you will not have the bundle.js file yet because it will be generated from the index.js file you create.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;title&gt;Web Sample&lt;/title&gt;\n  &lt;meta charset=\"UTF-8\" /&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n  &lt;meta name=\"description\" content=\"\" /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Web Sample&lt;/h1&gt;\n  &lt;div id=\"wallet\"&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;script src=\"../bundle.js\"&gt;&lt;/script&gt;\n&lt;/html&gt;\n</code></pre> <p>Your file structure should look like this</p> <pre><code>web-sample\n    src\n        index.html\n        index.js\n    package.json\n    webpack.config.js\n</code></pre>","title":"Set up Website"},{"location":"web/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"}]}