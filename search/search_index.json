{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"","text":"","title":"Introduction"},{"location":"#issue-and-verify-universally-accepted-digital-credentials","text":"<p>Trinsic is the proof of anything platform. We make it easy for people and organizations to prove things about themselves with technology instead of paper documents. Our software is based on Decentralized Identifiers (DIDs) and Verifiable Credentials (VCs), a new digital identity standard. </p> <p>Using Trinsic, organizations and their customers share data between each other in a trustworthy, standardized, and privacy-preserving way without requiring a centralized server or database. </p> <p>We make all of this possible by signing, sharing and storing verifiable data within identity wallets owned by individuals. People can easily share them with others to prove things about themselves anywhere.</p> <p>Learn how to issue and verify universally-accepted digital credentials so that anywhere people go online or in-person, they can simply tap their phone, prove who they are, and get what they need.</p>","title":"Issue and verify universally-accepted digital credentials."},{"location":"#our-products","text":"","title":"Our Products"},{"location":"#trinsic-core","text":"<p>Trinsic Core is infrastructure for digital trust. It's our set of APIs for sending verifiable data between digital identity wallets. Core gives people and organizations the ability to easily and securely prove things about themselves with digital credentials.</p> <p>With Core, you can transform credentials, licenses, passes, and certificates into a W3C standard format that can be exchanged digitally and verified instantly by anyone called a \"verifiable credential\".</p>","title":"Trinsic Core"},{"location":"#trinsic-ecosystems","text":"<p>A layer built on top of Core, Trinsic Ecosystems is a product for organizations that want to build an ecosystem of different issuers, holders, and verifiers of credentials. By ecosystem, we mean a network of companies and consumers that need to be able to securely share and instantly verify data. </p> <p>At Trinsic, we call the organizations that bring together these ecosystems of companies and customers \"providers\" since they are providing digital trust to the ecosystem through Trinsic's infrastructure.</p>  <p>Get Started in 15 Minutes</p> <p>Want to get started using digital credentials quickly? Try our tutorial to get a conceptual walkthrough of a common use case.</p>","title":"Trinsic Ecosystems"},{"location":"early-adopter/","text":"<p>For development teams ready to integrate verifiable credentials for a specific industry or use case, Trinsic Ecosystems has been built specifically for you. We're currently in beta with a small group of customers.</p> <p>If you'd like to join the beta for Trinsic Ecosystems, please reach out! Simply fill out the form below, and we'll get in touch.</p> <p>Sign Up</p>","title":"Introducing Trinsic Ecosystems"},{"location":"roadmap/","text":"","title":"Roadmap"},{"location":"roadmap/#sdks","text":"","title":"SDKs"},{"location":"roadmap/#available-sdks","text":"<ul> <li> .NET</li> <li> Node</li> <li> Python</li> <li> Web</li> <li> Java</li> </ul>","title":"Available SDKs"},{"location":"roadmap/#coming-soon","text":"<ul> <li> Android</li> <li> iOS</li> <li> Go</li> <li> Ruby</li> </ul>","title":"Coming Soon"},{"location":"support/","text":"<p>Normally, the best way to ask quick questions is through the Trinsic Community slack channel.</p> <p>If you have a bug to report, please report it on the Github issues on our SDK. Contributions and additions to this docs site are always welcome.</p> <p>Finally, if you're interested in getting in touch with the team for any other reason, contact us at support@trinsic.id. We treat any feedback as gold.</p>","title":"Have a Question?"},{"location":"android/","text":"<p>The Trinsic Android sample application makes it easy to interact with the Trinsic API. The sample application is located here</p>","title":"Android Sample Application"},{"location":"android/#installation","text":"<ol> <li>Clone the <code>sdk-examples</code> repository</li> <li>Open the folder <code>sdk-examples/android</code> in Android Studio</li> <li>Run gradle build for the first time, it will take a while, but it should pull down all the required <code>.jar</code> files</li> <li>You should be able to build and run the android application.</li> <li>There is an <code>sdk-examples/android-controller</code> application written in Python which allows you to issue credentials/verify proofs outside of the android application for demonstration purposes.</li> </ol>  <p>Note</p> <p>If you want to included the two required Trinsic <code>.jar</code> files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p>  <pre><code>def urlFile = { url, name -&gt;\n    File file = new File(\"$buildDir/download/${name}.jar\")\n    file.parentFile.mkdirs()\n    if (!file.exists()) {\n        new URL(url).withInputStream { downloadStream -&gt;\n            file.withOutputStream { fileOut -&gt;\n                fileOut &lt;&lt; downloadStream\n            }\n        }\n    }\n    files(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\n    // other dependencies\n    implementation urlFile('https://github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0')\n    implementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1')\n}\n</code></pre>","title":"Installation"},{"location":"android/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Java API Reference</p>","title":"Next Steps"},{"location":"cli/","text":"<p>The Trinsic CLI makes it easy to interact with the Trinsic API from your terminal. You can get the CLI on homebrew or build the CLI from source on Github. It contains all the commands of Trinsic's SDKs and makes them interactive. </p>","title":"The Trinsic CLI"},{"location":"cli/#installation","text":"MacOS and LinuxWindowsFrom source   <p>We use homebrew to distribute the CLI packages for MacOS and Linux. Install Homebrew</p> <p>Then run these commands to install the Trinsic CLI <pre><code>brew tap trinsic-id/tap\nbrew install trinsic-cli\n</code></pre></p>   <p>The CLI can be installed using Winget <pre><code>winget install trinsic.okapi\nwinget install trinsic.cli\n</code></pre></p>   <p>The CLI can also be built from source.</p> <p>This requires the Rustup toolchain  installed on your system.</p> <p>Once installed, run this command in terminal:</p> <pre><code>cargo +nightly install --git https://github.com/trinsic-id/sdk trinsic\n</code></pre> <p>To verify that the CLI has been installed successfully, try running:</p> <pre><code>trinsic --help\n</code></pre>","title":"Installation"},{"location":"cli/#next-steps","text":"<p>Once the CLI is installed, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference. For more information about the CLI, read the configuration guide</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"},{"location":"cli/config/","text":"<p>The CLI stores its configuration in the user's home directory in <code>~/.trinsic/</code>. This directory contains the main configuration file <code>config.toml</code> and all the profile data.</p>","title":"Configuration"},{"location":"cli/config/#show-configuration","text":"<p>To print the current configuration file in the terminal use:</p> <pre><code>trinsic config --show\n</code></pre> <p>Typical configuration file may look like this:</p> <pre><code>[server]\naddress = \"https://prod.trinsic.cloud\"\n\n[profile]\ndefault = \"my_profile\"\n</code></pre>","title":"Show Configuration"},{"location":"cli/config/#update-configuration-entry","text":"<p>To change the configuration values, use the <code>config</code> subcommand with the attribute and its value.</p> <pre><code>trinsic config &lt;attribute_name&gt; &lt;attribute_value&gt;\n</code></pre> <p>The following attributes are currently supported:</p>  <code>server-address</code>  <p>Updates the default server address the CLI communicates</p> <pre><code>trinsic config --server-address https://example.com/\n</code></pre>  <code>profile-default</code>  <p>Updates the default profile used with the CLI</p> <pre><code>trinsic config --profile-default alice\n</code></pre>","title":"Update Configuration Entry"},{"location":"cli/demo/","text":"","title":"Trinsic CLI Demo"},{"location":"cli/demo/#steps-to-run","text":"<ul> <li>Click the green Run button</li> <li>Follow walkthrough</li> <li>Note: If you resize this window, make sure to reload the page. If not, the CLI will have display problems.</li> </ul>","title":"Steps to Run"},{"location":"dotnet/","text":"<p>The Trinsic C# / .NET SDK makes it easy to interact with the Trinsic API from your .NET application. The most recent version of the library can be found on NuGet. The Trinsic SDK supports .NET applications written in C#, VB.NET, and F# that utilize any supported version of .NET Core. You can also find the SDKs source on Github.</p>  <p>Supported runtimes</p> <p>.NET targets for iOS, Android, and Blazor are fully supported using the same package dependencies via .NET 6.</p>","title":"The Trinsic C# / .NET SDK"},{"location":"dotnet/#installation-in-a-new-project","text":"<p>Add the required dependencies from Nuget.org </p> Package Manager.NET CLIPackageReference   <pre><code>PM&gt; Install-Package Trinsic\n</code></pre>   <pre><code>dotnet add package Trinsic --prerelease\ndotnet add package Okapi.Net --prerelease\n</code></pre>   <pre><code>&lt;PackageReference Include=\"Trinsic\" /&gt;\n&lt;PackageReference Include=\"Okapi.Net\" /&gt;\n</code></pre> <p>This will not be required in future version and only package <code>Trinsic</code> can be used.</p>","title":"Installation in a new project"},{"location":"dotnet/#configuration","text":"<pre><code>// accountServiceConstructor() {\nvar myAccountService = new AccountService(_options);\n// }\n// accountServiceSignIn() {\nvar myProfile = await myAccountService.SignInAsync(new());\n// }\nmyAccountService.Options.AuthToken = myProfile;\n// accountServiceGetInfo() {\nvar output = await myAccountService.GetInfoAsync();\n// }\nAssert.NotNull(output);\n</code></pre>","title":"Configuration"},{"location":"dotnet/#next-steps","text":"<p>Once the .NET SDK package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API C# API Reference</p>","title":"Next Steps"},{"location":"go/","text":"<p>The Trinsic Go SDK makes it easy to interact with the Trinsic API from any Go application. The most recent version of the library can be found on ____. You can find the SDKs source on Github.</p>","title":"The Trinsic Go SDK"},{"location":"go/#installation-and-configuration","text":"<ul> <li>NOTE: Windows installation is possible, but requires jumping through a few hoops. More details to come later.</li> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>You need to have CGO configured for the okapi native binary link</li> <li>Issue the following command: <pre><code>go install github.com/trinsic-id/sdk/go@latest\n</code></pre></li> <li>To test the installation, try the following go code:</li> </ul> <pre><code>opts, err := sdk.NewServiceOptions()\nif err != nil {\n    panic(\"could not create service options\")\n}\naccountService, err := sdk.NewAccountService(opts)\nif err != nil {\n    panic(\"Account service not created\")\n}\n\nprofile, _, err := accountService.SignIn(context.Background(), &amp;sdkproto.SignInRequest{})\nif err != nil {\n    panic(\"Sign in failed!\")\n}\nfmt.Printf(\"%v\\n\", profile)\n</code></pre>","title":"Installation and Configuration"},{"location":"go/#next-steps","text":"<p>Once the go package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Go API Reference</p>","title":"Next Steps"},{"location":"ios/","text":"<p>The Trinsic Swift SDK makes it easy to interact with the Trinsic API from any application built for iOS, MacCatalyst, or MacOS. The SDK is available for Swift Package Manager and can be added in your dependency section in <code>Package.swift</code> as follows:</p> <pre><code>dependencies: [\n    .package(name: \"Trinsic\", url: \"https://github.com/trinsic-id/sdk-swift\", branch: \"main\")\n],\n</code></pre> <p>You can find more details, source code, and tests for the Swift SDK at trinsic-id/sdk-swift.</p>","title":"The Trinsic Swift SDK"},{"location":"java/","text":"<p>The Trinsic Java SDK makes it easy to interact with the Trinsic API from any Java application. The most recent version of the package is found on the Github Release. You can find the SDKs source on Github.</p>","title":"The Trinsic Java SDK"},{"location":"java/#installation","text":"<ol> <li>Add the <code>urlFile</code> code shown below to your <code>build.gradle</code>.</li> <li>Add the implementations as shown below to your <code>build.gradle</code>.</li> <li>Run <code>gradle build</code> to download the required jar files. This can take some time.</li> </ol>","title":"Installation"},{"location":"java/#configuration","text":"<ol> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>LD_LIBRARY_PATH</code>, even on Windows.</li> </ol>  <p>Note</p> <p>If you want to included the two required Trinsic <code>.jar</code> files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle <code>implementation</code> target as shown below:</p>  <pre><code>def urlFile = { url, name -&gt;\n    File file = new File(\"$buildDir/download/${name}.jar\")\n    file.parentFile.mkdirs()\n    if (!file.exists()) {\n        new URL(url).withInputStream { downloadStream -&gt;\n            file.withOutputStream { fileOut -&gt;\n                fileOut &lt;&lt; downloadStream\n            }\n        }\n    }\n    files(file.absolutePath)\n}\n</code></pre> <pre><code>dependencies {\n    // other dependencies\n    implementation urlFile('https://github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0')\n    implementation urlFile('https://github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1')\n}\n</code></pre>","title":"Configuration"},{"location":"java/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Java API Reference</p>","title":"Next Steps"},{"location":"learn/credentials/","text":"<p></p> <p>\"Verifiable Credentials\", or \"VCs\" are digital documents that conform to the W3C Verifiable Credential Data Model. VCs provide a standard for digitally issuing, holding, and verifying data about a subject. A verifiable credential is a set of tamper-evident claims and metadata that cryptographically prove who issued it.  https://www.w3.org/TR/vc-data-model/</p> <p>Verifiable credentials are unique from other kinds of digital documents because they enable you to verify the following things: </p> <ol> <li>The original issuing entity (the source of the data) </li> <li>It was issued to the entity presenting it (the subject of the data) </li> <li>It hasn't been tampered with (the veracity of the data)</li> <li>Whether the issuer revoked the credential as of a particular point in time (the status of the data)</li> </ol> <p>trust triangle</p>","title":"What are Verifiable Credentials"},{"location":"learn/credentials/#components-of-a-credential","text":"<p>To break down the components of a credential, we'll use a digital driver's license as an example.</p>","title":"Components of a Credential"},{"location":"learn/credentials/#issuer-did","text":"<p>As you can see from the diagram above, a verifier will only accept a credential if they trust its source. For example, in the United States a TSA agent will only let you on an airplane if you present a valid driver's license (or other gov ID); they do this because they trust the DMV or other agency that issued it. In order to validate where a credential came from, verifiers use the issuer's DID.</p> <p>Each new issuer is assigned an issuer DID. The issuer DID acts as a public-facing address or public key. In self-sovereign identity, these DIDs are usually written to a public blockchain, but other locations are possible, too. Each issuer DID has an associated private key which is used to cryptographically \"sign\" each issued credential. In fact, each attribute inside the credential is signed in this manner, allowing the holder of the credential to share only a subset of the attributes when desired. For example, someone could share their name and age from their driver's license without sharing the driver's license number, address, and hair color. Using the issuer DID and straightforward public-private key cryptography, anyone can verify the attributes in the credential were attested to by the issuer. </p>","title":"Issuer DID"},{"location":"learn/credentials/#schema","text":"<p>Each credential needs a template so the data can be shared and interpreted correctly. That template is called a Schema.</p> <p>Schemas are the general structure of the credential. In our example, they tell us what information must be included on the driver's license in order for it to be valid, like Full name, Address, Eye color, etc. </p> <p>In short, they are the attributes that you want to include in this credential.</p>","title":"Schema"},{"location":"learn/credentials/#example","text":"<pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"description\": \"Email\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"emailAddress\": {\n            \"type\": \"string\",\n            \"format\": \"email\"\n            }\n        },\n    \"required\": [\"emailAddress\"],\n    \"additionalProperties\": false\n}\n</code></pre> <p>Schemas are nonproprietary; any issuer can view/use the schemas written by any other issuer.</p> <p>We abstract schema creation away into the same action as creation of a credential template. Keep reading to read how to create a schema and credential template. </p>","title":"Example:"},{"location":"learn/credentials/#verifications","text":"<p>Passes are documents generated from credentials that contain only the information required to be verified. They can be generated in advance or in real-time. Passes minimize the information about you that is shared with third parties.</p> <p>Credentials are signed using BLS keys. These create from the credential fields. </p>","title":"Verifications"},{"location":"learn/ecosystems/","text":"<p>Exchanging credentials often requires many different participants to all communicate and collaborate. Aligning standards and incentives is challenging. </p> <p>We've made it simple to create an ecosystem of participants to all exchange credentials. </p>","title":"Ecosystems"},{"location":"learn/ecosystems/#potential-scenarios","text":"<p>Industry groups, enterprises, and startups who are deploying this technology to multi-party ecosystems. Our focus on building for interoperability, hyper-scalability, and ease of use means you can get to market faster with a better product with Trinsic than any other way. </p> <p>Trust ecosystems are networks of participants that can authenticate to and share data with one another. Trust ecosystems exist all around us, but most are analog and disaggregated. The first trust ecosystems to go digital were payments networks. Visa, MasterCard, etc. introduced a standard mechanism to allow consumers to make purchases with any merchant using credit from any bank. Visa created an enduring business while simultaneously unlocking value for all participants involved.</p> <p>Credit card networks represent only one kind of trust ecosystem. A trust ecosystem at a minimum has the following 4 roles.</p> <ul> <li>Provider - provides the tools and rules to the rest of the participants to ensure a healthy ecosystem, generally through a product experience that is sold to the other participants</li> <li>Issuer - is the source of data that is shared throughout an ecosystem</li> <li>Verifier - consumes data in an ecosystem</li> <li>Holder - holds data, and is generally the subject of the data, in an ecosystem</li> </ul>","title":"Potential Scenarios"},{"location":"learn/ecosystems/#anatomy-of-a-trust-ecosystem","text":"<p>Before diving into the value provided by each participant, it\u2019s helpful to cover how it works at a high level. You may dive deeper into any of these items by clicking into the respective pages. We\u2019ll use the analogy of a payment network to conceptualize the purpose of each component.</p> <p>Wallet - A place to securely store verifiable credentials.</p> <p>Credential - W3C Verifiable Credentials that contain valuable data about a subject. These are signed and issued by an issuer.</p> <p>Pass - A presentation of a verifiable credential that only includes the information required for use case.</p> <p>Underlying Tech - All of the additional standardized technology Trinsic uses to build trust ecosystems.</p>","title":"Anatomy of a Trust Ecosystem"},{"location":"learn/ecosystems/#value-of-trust-ecosystems-to-participants","text":"<p>The first step to successfully building a trust ecosystem that can scale is to identify the value for each of the participants. Here we will elaborate on the value derived by each actor in an ecosystem and how Trinsic\u2019s platform is optimized to help deliver it.</p>","title":"Value of Trust Ecosystems to Participants"},{"location":"learn/ecosystems/#providers","text":"<p>Providers typically already have, or are building, a product or platform to sell to the issuers and verifiers with the goal of creating a sustainable business. </p> <p>Visa, for example, isn\u2019t a currency, a bank, or a merchant. They sell the rails for transaction settlement to banks and merchants to enable the seamless transactions we all enjoy. By taking a small interchange fee, they capture value alongside the banks and merchants and have built a sustainable business.</p> <p>Trinsic is the only company to offer a product tailored specifically for providers. That means instead of patching together various open source components meant for issuers or verifiers, Trinsic offers a product built from the ground-up to accommodate the unique needs of providers. Ultimately, that means providers using Trinsic get to market faster with better products.</p>","title":"Providers"},{"location":"learn/ecosystems/#issuers","text":"<p>Issuers realize value when they extend or augment their existing business operations. By issuing the data they already have in verifiable credential form, they often can increase revenue, reduce verification costs, and improve brand presence. </p> <p>When credit cards were in their infancy, banks began issuing cards because it allowed them to continue their existing business (giving credit) in a new way. Likewise, the issuers that get the most value from verifiable credentials are ones who already have data about people, and simply need to give it to them in a new way (e.g. medical labs who already give paper documents can now give digital form).</p> <p>Trinsic\u2019s platform is optimized to both reduce onboarding costs and add help issuers scale without increasing their costs</p> <ul> <li>Before credit cards banks could offer various consumer loans</li> </ul>","title":"Issuers"},{"location":"learn/ecosystems/#holders","text":"<p>Holders acquire the most convenient way to prove something about themselves digitally, both in-person and online</p> <ul> <li>Before credit cards, consumers needed to pay with paper. Paying with credit meant bespoke processes with each individual retailer (e.g. opening a tab at a bar, creating a Macy\u2019s account, etc). Likewise today our digital identities are all siloed and separate, resulting in a myriad of problems for consumers.</li> </ul>","title":"Holders"},{"location":"learn/ecosystems/#verifiers","text":"<p>Verifiers get instant, trusted authentication and verification without needing to maintain their own infrastructure</p> <ul> <li>Before credit card networks like Visa, merchants needed to issue credit and manage collections in-house if they wanted customers who could buy on credit. Likewise, companies in virtually every industry have compliance, risk, and identity departments where they manage this in-house. Just as Visa turned electronic payments into a simple terminal installation for merchants, so too will trust ecosystems unlock the ability for verifiers of all kinds to focus on their true business without compromising on trust and security.</li> </ul> <p>Like the internet itself, trust over IP represents a massive business opportunity for innovators in all industries. And like the internet itself, the vast majority of the value will be created at the application layer.</p>","title":"Verifiers"},{"location":"learn/intro/","text":"<p>Trinsic is a hosting provider for identity wallets and an SDK for developers that want to interact with them. You can use Trinsic to give your end-users identity wallets and then share, store, and verify data through them.</p>","title":"What is Trinsic?"},{"location":"learn/intro/#wallets","text":"<p>Identity Wallets are secure, partitioned data stores for information that needs to get verified. This normally is a person, but it can also be an organization or a device. </p> <p>You can use Trinsic's platform to invite end-users to create a cloud-hosted identity wallet that can be accessed on any device using multi-factor passwordless authentication. </p> <p>Once created, applications and organizations can issue data to the identity wallet. Other applications can request to verify information from the wallet. If the end-user accepts the request, a proof of the requested information will be created and sent to the requester. </p> <p>Using identity wallets, you can build powerful products that preserve your end-users' privacy without compromising on convenience.</p> <p>Wallet Service</p>","title":"Wallets"},{"location":"learn/intro/#credentials-proofs","text":"<p>Trinsic's wallets are built to represent verifiable data as credentials. This allows any information sent to the identity wallet to be easily verified using interoperable standards. Because we follow a standardized open data model, identity wallets can bridge software platforms, letting individuals use their data wherever they choose. </p> <p>To minimize the amount of information that is requested from identity wallets, a credential's attributes can be filtered to generate a proof of the credential with only the data required to fulfill a verifier's request.</p> <p>Credential Service</p>","title":"Credentials &amp; Proofs"},{"location":"learn/intro/#templates","text":"<p>Credential templates let you publish a credential format for others to follow. There are often more than one issuer of the same type of credential, and this allows issuers to reuse the same credential format and share the same attribute types. </p> <p>When data models can be reused, more interoperability can be achieved between different systems. This lets data that previously had to be manually entered via form or sent via custom API integration get automatically exchanged and verified without needing human interaction. </p> <p>Template Service</p>","title":"Templates"},{"location":"learn/intro/#trust-registries","text":"<p>A trust registry is a way for a wallet to publish a list of other wallets that it trusts to issue and verifier credentials. </p> <p>This is useful when building trust without a centralized service or database. If you onboard wallets, it is likely that the wallet holders already have a connection with you. You can publish a list of issuers and verifiers that you've also vetted and onboarded and the wallet holders can reference this list before receiving or sharing their information with another wallet.</p> <p>When verifying a credential, a verifier can cross-reference the issuer's identifier within the credential with a trust registry to ensure it was actually issued by an organization that they trust.</p> <p>Trust Registry Service</p>","title":"Trust Registries"},{"location":"learn/intro/#ecosystems","text":"<p>When creating a product that uses identity wallets, it is useful to have the tools to onboard participants that want to either issue, store, or verify credentials. Trinsic Ecosystems is a set of tools built so you can invite participants to an ecosystem and configure their wallets for them. This makes it possible to quickly go live with a proof of concept or pilot without requiring your ecosystem participants to do any setup or integrations themselves.</p> <p>Provider Service</p>","title":"Ecosystems"},{"location":"learn/intro/#open-standards","text":"<p>Trinsic's technology is all based on open web standards. Our goal is to promote a future of applications where identity and personal data is independent from applications. To meet this end, we use decentralized identifiers that can be generated and resolved without needing a centralized database. We also follow the data model for verifiable credentials so that data sent by one application can be presented at another without requiring a specific vendor. </p> <p>Learn More</p>","title":"Open Standards"},{"location":"learn/intro/#security-and-privacy","text":"<p>As a hosting provider of identity wallets, we've recognized the need for strong security and privacy since before we started building. </p> <p>Our identity wallets are secured using zero knowledge authentication. No private keys are stored or processed on our servers. They are all generated locally by our SDKs. We do this using a lightweight zero-knowledge proof protocol. Even if an adversary were to intercept a payload, they would not be able to reuse the token to gain additional access to our system.</p> <p>Learn More</p>","title":"Security and Privacy"},{"location":"learn/security/","text":"","title":"Security Infrastructure"},{"location":"learn/security/#overview","text":"<p>Our cloud services are secured using a novel method of authentication based on zero-knowledge proofs . This approach allows us to introduce passwordless client authentication with improved security and user experience.</p> <p>Compared to traditional security methods that store users' credentials on the server, our approach relies on a one-time client/server negotiation without storing any user secrets on our servers. All secrets are stored with the user client and are entirely in their control. During authentication, users present proof of knowledge of these secret tokens, instead of the actual tokens. This proof is generated with each request and is unique for that request only.</p>","title":"Overview"},{"location":"learn/security/#zero-knowledge-architecture","text":"<p>TODO: Comparison to traditional security models</p>","title":"Zero-knowledge Architecture"},{"location":"learn/security/#oberon-auth-scheme","text":"<p>A succinct ZKP protocol for authentication. It works by using techniques similar to Identity-Based/Attribute-Based signatures.</p> <p>Oberon allows endpoints to issue multi-factor capable tokens to consumers who can prove their validity without disclosing the tokens themselves and without requiring email, SMS, or authenticator apps. Endpoints only need to store a single public key and not any tokens. An attacker that breaks into the server doesn't have any password/token files to steal and only would see a public key. The proof of token validity is only 256 bytes while the token itself is only 48 bytes. The issuing party and verifying servers can be separate entities.</p> <p>Crypto details for Oberon </p>","title":"Oberon Auth Scheme"},{"location":"learn/security/#account-registration","text":"<p>The below diagram illustrates how client and server interact during the registration process and negotiate the data for authentication:</p> <pre><code>sequenceDiagram\n  actor Client\n  Client-&gt;&gt;Server: Register new account or ecosystem\n  Server--&gt;&gt;Client: Generated token\n  Note right of Server: Does not store token\n  opt\n    Note over Client: Apply multi-factor security&lt;br /&gt;using PIN, word phrase, HSM, etc.&lt;br /&gt;by cryptographically blinding&lt;br/&gt;the secret token\n    Client-&gt;&gt;Client: Token protection\n  end\n  Client-&gt;&gt;Client: Save token on client device</code></pre>","title":"Account Registration"},{"location":"learn/security/#api-requests","text":"<p>The process of making authenticated API requests against the server involves generating a proof of knowledge and appending it to the request headers. This proof is:</p> <ul> <li>valid for a limited time only (order of milliseconds)</li> <li>unique and cannot be used twice (replay protection)</li> <li>bound to the current request payload (mitm protection)</li> </ul> <p>The diagram below illustrates the steps involved in generating proof and interacting with the server.</p> <pre><code>sequenceDiagram\n    actor U as Client\n    participant A as Server\n\n    U-&gt;&gt;U: Read Token\n    U-&gt;&gt;U: Generate proof of token\n    U-&gt;&gt;A: Make API Request\n    note right of U: Proof is added in 'Authorization' header\n\n    A-&gt;&gt;A: Check authorization\n\n    alt sucesss\n        A-&gt;&gt;A: Process request\n        A--&gt;&gt;U: Send response\n    else invalid proof\n        A--&gt;&gt;U: 401 Unauthorized\n    end</code></pre>","title":"API Requests"},{"location":"learn/standards/","text":"","title":"Underlying Tech"},{"location":"learn/standards/#linked-data","text":"<p>When we consider credentials getting exchanged online far and wide, a problem starts to occur - how does everyone know what every else means when they show a credential? To the rescue comes Linked Data, a format for representing structured data with self-contained descriptors of that data.</p> <p>\"Linked data is to spreadsheets and databases what the web of hypertext documents is to word processor files\" - W3C Wiki on Linked Data</p>","title":"Linked Data"},{"location":"learn/standards/#decentralized-identifiers","text":"<p>Taken from the Verifiable Credential Data Model, a decentralized identifier is \"a portable URL-based identifier, also known as a DID, associated with an entity. These identifiers are most often used in a verifiable credential and are associated with subjects such that a verifiable credential itself can be easily ported from one repository to another without the need to reissue the credential. An example of a DID is <code>did:example:123456abcdef</code>\"</p>","title":"Decentralized Identifiers"},{"location":"learn/standards/#zero-knowledge-proofs","text":"<p>One of the most exciting qualities of verifiable credentials are their ability to minimize the data shared about you when you prove who you are. The classic example is showing your driver's license in a bar. While a human bouncer may forget all the revealing information on your driver's license, a computerized bouncer that scans your driver's license never forgets any information. With zero knowledge proofs, you can choose specific information from your credentials to share with verifiers.</p> <p>These are enabled through a BBS+ Signature specification.</p>","title":"Zero Knowledge Proofs"},{"location":"learn/templates/","text":"<p>Trinsic's credential templates make it easy to define types of credentials and publish these types for multiple issuers all to use. Credential templates will create two things to include in a credential: a json schema and a json ld context. Templates remove all of that complexity and let you define a list of attributes along with the attribute types and descriptions. </p> <p>This an example of a list of attributes that would comprise a credential template: </p> <pre><code>{\n    \"name\": {\n        \"type\": \"string\",\n        \"description\": \"Name of the business\",\n    },\n    \"website\": {\n        \"type\": \"string\",\n        \"description\": \"More information about the business\"\n    },\n    \"rating\":{\n        \"type\": \"number\",\n        \"description\": \"rating on scale of 1-10\",\n        \"optional\": false\n    },\n    \"details\":{\n        \"type\": \"string\",\n        \"description\": \"An individual's last name\",\n        \"optional\": false\n    }\n}\n</code></pre> <p>This will create a Template that has the following structure: <pre><code>TemplateData {\n    id: \"urn:template:alices-local-guides:review\",\n    name: \"Review\",\n    version: 1,\n    fields: {\n        \"name\": TemplateField {\n            description: \"Name of the business\",\n            optional: false,\n            r#type: String,\n        },\n        \"rating\": TemplateField {\n            description: \"rating on scale of 1-10\",\n            optional: false,\n            r#type: Number,\n        },\n        \"details\": TemplateField {\n            description: \"An individual's last name\",\n            optional: false,\n            r#type: String,\n        },\n        \"website\": TemplateField {\n            description: \"More information about the business\",\n            optional: false,\n            r#type: String,\n        },\n    },\n    allow_additional_fields: true,\n    schema_uri: \"https://staging-schema.trinsic.cloud/__default/review\",\n    context_uri: \"https://staging-schema.trinsic.cloud/__default/review/context\",\n    ecosystem_id: \"__default\",\n    r#type: \"VerifiableCredential\",\n}\n</code></pre> You can view the <code>schema_uri</code> and the <code>context_uri</code> in the browser as raw json</p>","title":"Credential Templates"},{"location":"learn/wallets/","text":"","title":"Wallets"},{"location":"learn/wallets/#what-are-wallets","text":"<p>A wallet is a secure place to store credentials. You can create a wallet using the Trinsic CLI or SDK and begin using it to store and share credentials.  Wallet storage is scoped to a single person or subject. Each wallet has the capability to store and share credentials and proofs. A provider wallet can also define templates, create an ecosystem governance framework, and invite wallets to their ecosystem. </p> <p>Data wallets are meant to help individuals manage their digital credentials and cryptographic keys. </p>","title":"What are wallets?"},{"location":"learn/wallets/#how-to-use-wallets-in-your-app","text":"<p>Instead of users creating accounts when they sign up for your app, users can instead connect their wallet. Because many users will be first-time wallet holders, if a user is signing up for your app and they don't have a wallet, we make it easy to create new wallets for your users with the <code>invite</code> command. Once you've invited a user to a wallet, they can enter the 2fa code to log in. </p> <p>You can give each of your end-users a wallet tied to their email address or phone number. </p>","title":"How to use wallets in your app"},{"location":"learn/wallets/#wallet-architecture","text":"<p>While wallets are hosted on our server, your client application must connect with the wallet (using device stored keys). Wallet communication is peer to peer. </p> <p>Wallets can be thought of a little like an email inbox. Each wallet can only be accessed by a set of keys stored on devices. </p>","title":"Wallet Architecture"},{"location":"learn/wallets/#commands","text":"<ul> <li>Store Item</li> <li>Search</li> <li>Send</li> </ul>","title":"Commands"},{"location":"node/","text":"<p>The Trinsic Node SDK makes it easy to interact with the Trinsic API from any backend javascript application. The most recent version of the library can be found on npm. You can find the SDKs source on Github.</p>","title":"The Trinsic Javascript / Node SDK"},{"location":"node/#installation","text":"<p>Install the package for Node from npmjs.com </p> Install   <pre><code>npm i @trinsic/trinsic\n</code></pre>","title":"Installation"},{"location":"node/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference.</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"},{"location":"python/","text":"<p>The Trinsic Python SDK makes it easy to interact with the Trinsic API from any Python application. The most recent version of the library can be found on PyPi. You can find the SDKs source on Github.</p>","title":"The Trinsic Python SDK"},{"location":"python/#installation-and-configuration","text":"<ul> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>LD_LIBRARY_PATH</code>, even on Windows.</li> <li>Recommended: Create a virtual environment</li> <li>Install the trinsic package <pre><code>pip install trinsic-sdk\n</code></pre></li> <li>Test installation by running the following python script:</li> </ul> <pre><code>import asyncio\nfrom trinsic.services import AccountService\n\nasync def demo():\n    account_service = AccountService()\n    profile = await account_service.sign_in()\n    print(profile)\n    account_service.close()\nif __name__ == \"__main__\":\n    asyncio.run(demo())\n</code></pre> <ul> <li>The output should look something like this: <pre><code>AccountProfile(profile_type='https://trinsic.id/security/v1/oberon', auth_data=b'\\n*urn:trinsic:wallets:JkhchLXS8NDwTjmJjNogkQ\\x12$1d58106c-325a-4f45-abe0-6a14aa613a10', auth_token=b'\\x83E\\x06p\\xd60V\\xe0D\\x12NU\\xe7\\n6\\x06\\x19 \\x0b\\xe0\\x8er\\xf2\\xc1\\xb3\\x96\\xdb\\xbd/\\xf5#\\xa7\\xe7F\\x10\\x97E\\xe2\\xa9\\xc4\\x10\\xdfJ\\xbe\\xea\\xa3Fz', protection=TokenProtection())\n</code></pre></li> </ul>","title":"Installation and Configuration"},{"location":"python/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API Python API Reference</p>","title":"Next Steps"},{"location":"reference/","text":"<p>If you are ready to begin integrating the SDK, make sure you have an SDK installed and configured. You can install each SDK by following the instructions in each page under Build in the sidebar.</p> <p>When using the SDK, you can pass parameters to the default service constructors and use the provided methods to set different active profiles.</p>","title":"Overview"},{"location":"reference/#authorization","text":"<p>See our security section for more information on how we have implemented wallet authentication and authorization.</p>","title":"Authorization"},{"location":"reference/#sdk-services","text":"<p>Our SDK is broken down into the following services:</p> <ul> <li>Account Service</li> <li>Wallet Service</li> <li>Credential Service</li> <li>Trust Registry Service</li> <li>Template Service</li> <li>Provider Service</li> </ul>","title":"SDK Services"},{"location":"reference/proto/","text":"<p></p>","title":"Protocol Documentation"},{"location":"reference/proto/#table-of-contents","text":"<ul> <li> <p>pbmse/v1/pbmse.proto</p> <ul> <li>EncryptedMessage</li> <li>EncryptionHeader</li> <li>EncryptionRecipient</li> <li>Signature</li> <li>SignatureHeader</li> <li> <p>SignedMessage</p> </li> <li> <p>EncryptionAlgorithm</p> </li> <li>EncryptionMode</li> </ul> </li> <li> <p>sdk/options/v1/options.proto</p> <ul> <li>ServiceOptions</li> </ul> </li> <li> <p>services/account/v1/account.proto</p> <ul> <li>AccountDetails</li> <li>AccountEcosystem</li> <li>AccountProfile</li> <li>InfoRequest</li> <li>InfoResponse</li> <li>ListDevicesRequest</li> <li>ListDevicesResponse</li> <li>RevokeDeviceRequest</li> <li>RevokeDeviceResponse</li> <li>SignInRequest</li> <li>SignInResponse</li> <li> <p>TokenProtection</p> </li> <li> <p>ConfirmationMethod</p> </li> <li> <p>Account</p> </li> </ul> </li> <li> <p>services/common/v1/common.proto</p> <ul> <li>Nonce</li> <li> <p>ServerConfig</p> </li> <li> <p>ResponseStatus</p> </li> <li> <p>Common</p> </li> </ul> </li> <li> <p>services/debug/v1/debug.proto</p> <ul> <li>Debugging</li> </ul> </li> <li> <p>services/provider/v1/provider.proto</p> <ul> <li>CreateEcosystemRequest</li> <li>CreateEcosystemResponse</li> <li>Ecosystem</li> <li>GenerateTokenRequest</li> <li>GenerateTokenResponse</li> <li>InvitationStatusRequest</li> <li>InvitationStatusResponse</li> <li>Invite</li> <li>InviteRequest</li> <li>InviteRequest.DidCommInvitation</li> <li> <p>InviteResponse</p> </li> <li> <p>InvitationStatusResponse.Status</p> </li> <li> <p>ParticipantType</p> </li> <li> <p>Provider</p> </li> </ul> </li> <li> <p>services/trust-registry/v1/trust-registry.proto</p> <ul> <li>AddFrameworkRequest</li> <li>AddFrameworkResponse</li> <li>CheckIssuerStatusRequest</li> <li>CheckIssuerStatusResponse</li> <li>CheckVerifierStatusRequest</li> <li>CheckVerifierStatusResponse</li> <li>FetchDataRequest</li> <li>FetchDataResponse</li> <li>GovernanceFramework</li> <li>RegisterIssuerRequest</li> <li>RegisterIssuerResponse</li> <li>RegisterVerifierRequest</li> <li>RegisterVerifierResponse</li> <li>RemoveFrameworkRequest</li> <li>RemoveFrameworkResponse</li> <li>SearchRegistryRequest</li> <li>SearchRegistryResponse</li> <li>UnregisterIssuerRequest</li> <li>UnregisterIssuerResponse</li> <li>UnregisterVerifierRequest</li> <li> <p>UnregisterVerifierResponse</p> </li> <li> <p>RegistrationStatus</p> </li> <li> <p>TrustRegistry</p> </li> </ul> </li> <li> <p>services/universal-wallet/v1/universal-wallet.proto</p> <ul> <li>DeleteItemRequest</li> <li>DeleteItemResponse</li> <li>GetItemRequest</li> <li>GetItemResponse</li> <li>InsertItemRequest</li> <li>InsertItemResponse</li> <li>SearchRequest</li> <li>SearchResponse</li> <li>UpdateItemRequest</li> <li> <p>UpdateItemResponse</p> </li> <li> <p>UniversalWallet</p> </li> </ul> </li> <li> <p>services/verifiable-credentials/templates/v1/templates.proto</p> <ul> <li>CreateCredentialTemplateRequest</li> <li>CreateCredentialTemplateRequest.FieldsEntry</li> <li>CreateCredentialTemplateResponse</li> <li>DeleteCredentialTemplateRequest</li> <li>DeleteCredentialTemplateResponse</li> <li>GetCredentialTemplateRequest</li> <li>GetCredentialTemplateResponse</li> <li>GetTemplateRequest</li> <li>GetTemplateResponse</li> <li>ListCredentialTemplatesRequest</li> <li>ListCredentialTemplatesResponse</li> <li>ListTemplatesRequest</li> <li>ListTemplatesResponse</li> <li>SearchCredentialTemplatesRequest</li> <li>SearchCredentialTemplatesResponse</li> <li>TemplateData</li> <li>TemplateData.FieldsEntry</li> <li> <p>TemplateField</p> </li> <li> <p>FieldType</p> </li> <li> <p>CredentialTemplates</p> </li> </ul> </li> <li> <p>services/verifiable-credentials/v1/verifiable-credentials.proto</p> <ul> <li>CheckStatusRequest</li> <li>CheckStatusResponse</li> <li>CreateProofRequest</li> <li>CreateProofResponse</li> <li>IssueFromTemplateRequest</li> <li>IssueFromTemplateResponse</li> <li>IssueRequest</li> <li>IssueResponse</li> <li>SendRequest</li> <li>SendResponse</li> <li>UpdateStatusRequest</li> <li>UpdateStatusResponse</li> <li>VerifyProofRequest</li> <li> <p>VerifyProofResponse</p> </li> <li> <p>VerifiableCredential</p> </li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>","title":"Table of Contents"},{"location":"reference/proto/#pbmsev1pbmseproto","text":"<p></p>","title":"pbmse/v1/pbmse.proto"},{"location":"reference/proto/#encryptedmessage","text":"Field Type Label Description     iv bytes     aad bytes     ciphertext bytes     tag bytes     recipients EncryptionRecipient repeated     <p></p>","title":"EncryptedMessage"},{"location":"reference/proto/#encryptionheader","text":"Field Type Label Description     mode EncryptionMode     algorithm EncryptionAlgorithm     key_id string     sender_key_id string      <p></p>","title":"EncryptionHeader"},{"location":"reference/proto/#encryptionrecipient","text":"Field Type Label Description     header EncryptionHeader     content_encryption_key bytes      <p></p>","title":"EncryptionRecipient"},{"location":"reference/proto/#signature","text":"Field Type Label Description     header bytes     signature bytes      <p></p>","title":"Signature"},{"location":"reference/proto/#signatureheader","text":"Field Type Label Description     algorithm string     key_id string      <p></p>","title":"SignatureHeader"},{"location":"reference/proto/#signedmessage","text":"<p>JWS Protocol buffer message signing and encryption</p>    Field Type Label Description     payload bytes     signatures Signature repeated     <p></p>","title":"SignedMessage"},{"location":"reference/proto/#encryptionalgorithm","text":"Name Number Description     ENCRYPTION_ALGORITHM_UNSPECIFIED 0    ENCRYPTION_ALGORITHM_XCHACHA20POLY1305 1    ENCRYPTION_ALGORITHM_AES_GCM 2     <p></p>","title":"EncryptionAlgorithm"},{"location":"reference/proto/#encryptionmode","text":"Name Number Description     ENCRYPTION_MODE_UNSPECIFIED 0    ENCRYPTION_MODE_DIRECT 1    ENCRYPTION_MODE_CONTENT_ENCRYPTION_KEY 2     <p></p> <p>Top</p>","title":"EncryptionMode"},{"location":"reference/proto/#sdkoptionsv1optionsproto","text":"<p></p>","title":"sdk/options/v1/options.proto"},{"location":"reference/proto/#serviceoptions","text":"<p>service options</p>    Field Type Label Description     server_endpoint string  service endpoint   server_port int32  service port   server_use_tls bool  indicates if tls is used   auth_token string  default auth token for oberon security scheme   default_ecosystem string  ecosystem to use with endpoints that require it    <p></p> <p>Top</p>","title":"ServiceOptions"},{"location":"reference/proto/#servicesaccountv1accountproto","text":"<p></p>","title":"services/account/v1/account.proto"},{"location":"reference/proto/#accountdetails","text":"<p>Account Registration Details</p>    Field Type Label Description     name string  Account name (optional)   email string  Email account (required)   sms string  SMS number including country code (optional)    <p></p>","title":"AccountDetails"},{"location":"reference/proto/#accountecosystem","text":"Field Type Label Description     id string     name string     description string     uri string      <p></p>","title":"AccountEcosystem"},{"location":"reference/proto/#accountprofile","text":"<p>Device profile containing sensitive authentication data. This information should be stored securely</p>    Field Type Label Description     profile_type string  The type of profile, used to differentiate between protocol schemes or versions   auth_data bytes  Auth data containg information about the current device access   auth_token bytes  Secure token issued by server used to generate zero-knowledge proofs   protection TokenProtection  Token security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.    <p></p>","title":"AccountProfile"},{"location":"reference/proto/#inforequest","text":"<p></p>","title":"InfoRequest"},{"location":"reference/proto/#inforesponse","text":"Field Type Label Description     details AccountDetails  The account details associated with the calling request context   ecosystems AccountEcosystem repeated any ecosystems the account has access to    <p></p>","title":"InfoResponse"},{"location":"reference/proto/#listdevicesrequest","text":"<p></p>","title":"ListDevicesRequest"},{"location":"reference/proto/#listdevicesresponse","text":"<p></p>","title":"ListDevicesResponse"},{"location":"reference/proto/#revokedevicerequest","text":"<p></p>","title":"RevokeDeviceRequest"},{"location":"reference/proto/#revokedeviceresponse","text":"<p></p>","title":"RevokeDeviceResponse"},{"location":"reference/proto/#signinrequest","text":"<p>Request for creating new account</p>    Field Type Label Description     details AccountDetails  Account registration details   invitation_code string  Invitation code associated with this registration This field is optional.   ecosystem_id string  EcosystemId to sign in. This field is optional and will be ignored if invitation_code is passed    <p></p>","title":"SignInRequest"},{"location":"reference/proto/#signinresponse","text":"<p>Response for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc.</p>    Field Type Label Description     status services.common.v1.ResponseStatus  The status of the response   confirmation_method ConfirmationMethod  Indicates if confirmation of account is required. This settings is configured globally by the server administrator.   profile AccountProfile  Contains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data.    <p></p>","title":"SignInResponse"},{"location":"reference/proto/#tokenprotection","text":"<p>Token protection info</p>    Field Type Label Description     enabled bool  Indicates if token is protected using a PIN, security code, HSM secret, etc.   method ConfirmationMethod  The method used to protect the token    <p></p>","title":"TokenProtection"},{"location":"reference/proto/#confirmationmethod","text":"<p>Confirmation method type for two-factor workflows</p>    Name Number Description     None 0 No confirmation required   Email 1 Email confirmation required   Sms 2 SMS confirmation required   ConnectedDevice 3 Confirmation from a connected device is required   Other 10 Indicates third-party method of confirmation is required    <p></p>","title":"ConfirmationMethod"},{"location":"reference/proto/#account","text":"Method Name Request Type Response Type Description     SignIn SignInRequest SignInResponse Sign in to an already existing account    <p>rpc SIgnInConfirm (SignInConfirmRequest) returns (SignInConfirmResponse); | | Info | InfoRequest | InfoResponse | Get account information | | ListDevices | ListDevicesRequest | ListDevicesResponse | List all connected devices | | RevokeDevice | RevokeDeviceRequest | RevokeDeviceResponse | Revoke device access to the account's cloud wallet |</p> <p></p> <p>Top</p>","title":"Account"},{"location":"reference/proto/#servicescommonv1commonproto","text":"<p></p>","title":"services/common/v1/common.proto"},{"location":"reference/proto/#nonce","text":"<p>Nonce used to generate an oberon proof</p>    Field Type Label Description     timestamp int64  UTC unix millisecond timestamp the request was made   request_hash bytes  blake3256 hash of the request body    <p></p>","title":"Nonce"},{"location":"reference/proto/#serverconfig","text":"Field Type Label Description     endpoint string  service endpoint   port int32  service port   use_tls bool  indicates if tls is used    <p></p>","title":"ServerConfig"},{"location":"reference/proto/#responsestatus","text":"Name Number Description     SUCCESS 0    WALLET_ACCESS_DENIED 10    WALLET_EXISTS 11    ITEM_NOT_FOUND 20    SERIALIZATION_ERROR 200    UNKNOWN_ERROR 100     <p></p>","title":"ResponseStatus"},{"location":"reference/proto/#common","text":"Method Name Request Type Response Type Description     Request .pbmse.v1.EncryptedMessage .pbmse.v1.EncryptedMessage     <p></p> <p>Top</p>","title":"Common"},{"location":"reference/proto/#servicesdebugv1debugproto","text":"<p></p>","title":"services/debug/v1/debug.proto"},{"location":"reference/proto/#debugging","text":"Method Name Request Type Response Type Description     CallEmpty .google.protobuf.Empty .google.protobuf.Empty    CallEmptyAuth .google.protobuf.Empty .google.protobuf.Empty     <p></p> <p>Top</p>","title":"Debugging"},{"location":"reference/proto/#servicesproviderv1providerproto","text":"<p></p>","title":"services/provider/v1/provider.proto"},{"location":"reference/proto/#createecosystemrequest","text":"Field Type Label Description     name string  Globally unique name for the Ecosystem. This name will be part of the ecosystem specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen.   description string  Ecosystem description. This field is optional.   uri string  External URL associated with your organization or ecosystem entity. This field is optional   details services.account.v1.AccountDetails  The account details of the owner of the ecosystem    <p></p>","title":"CreateEcosystemRequest"},{"location":"reference/proto/#createecosystemresponse","text":"Field Type Label Description     ecosystem Ecosystem  Details of the created ecosystem   profile services.account.v1.AccountProfile  Account profile for auth of the owner of the ecosystem   confirmation_method services.account.v1.ConfirmationMethod  Indicates if confirmation of account is required. This settings is configured globally by the server administrator.    <p></p>","title":"CreateEcosystemResponse"},{"location":"reference/proto/#ecosystem","text":"Field Type Label Description     id string     name string     description string     uri string      <p></p>","title":"Ecosystem"},{"location":"reference/proto/#generatetokenrequest","text":"Field Type Label Description     description string  Optional description to identify this token    <p></p>","title":"GenerateTokenRequest"},{"location":"reference/proto/#generatetokenresponse","text":"Field Type Label Description     profile services.account.v1.AccountProfile  Account authentication profile that contains unprotected token    <p></p>","title":"GenerateTokenResponse"},{"location":"reference/proto/#invitationstatusrequest","text":"<p>Request details for the status of onboarding an individual or organization. The reference_id passed is the response from the <code>Onboard</code> method call</p>    Field Type Label Description     invitation_id string      <p></p>","title":"InvitationStatusRequest"},{"location":"reference/proto/#invitationstatusresponse","text":"Field Type Label Description     status InvitationStatusResponse.Status     status_details string      <p></p>","title":"InvitationStatusResponse"},{"location":"reference/proto/#invite","text":"Field Type Label Description     id string     code string     created string     accepted string     expires string      <p></p>","title":"Invite"},{"location":"reference/proto/#inviterequest","text":"Field Type Label Description     participant ParticipantType     description string     details services.account.v1.AccountDetails      <p></p>","title":"InviteRequest"},{"location":"reference/proto/#inviterequestdidcomminvitation","text":"<p></p>","title":"InviteRequest.DidCommInvitation"},{"location":"reference/proto/#inviteresponse","text":"Field Type Label Description     status services.common.v1.ResponseStatus     invitation_id string     invitation_code string  Invitation Code that must be passed with the account 'SignIn' request to correlate this user with the invitation sent.    <p></p>","title":"InviteResponse"},{"location":"reference/proto/#invitationstatusresponsestatus","text":"Name Number Description     Error 0 Onboarding resulted in error   InvitationSent 1 The participant has been invited   Completed 2 The participant has been onboarded   Expired 3 The invite has expired    <p></p>","title":"InvitationStatusResponse.Status"},{"location":"reference/proto/#participanttype","text":"Name Number Description     participant_type_individual 0    participant_type_organization 1     <p></p>","title":"ParticipantType"},{"location":"reference/proto/#provider","text":"Method Name Request Type Response Type Description     CreateEcosystem CreateEcosystemRequest CreateEcosystemResponse Create new ecosystem and assign the authenticated user as owner   GenerateToken GenerateTokenRequest GenerateTokenResponse Generates an unprotected authentication token that can be used to configure server side applications   Invite InviteRequest InviteResponse Invite a user to the ecosystem   InvitationStatus InvitationStatusRequest InvitationStatusResponse Check the invitation status    <p></p> <p>Top</p>","title":"Provider"},{"location":"reference/proto/#servicestrust-registryv1trust-registryproto","text":"<p></p>","title":"services/trust-registry/v1/trust-registry.proto"},{"location":"reference/proto/#addframeworkrequest","text":"Field Type Label Description     governance_framework GovernanceFramework      <p></p>","title":"AddFrameworkRequest"},{"location":"reference/proto/#addframeworkresponse","text":"Field Type Label Description     status services.common.v1.ResponseStatus      <p></p>","title":"AddFrameworkResponse"},{"location":"reference/proto/#checkissuerstatusrequest","text":"Field Type Label Description     governance_framework_uri string     did_uri string     x509_cert string     credential_type_uri string      <p></p>","title":"CheckIssuerStatusRequest"},{"location":"reference/proto/#checkissuerstatusresponse","text":"Field Type Label Description     status RegistrationStatus      <p></p>","title":"CheckIssuerStatusResponse"},{"location":"reference/proto/#checkverifierstatusrequest","text":"Field Type Label Description     governance_framework_uri string     did_uri string     x509_cert string     presentation_type_uri string      <p></p>","title":"CheckVerifierStatusRequest"},{"location":"reference/proto/#checkverifierstatusresponse","text":"Field Type Label Description     status RegistrationStatus      <p></p>","title":"CheckVerifierStatusResponse"},{"location":"reference/proto/#fetchdatarequest","text":"Field Type Label Description     governance_framework_uri string     query string      <p></p>","title":"FetchDataRequest"},{"location":"reference/proto/#fetchdataresponse","text":"Field Type Label Description     response_json string     has_more_results bool     continuation_token string      <p></p>","title":"FetchDataResponse"},{"location":"reference/proto/#governanceframework","text":"Field Type Label Description     governance_framework_uri string     trust_registry_uri string     description string      <p></p>","title":"GovernanceFramework"},{"location":"reference/proto/#registerissuerrequest","text":"Field Type Label Description     did_uri string     x509_cert string     credential_type_uri string     valid_from_utc uint64     valid_until_utc uint64     governance_framework_uri string      <p></p>","title":"RegisterIssuerRequest"},{"location":"reference/proto/#registerissuerresponse","text":"Field Type Label Description     status services.common.v1.ResponseStatus      <p></p>","title":"RegisterIssuerResponse"},{"location":"reference/proto/#registerverifierrequest","text":"Field Type Label Description     did_uri string     x509_cert string     presentation_type_uri string     valid_from_utc uint64     valid_until_utc uint64     governance_framework_uri string      <p></p>","title":"RegisterVerifierRequest"},{"location":"reference/proto/#registerverifierresponse","text":"Field Type Label Description     status services.common.v1.ResponseStatus      <p></p>","title":"RegisterVerifierResponse"},{"location":"reference/proto/#removeframeworkrequest","text":"Field Type Label Description     governance_framework GovernanceFramework      <p></p>","title":"RemoveFrameworkRequest"},{"location":"reference/proto/#removeframeworkresponse","text":"Field Type Label Description     status services.common.v1.ResponseStatus      <p></p>","title":"RemoveFrameworkResponse"},{"location":"reference/proto/#searchregistryrequest","text":"Field Type Label Description     query string  SELECT c from c where c.type == 'GovernanceFramework'   continuation_token string      <p></p>","title":"SearchRegistryRequest"},{"location":"reference/proto/#searchregistryresponse","text":"Field Type Label Description     items_json string     has_more bool     count int32     continuation_token string      <p></p>","title":"SearchRegistryResponse"},{"location":"reference/proto/#unregisterissuerrequest","text":"Field Type Label Description     did_uri string     x509_cert string     credential_type_uri string     governance_framework_uri string      <p></p>","title":"UnregisterIssuerRequest"},{"location":"reference/proto/#unregisterissuerresponse","text":"Field Type Label Description     status services.common.v1.ResponseStatus      <p></p>","title":"UnregisterIssuerResponse"},{"location":"reference/proto/#unregisterverifierrequest","text":"Field Type Label Description     did_uri string     x509_cert string     presentation_type_uri string     governance_framework_uri string      <p></p>","title":"UnregisterVerifierRequest"},{"location":"reference/proto/#unregisterverifierresponse","text":"Field Type Label Description     status services.common.v1.ResponseStatus      <p></p>","title":"UnregisterVerifierResponse"},{"location":"reference/proto/#registrationstatus","text":"Name Number Description     CURRENT 0 - the entity is currently authorized, as of time of the query.   EXPIRED 1 - entity rights have expired.   TERMINATED 2 - entity has voluntarily ceased Issuer role under the specific EGF.   REVOKED 3 - entity authority under specific EGF was terminated by the governing authority.   NOT_FOUND 10     <p></p>","title":"RegistrationStatus"},{"location":"reference/proto/#trustregistry","text":"Method Name Request Type Response Type Description     AddFramework AddFrameworkRequest AddFrameworkResponse Adds a trust registry defintion to the ecosystem   RemoveFramework RemoveFrameworkRequest RemoveFrameworkResponse    SearchRegistry SearchRegistryRequest SearchRegistryResponse    RegisterIssuer RegisterIssuerRequest RegisterIssuerResponse Registers an authoritative issuer with a credential template   RegisterVerifier RegisterVerifierRequest RegisterVerifierResponse Registers an authoritative verifier with a credential template   UnregisterIssuer UnregisterIssuerRequest UnregisterIssuerResponse Removes an authoritative issuer with a credential template from the trust registry   UnregisterVerifier UnregisterVerifierRequest UnregisterVerifierResponse Removes an authoritative verifier with a presentation template from the trust registry   CheckIssuerStatus CheckIssuerStatusRequest CheckIssuerStatusResponse    CheckVerifierStatus CheckVerifierStatusRequest CheckVerifierStatusResponse    FetchData FetchDataRequest FetchDataResponse stream     <p></p> <p>Top</p>","title":"TrustRegistry"},{"location":"reference/proto/#servicesuniversal-walletv1universal-walletproto","text":"<p></p>","title":"services/universal-wallet/v1/universal-wallet.proto"},{"location":"reference/proto/#deleteitemrequest","text":"<p>Delete item request</p>    Field Type Label Description     item_id string  item identifier of the record to delete    <p></p>","title":"DeleteItemRequest"},{"location":"reference/proto/#deleteitemresponse","text":"<p>Delete item response</p>    Field Type Label Description     status services.common.v1.ResponseStatus      <p></p>","title":"DeleteItemResponse"},{"location":"reference/proto/#getitemrequest","text":"<p>Get item request object</p>    Field Type Label Description     item_id string  The item identifier    <p></p>","title":"GetItemRequest"},{"location":"reference/proto/#getitemresponse","text":"<p>Get item response object</p>    Field Type Label Description     item_json string  The item data represented as stringified JSON   item_type string  User set item type that described the content of this item    <p></p>","title":"GetItemResponse"},{"location":"reference/proto/#insertitemrequest","text":"<p>Insert item request</p>    Field Type Label Description     item_json string  the document to insert as stringified json   item_type string  optional item type ex. \"VerifiableCredential\"    <p></p>","title":"InsertItemRequest"},{"location":"reference/proto/#insertitemresponse","text":"<p>Insert item response</p>    Field Type Label Description     status services.common.v1.ResponseStatus     item_id string  The item identifier of the inserted record    <p></p>","title":"InsertItemResponse"},{"location":"reference/proto/#searchrequest","text":"<p>Search request object</p>    Field Type Label Description     query string     continuation_token string      <p></p>","title":"SearchRequest"},{"location":"reference/proto/#searchresponse","text":"<p>Search response object</p>    Field Type Label Description     items string repeated    has_more bool     count int32     continuation_token string      <p></p>","title":"SearchResponse"},{"location":"reference/proto/#updateitemrequest","text":"<p>Update item request object</p>    Field Type Label Description     item_id string  The item identifier   item_type string  The item type that described the content of this item    <p></p>","title":"UpdateItemRequest"},{"location":"reference/proto/#updateitemresponse","text":"<p>Update item response object</p>    Field Type Label Description     status services.common.v1.ResponseStatus  Response status    <p></p>","title":"UpdateItemResponse"},{"location":"reference/proto/#universalwallet","text":"Method Name Request Type Response Type Description     GetItem GetItemRequest GetItemResponse Retrieve an item from the wallet with a given item identifier   Search SearchRequest SearchResponse Search the wallet using a SQL-like syntax   InsertItem InsertItemRequest InsertItemResponse Insert an item into the wallet   UpdateItem UpdateItemRequest UpdateItemResponse Insert an item into the wallet   DeleteItem DeleteItemRequest DeleteItemResponse Delete an item from the wallet permanently    <p></p> <p>Top</p>","title":"UniversalWallet"},{"location":"reference/proto/#servicesverifiable-credentialstemplatesv1templatesproto","text":"<p></p>","title":"services/verifiable-credentials/templates/v1/templates.proto"},{"location":"reference/proto/#createcredentialtemplaterequest","text":"<p>Request to create new template</p>    Field Type Label Description     name string     fields CreateCredentialTemplateRequest.FieldsEntry repeated    allow_additional_fields bool      <p></p>","title":"CreateCredentialTemplateRequest"},{"location":"reference/proto/#createcredentialtemplaterequestfieldsentry","text":"Field Type Label Description     key string     value TemplateField      <p></p>","title":"CreateCredentialTemplateRequest.FieldsEntry"},{"location":"reference/proto/#createcredentialtemplateresponse","text":"Field Type Label Description     data TemplateData      <p></p>","title":"CreateCredentialTemplateResponse"},{"location":"reference/proto/#deletecredentialtemplaterequest","text":"Field Type Label Description     id string      <p></p>","title":"DeleteCredentialTemplateRequest"},{"location":"reference/proto/#deletecredentialtemplateresponse","text":"<p></p>","title":"DeleteCredentialTemplateResponse"},{"location":"reference/proto/#getcredentialtemplaterequest","text":"Field Type Label Description     id string      <p></p>","title":"GetCredentialTemplateRequest"},{"location":"reference/proto/#getcredentialtemplateresponse","text":"Field Type Label Description     template TemplateData      <p></p>","title":"GetCredentialTemplateResponse"},{"location":"reference/proto/#gettemplaterequest","text":"Field Type Label Description     id string      <p></p>","title":"GetTemplateRequest"},{"location":"reference/proto/#gettemplateresponse","text":"Field Type Label Description     data TemplateData      <p></p>","title":"GetTemplateResponse"},{"location":"reference/proto/#listcredentialtemplatesrequest","text":"Field Type Label Description     query string  SELECT * FROM c WHERE c.name = 'Diploma'   continuation_token string      <p></p>","title":"ListCredentialTemplatesRequest"},{"location":"reference/proto/#listcredentialtemplatesresponse","text":"Field Type Label Description     templates TemplateData repeated    has_more_results bool     continuation_token string      <p></p>","title":"ListCredentialTemplatesResponse"},{"location":"reference/proto/#listtemplatesrequest","text":"<p></p>","title":"ListTemplatesRequest"},{"location":"reference/proto/#listtemplatesresponse","text":"Field Type Label Description     templates TemplateData repeated     <p></p>","title":"ListTemplatesResponse"},{"location":"reference/proto/#searchcredentialtemplatesrequest","text":"Field Type Label Description     query string  SELECT * FROM c WHERE c.name = 'Diploma'   continuation_token string      <p></p>","title":"SearchCredentialTemplatesRequest"},{"location":"reference/proto/#searchcredentialtemplatesresponse","text":"Field Type Label Description     items_json string     has_more bool     count int32     continuation_token string      <p></p>","title":"SearchCredentialTemplatesResponse"},{"location":"reference/proto/#templatedata","text":"Field Type Label Description     id string     name string     version int32     fields TemplateData.FieldsEntry repeated    allow_additional_fields bool     schema_uri string     context_uri string     ecosystem_id string     type string      <p></p>","title":"TemplateData"},{"location":"reference/proto/#templatedatafieldsentry","text":"Field Type Label Description     key string     value TemplateField      <p></p>","title":"TemplateData.FieldsEntry"},{"location":"reference/proto/#templatefield","text":"Field Type Label Description     description string     optional bool     type FieldType      <p></p>","title":"TemplateField"},{"location":"reference/proto/#fieldtype","text":"Name Number Description     STRING 0    NUMBER 1    BOOL 2    DATETIME 4     <p></p>","title":"FieldType"},{"location":"reference/proto/#credentialtemplates","text":"Method Name Request Type Response Type Description     Create CreateCredentialTemplateRequest CreateCredentialTemplateResponse    Get GetCredentialTemplateRequest GetCredentialTemplateResponse    List ListCredentialTemplatesRequest ListCredentialTemplatesResponse    Search SearchCredentialTemplatesRequest SearchCredentialTemplatesResponse    Delete DeleteCredentialTemplateRequest DeleteCredentialTemplateResponse     <p></p> <p>Top</p>","title":"CredentialTemplates"},{"location":"reference/proto/#servicesverifiable-credentialsv1verifiable-credentialsproto","text":"<p></p>","title":"services/verifiable-credentials/v1/verifiable-credentials.proto"},{"location":"reference/proto/#checkstatusrequest","text":"<p>request object to update the status of the revocation entry</p>    Field Type Label Description     credential_status_id string  the credential status id    <p></p>","title":"CheckStatusRequest"},{"location":"reference/proto/#checkstatusresponse","text":"<p>response object for update of status of revocation entry</p>    Field Type Label Description     revoked bool  indicates if the status is revoked    <p></p>","title":"CheckStatusResponse"},{"location":"reference/proto/#createproofrequest","text":"<p>Create Proof</p>    Field Type Label Description     reveal_document_json string  Optional document that describes which fields should be revealed in the generated proof. If specified, this document must be a valid JSON-LD frame. If this field is not specified, a default reveal document will be used and all fields in the signed document will be revealed   item_id string  The item identifier that contains a record with a verifiable credential to be used for generating the proof.   document_json string  A document that contains a valid verifiable credential with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet.    <p></p>","title":"CreateProofRequest"},{"location":"reference/proto/#createproofresponse","text":"Field Type Label Description     proof_document_json string      <p></p>","title":"CreateProofResponse"},{"location":"reference/proto/#issuefromtemplaterequest","text":"Field Type Label Description     template_id string     values_json string      <p></p>","title":"IssueFromTemplateRequest"},{"location":"reference/proto/#issuefromtemplateresponse","text":"Field Type Label Description     document_json string      <p></p>","title":"IssueFromTemplateResponse"},{"location":"reference/proto/#issuerequest","text":"Field Type Label Description     document_json string      <p></p>","title":"IssueRequest"},{"location":"reference/proto/#issueresponse","text":"Field Type Label Description     signed_document_json string      <p></p>","title":"IssueResponse"},{"location":"reference/proto/#sendrequest","text":"Field Type Label Description     email string     did_uri string     didcomm_invitation_json string     document_json string      <p></p>","title":"SendRequest"},{"location":"reference/proto/#sendresponse","text":"Field Type Label Description     status services.common.v1.ResponseStatus      <p></p>","title":"SendResponse"},{"location":"reference/proto/#updatestatusrequest","text":"<p>request object to update the status of the revocation entry</p>    Field Type Label Description     credential_status_id string  the credential status id   revoked bool  indicates if the status is revoked    <p></p>","title":"UpdateStatusRequest"},{"location":"reference/proto/#updatestatusresponse","text":"<p>response object for update of status of revocation entry</p>    Field Type Label Description     status services.common.v1.ResponseStatus      <p></p>","title":"UpdateStatusResponse"},{"location":"reference/proto/#verifyproofrequest","text":"<p>Verify Proof</p>    Field Type Label Description     proof_document_json string      <p></p>","title":"VerifyProofRequest"},{"location":"reference/proto/#verifyproofresponse","text":"Field Type Label Description     is_valid bool  Indicates if the proof is valid   validation_messages string repeated Validation messages that describe invalid verifications based on different factors, such as schema validation, proof verification, revocation registry membership, etc. If the proof is not valid, this field will contain detailed results where this verification failed.    <p></p>","title":"VerifyProofResponse"},{"location":"reference/proto/#verifiablecredential","text":"Method Name Request Type Response Type Description     Issue IssueRequest IssueResponse Sign and issue a verifiable credential from a submitted document. The document must be a valid JSON-LD document.   IssueFromTemplate IssueFromTemplateRequest IssueFromTemplateResponse Sign and issue a verifiable credential from a pre-defined template. This process will also add schema validation and revocation registry entry in the credential.   CheckStatus CheckStatusRequest CheckStatusResponse Check credential status by setting the revocation value   UpdateStatus UpdateStatusRequest UpdateStatusResponse Update credential status by setting the revocation value   CreateProof CreateProofRequest CreateProofResponse Create a proof from a signed document that is a valid verifiable credential and contains a signature from which a proof can be derived.   VerifyProof VerifyProofRequest VerifyProofResponse Verifies a proof by checking the signature value, and if possible schema validation, revocation status, and issuer status against a trust registry   Send SendRequest SendResponse Sends a document directly to a user's email within the given ecosystem","title":"VerifiableCredential"},{"location":"reference/proto/#scalar-value-types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby      double  double double float float64 double float Float    float  float float float float32 float float Float    int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)    int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum    uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)    uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)    sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)    sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum    fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)    fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum    sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)    sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum    bool  bool boolean boolean bool bool boolean TrueClass/FalseClass    string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)    bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Scalar Value Types"},{"location":"reference/services/account-service/","text":"<p>When you need to manage trinsic account, you will most definitely interface with the Account Service. Below you will find information on how to work with the different procedures pertinent to the account service.</p>","title":"Account Service"},{"location":"reference/services/account-service/#construct-instance","text":"<p>If you are using one of Trinsic SDK's, you will need to create an instance of the Account Service in order to use its different procedures/calls. Below you  will find how to instantiate the Account Service with default settings, by simply calling the constructor without passing any parameters.</p> TypeScriptC#PythonGoJavaRuby   <pre><code>const accountService = new AccountService();\n</code></pre>   <pre><code>var myAccountService = new AccountService(_options);\n</code></pre>   <pre><code>account_service = AccountService(server_config=trinsic_config())\n</code></pre>   <pre><code>opts, err := NewServiceOptions(WithTestEnv())\nif !assert2.Nil(err) {\n    return\n}\n\naccountService, err := NewAccountService(opts)\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var accountService = new AccountService(TrinsicUtilities.getTrinsicServiceOptions());\n</code></pre>   <pre><code>account_service = Trinsic::AccountService.new(nil, Trinsic::trinsic_prod_server)\n</code></pre>    <p>The constructor also accepts an <code>options</code> object as an argument. It follows the same structure of ServiceOptions, with the following properties:</p>  <p>ServiceOptions   <p>service options</p>    Field Type Label Description     server_endpoint string  service endpoint   server_port int32  service port   server_use_tls bool  indicates if tls is used   auth_token string  default auth token for oberon security scheme   default_ecosystem string  ecosystem to use with endpoints that require it    <p></p> <p>Top</p>   <p>The exact structure of such object will depend on the language you are working with. You can always rely on your editor's intellisense when in doubt. </p>","title":"Construct Instance"},{"location":"reference/services/account-service/#sign-in","text":"<p>Create login credentials by signing into an existing account or creating a new one. As part of this procedure, you must provide a  Sign In Request object that contains account details information such as name (alias) of the account, email,  and an SMS phone number. You may also provide an invitation code and ecosystem ID if you have them. </p> <p>The sign in request should look like this:</p>  <p>SignInRequest   <p>Request for creating new account</p>    Field Type Label Description     details AccountDetails  Account registration details   invitation_code string  Invitation code associated with this registration This field is optional.   ecosystem_id string  EcosystemId to sign in. This field is optional and will be ignored if invitation_code is passed    <p></p>   <p>And the Account Details object should look like this:</p>  <p>AccountDetails   <p>Account Registration Details</p>    Field Type Label Description     name string  Account name (optional)   email string  Email account (required)   sms string  SMS number including country code (optional)    <p></p>   Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic account login --email &lt;PROFILE_EMAIL&gt; --name &lt;PROFILE_NAME&gt;\n</code></pre>   <pre><code>const allison = (await accountService.signIn()).getProfile();\n</code></pre>   <pre><code>var myProfile = await myAccountService.SignInAsync(new());\n</code></pre>   <pre><code>account_service = AccountService(server_config=trinsic_config())\n</code></pre>   <pre><code>profile, _, err := accountService.SignIn(context.Background(), &amp;sdk.SignInRequest{})\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var myProfile = accountService.signIn().get();\n</code></pre>   <pre><code>allison = account_service.sign_in(nil).profile\n</code></pre>    <p>This operation produces a response that has the structure of a Sign In Response, indicating whether or not a confirmation code was sent to one of the users two-factor methods like email, SMS, etc. (as defined by the Sign In Request).</p>  <p>SignInResponse   <p>Response for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc.</p>    Field Type Label Description     status services.common.v1.ResponseStatus  The status of the response   confirmation_method ConfirmationMethod  Indicates if confirmation of account is required. This settings is configured globally by the server administrator.   profile AccountProfile  Contains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data.    <p></p>","title":"Sign In"},{"location":"reference/services/account-service/#get-account-info","text":"<p>This will returns the account info of the current active profile in the SDK or CLI. This can only be called on a profile that has been  unprotected by providing a code that was sent through email or SMS when the account was  signed in. Its response is a Info Response object and has the following properties:</p>  <p>InfoResponse      Field Type Label Description     details AccountDetails  The account details associated with the calling request context   ecosystems AccountEcosystem repeated any ecosystems the account has access to    <p></p>   <p>Calling this procedure, is as trivial as evidenced below. Keep it mind, however, that it assumes you have the correct profile active.</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic account info\n</code></pre>   <pre><code>const info = await accountService.info();\n</code></pre>   <pre><code>var output = await myAccountService.GetInfoAsync();\n</code></pre>   <pre><code>info = await account_service.get_info()\n</code></pre>   <pre><code>info2, err2 := accountService.GetInfo(context.Background())\n</code></pre>   <pre><code>var info = accountService.getInfo().get();\n</code></pre>   <pre><code>info = account_service.get_info()\n</code></pre>","title":"Get Account Info"},{"location":"reference/services/account-service/#protect-account-profile","text":"<p>Protects the specified account profile blinding its token using oberon. It is not possible to execute this call using the CLI, and the parameters that you must  provide are evidenced in the code snippets below:</p> TypeScriptC#PythonGoJavaRuby   <pre><code>const protectedProfile = await accountService.protect(accountProfile, \"1234\");\n</code></pre>   <pre><code>var securityCode = \"1234\";\nvar myProtectedProfile = AccountService.Protect(myProfile, securityCode);\nvar myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n</code></pre>   <pre><code>code = b\"1234\"\nmy_protected_profile = account_service.protect(\n    profile=my_profile, security_code=code\n)\nwith self.assertRaises(Exception) as ve:\n    await self.print_get_info(account_service, my_protected_profile)\n\nmy_unprotected_profile = account_service.unprotect(\n    profile=my_protected_profile, security_code=code\n)\n</code></pre>   <pre><code>securityCode := \"1234\"\nprotectedProfile, err := accountService.Protect(profile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\nunprotectedProfile, err := accountService.Unprotect(protectedProfile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var code = \"1234\";\nvar myProtectedProfile = AccountService.protect(myProfile, code);\nvar myUnprotectedProfile = AccountService.unprotect(myProtectedProfile, code);\n</code></pre>   <pre><code>protected_profile = account_service.protect(account_profile, '1234')\n</code></pre>","title":"Protect Account Profile"},{"location":"reference/services/account-service/#unprotect-account-profile","text":"<p>Unprotects the specified account profile unblinding its token using oberon. It is not possible to execute this call using the CLI, and the parameters that you must  provide are evidenced in the code snippets below. Keep in mind, that if this account was signed in using protection, you must provide the code you received in the email or SMS as the <code>securityCode</code> argument.</p> TypeScriptC#PythonGoJavaRuby   <pre><code>const accountProfile = await accountService.unprotect(protectedProfile, \"1234\");\n</code></pre>   <pre><code>var securityCode = \"1234\";\nvar myProtectedProfile = AccountService.Protect(myProfile, securityCode);\nvar myUnprotectedProfile = AccountService.Unprotect(myProtectedProfile, securityCode);\n</code></pre>   <pre><code>code = b\"1234\"\nmy_protected_profile = account_service.protect(\n    profile=my_profile, security_code=code\n)\nwith self.assertRaises(Exception) as ve:\n    await self.print_get_info(account_service, my_protected_profile)\n\nmy_unprotected_profile = account_service.unprotect(\n    profile=my_protected_profile, security_code=code\n)\n</code></pre>   <pre><code>securityCode := \"1234\"\nprotectedProfile, err := accountService.Protect(profile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\nunprotectedProfile, err := accountService.Unprotect(protectedProfile, securityCode)\nif !assert2.Nil(err) {\n    return\n}\n</code></pre>   <pre><code>var code = \"1234\";\nvar myProtectedProfile = AccountService.protect(myProfile, code);\nvar myUnprotectedProfile = AccountService.unprotect(myProtectedProfile, code);\n</code></pre>   <pre><code>account_profile = account_service.unprotect(protected_profile, '1234')\n</code></pre>","title":"Unprotect Account Profile"},{"location":"reference/services/credential-service/","text":"<p>The Credentials Service gives you the ability to manage complex workflows related to DIDs (contacts/Connections) and VCs (credential issuance, Revocation, Verification, etc). This is probably the service you will most interact with because VC Issuance and verification are at the core of every SSI use case.</p> <p>The Credential service supports signing data using BBS+ Signatures . The data is signed with a key unique to the owner's wallet. This key is also used as linked secret, when it comes to proof derivation.</p>","title":"Credential Service"},{"location":"reference/services/credential-service/#issue-credential","text":"<pre><code>Issues a credential from a valid JSON-LD document. You can learn more about how creating these documents, and about VC data models in general, from W3C: [VC Data Model v1.1](https://www.w3.org/TR/vc-data-model/).\n\n**`IssueCredential` requires a valid JSON-LD document to be provided**. Do not confuse this operation with [Issue Credential From Template](./credential-service.md#issue-credential-from-template).\n</code></pre> Trinsic CLI   <pre><code>trinsic vc issue --document &lt;JSONLD_FILE&gt; --out &lt;OUTPUT_FILE&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Issue Request object. This object follows the model below:</p>  <p>IssueRequest      Field Type Label Description     document_json string      <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>// Sign a credential as the clinic and send it to Allison\nconst credentialJson = getVaccineCertUnsignedJSON()\nconst credential = await credentialService.issueCredential(new IssueRequest()\n    .setDocumentJson(JSON.stringify(credentialJson)));\n</code></pre>   <pre><code>var credential = await credentialsService.IssueCredentialAsync(new() {DocumentJson = credentialJson});\n_testOutputHelper.WriteLine($\"Credential:\\n{credential.SignedDocumentJson}\");\n</code></pre>   <pre><code>issue_response = await credentials_service.issue_credential(\n    request=IssueRequest(document_json=credential_json)\n)\n</code></pre>   <pre><code>credential, err := credentialService.IssueCredential(context.Background(), &amp;sdk.IssueRequest{DocumentJson: string(fileContent)})\n</code></pre>   <pre><code>var issueResult = credentialsService.issueCredential(VerifiableCredentials.IssueRequest.newBuilder().setDocumentJson(credentialJson).build()).get();\n</code></pre>    <p>The output of this method will be a signed JSON document using BBS+ Signature Suite 2020. This document is not automatically stored in the wallet when issued. You need to call the insert record separately if you'd like to store a copy of this document.</p> <p>The response model is of type Issue Response:</p>  <p>IssueResponse      Field Type Label Description     signed_document_json string      <p></p>","title":"Issue Credential"},{"location":"reference/services/credential-service/#issue-credential-from-template","text":"<p>Issues a credential from a previously defined template through CreateCredential call. The template is specified by passing a JSON document that matches the structure of the template. For example:</p> <pre><code>{\n    \"field1\": \"value1\",\n    \"field2\": \"value2\",\n    ...\n}\n</code></pre> <p>Do not confuse this operation with Issue Credential where JSON-LD document is required..</p> Trinsic CLI   <pre><code>trinsic vc issue-from-template [OPTIONS] --template-id &lt;ID&gt;\n\n# OPTIONS\n# --out &lt;OUTPUT_FILE&gt;     (Optional) Output file to store the issued credential\n# --values-data &lt;JSON&gt;    The JSON values of the credential subject\n# --values-file &lt;FILE&gt;    The file with JSON values of the credential subject\n</code></pre>    <p>When using one of the SDKs, you must supply an Issue From Template Request object. This object follows the model below:</p>  <p>IssueFromTemplateRequest      Field Type Label Description     template_id string     values_json string      <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>let request = new IssueFromTemplateRequest()\n  .setTemplateId(templateResponse?.getData()?.getId() ?? \"\")\n  .setValuesJson(JSON.stringify({\n    \"name\": \"Alice\",\n    \"numberOfBags\": 2,\n    \"dateOfBirth\": new Date(\"1/1/2000\").toISOString(),\n    \"vaccinated\": true\n  }));\n\nlet response = await service.issueFromTemplate(request);\n</code></pre>   <pre><code>var credentialJson = await credentialService.IssueFromTemplateAsync(new() {\n    TemplateId = template.Data.Id,\n    ValuesJson = values\n});\n</code></pre>   <pre><code>values = json.dumps({\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"age\": 42})\nissue_response = await credential_service.issue_from_template(\n    request=IssueFromTemplateRequest(\n        template_id=template.data.id, values_json=values\n    )\n)\n</code></pre>   <pre><code>credentialJSON, err := credentialService.IssueFromTemplate(context.Background(), &amp;sdk.IssueFromTemplateRequest{\n    TemplateId: template.Data.Id,\n    ValuesJson: string(valuesString),\n})\n</code></pre>   <pre><code>var valuesMap = new HashMap&lt;String, Object&gt;();\nvaluesMap.put(\"firstName\", \"Jane\");\nvaluesMap.put(\"lastName\", \"Doe\");\nvaluesMap.put(\"age\", 42);\nvar valuesJson = new Gson().toJson(valuesMap);\nvar issueResponse = credentialService.issueCredentialFromTemplate(VerifiableCredentials.IssueFromTemplateRequest.newBuilder().setTemplateId(template.getData().getId()).setValuesJson(valuesJson).build()).get();\n</code></pre>    <p>The output of this method will be a signed JSON document using BBS+ Signature Suite 2020. This document is not automatically stored in the wallet when issued. You need to call the insert record separately if you'd like to store a copy of this document.</p> <p>The response model is of type Issue From Template Response:</p>  <p>IssueFromTemplateResponse      Field Type Label Description     document_json string      <p></p>","title":"Issue Credential from Template"},{"location":"reference/services/credential-service/#check-revocation-status","text":"<p>Get the credential status (revocation) of a previously issued credential. You must supply the credential id to this call.</p> Trinsic CLI   <pre><code>trinsic vc get-status --credential-status-id &lt;ID&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Check Status Request object. This object follows the model below:</p>  <p>CheckStatusRequest   <p>request object to update the status of the revocation entry</p>    Field Type Label Description     credential_status_id string  the credential status id    <p></p>   <p>Then you can supply it to SDK:</p> C#PythonGoJava   <pre><code>var checkResponse = await credentialService.CheckStatusAsync(new() {CredentialStatusId = \"\"});\n</code></pre>   <pre><code>check_response = await credential_service.check_status(\n    request=CheckStatusRequest(credential_status_id=\"\")\n)\n</code></pre>   <pre><code>status, err := credentialService.CheckStatus(context.Background(), &amp;sdk.CheckStatusRequest{CredentialStatusId: \"\"})\n</code></pre>   <pre><code>var checkStatusResponse = credentialService.checkStatus(VerifiableCredentials.CheckStatusRequest.newBuilder().build()).get();\n</code></pre>    <p>The response model is of type Check Status Response:</p>  <p>CheckStatusResponse   <p>response object for update of status of revocation entry</p>    Field Type Label Description     revoked bool  indicates if the status is revoked    <p></p>","title":"Check Revocation Status"},{"location":"reference/services/credential-service/#update-revocation-status","text":"<p>Update the credential status (revocation) of a previously issued credential. You must supply the credential id to this call.</p> Trinsic CLI   <pre><code># Revoke a credential\ntrinsic vc update-status --revoked --credential-status-id &lt;ID&gt;\n\n# Unrevoke a credential\ntrinsic vc update-status --unrevoked --credential-status-id &lt;ID&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Update Status Request object. This object follows the model below:</p>  <p>UpdateStatusRequest   <p>request object to update the status of the revocation entry</p>    Field Type Label Description     credential_status_id string  the credential status id   revoked bool  indicates if the status is revoked    <p></p>   <p>Then you can supply it to SDK:</p> C#PythonGoJava   <pre><code>await credentialService.UpdateStatusAsync(new() {CredentialStatusId = \"\", Revoked = true});\n</code></pre>   <pre><code>update_response = await credential_service.update_status(\n    request=UpdateStatusRequest(credential_status_id=\"\", revoked=True)\n)\n</code></pre>   <pre><code>updateResponse, err := credentialService.UpdateStatus(context.Background(), &amp;sdk.UpdateStatusRequest{CredentialStatusId: \"\", Revoked: true})\n</code></pre>   <pre><code>credentialService.updateStatus(VerifiableCredentials.UpdateStatusRequest.newBuilder().build());\n</code></pre>    <p>The response model is of type Update Status Response:</p>  <p>UpdateStatusResponse   <p>response object for update of status of revocation entry</p>    Field Type Label Description     status services.common.v1.ResponseStatus      <p></p>","title":"Update Revocation Status"},{"location":"reference/services/credential-service/#create-proof","text":"<p>Wallets allow data to be shared between parties in a secure manner, using a technique called Zero Knowledge Proofs. Trinsic Ecosystems uses the BBS+ Signature Proof scheme to allow data to be selectively disclosed to the requesting party. This allows users to share only the requested subset of data, instead the entire document.</p> <p>The endpoint to create a proof requires two inputs:</p> <ul> <li>document in the wallet that is signed with the correct signature</li> <li>JSONLD frame that describes the data to be disclosed</li> </ul> Trinsic CLI   <pre><code>trinsic vc create-proof --document-id &lt;STRING&gt; --out &lt;OUTPUT_FILE&gt; --reveal-document &lt;JSONLD_FRAME_FILE&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Create Proof Request object. This object follows the model below:</p>  <p>CreateProofRequest   <p>Create Proof</p>    Field Type Label Description     reveal_document_json string  Optional document that describes which fields should be revealed in the generated proof. If specified, this document must be a valid JSON-LD frame. If this field is not specified, a default reveal document will be used and all fields in the signed document will be revealed   item_id string  The item identifier that contains a record with a verifiable credential to be used for generating the proof.   document_json string  A document that contains a valid verifiable credential with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet.    <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>let proof = await credentialService.createProof(new CreateProofRequest()\n    .setItemId(insertItemResponse.getItemId())\n    .setRevealDocumentJson(JSON.stringify(getVaccineCertFrameJSON())));\n</code></pre>   <pre><code>var proof = await credentialService.CreateProofAsync(new() {\n    DocumentJson = credentialJson.DocumentJson,\n    RevealDocumentJson = frame.ToString(Formatting.None)\n});\n</code></pre>   <pre><code>proof_response = await credentials_service.create_proof(\n    request=CreateProofRequest(\n        reveal_document_json=proof_request_json, item_id=item_id\n    )\n)\n</code></pre>   <pre><code>credentialProof, err := credentialService.CreateProof(context.Background(), req)\n</code></pre>   <pre><code>var createProofResponse = credentialsService.createProof(VerifiableCredentials.CreateProofRequest.newBuilder().setItemId(itemId).setRevealDocumentJson(proofRequestJson).build()).get();\n</code></pre>    <p>The response model is of type Create Proof Response:</p>  <p>CreateProofResponse      Field Type Label Description     proof_document_json string      <p></p>","title":"Create Proof"},{"location":"reference/services/credential-service/#verify-proof","text":"<p>This endpoint verifies if the submitted data contains a valid proof. The data to be verified must contain a Linked Data Proof with BBS+ signature scheme.</p> Trinsic CLI   <pre><code># The JSONLD_FILE refers to the proof document obtained from a CreateProofResponse\ntrinsic vc issuer verify-proof --proof-document &lt;JSONLD_FILE&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Verify Proof Request object. This object follows the model below:</p>  <p>VerifyProofRequest   <p>Verify Proof</p>    Field Type Label Description     proof_document_json string      <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJavaRuby   <pre><code>let verifyResponse = await credentialService.verifyProof(new VerifyProofRequest()\n    .setProofDocumentJson(proof.getProofDocumentJson()));\n</code></pre>   <pre><code>var valid = await credentialService.VerifyProofAsync(new() {ProofDocumentJson = proof.ProofDocumentJson});\n</code></pre>   <pre><code>verify_result = await credentials_service.verify_proof(\n    request=VerifyProofRequest(proof_document_json=credential_proof)\n)\n</code></pre>   <pre><code>valid, err := credentialService.VerifyProof(context.Background(), &amp;sdk.VerifyProofRequest{ProofDocumentJson: credential.SignedDocumentJson})\n</code></pre>   <pre><code>var verifyProofResponse = credentialsService.verifyProof(VerifiableCredentials.VerifyProofRequest.newBuilder().setProofDocumentJson(credentialProof).build()).get();\n</code></pre>     <p>The response model is of type Verify Proof Response:</p>  <p>VerifyProofResponse      Field Type Label Description     is_valid bool  Indicates if the proof is valid   validation_messages string repeated Validation messages that describe invalid verifications based on different factors, such as schema validation, proof verification, revocation registry membership, etc. If the proof is not valid, this field will contain detailed results where this verification failed.    <p></p>","title":"Verify Proof"},{"location":"reference/services/credential-service/#exchange-credentials","text":"<p>Exchanging data securely is one of the fundamental functions of digital identity systems. There are many specifications with varying maturity that aim to provide interoperable and secure way of exchanging authentic data. We are commited to providing support for these methods.</p> <ul> <li>DIDComm Messaging </li> <li>Wallet And Credential Interactions </li> <li>OpenID Connect Credential Provider </li> </ul>  <p>During this beta period, we are only supporting exchanging data between users by using their email addresses. The messages are routed securely to the destination wallet without leaving the secure network of the ecosystem backend. Our goal is to provide basic ability to share data without affecting the user experience. As interoperable exchange methods become available, we will add this functionality in the SDK.</p>","title":"Exchange Credentials"},{"location":"reference/services/credential-service/#sending-documents-using-email-as-identifier","text":"<p>To send a document to another user, they must have created a wallet and associated their email address with that wallet.</p> Trinsic CLI   <pre><code>trinsic vc send --email &lt;EMAIL_ADDRESS&gt; --item &lt;FILE&gt;\n</code></pre>    <p>When using one of the SDKs, you must supply an Send Request object. This object follows the model below:</p>  <p>SendRequest      Field Type Label Description     email string     did_uri string     didcomm_invitation_json string     document_json string      <p></p>   <p>Then you can supply it to SDK:</p> TypeScriptC#PythonGoJava   <pre><code>await credentialService.send(document, \"admin@example.com\");\n</code></pre>   <pre><code>await credentialsService.SendAsync(new() {Email = \"example@trinsic.id\"});\n</code></pre>   <pre><code>send_response = await credentials_service.send(request=SendRequest(document_json=credential, email=\"example@trinsic.id\"))\n</code></pre>   <pre><code>err = credentialService.Send(context.Background(), &amp;sdk.SendRequest{DocumentJson: credential.SignedDocumentJson,\n    DeliveryMethod: &amp;sdk.SendRequest_Email{Email: \"example@trinsic.id\"}})\n</code></pre>   <pre><code>credentialsService.send(VerifiableCredentials.SendRequest.newBuilder().setDocumentJson(credentialProof).setEmail(\"example@trinsic.id\").build());\n</code></pre>    <p>The response model is of type Send Response:</p>  <p>SendResponse      Field Type Label Description     status services.common.v1.ResponseStatus      <p></p>","title":"Sending documents using Email as identifier"},{"location":"reference/services/provider-service/","text":"<p>This service helps ecosystem providers with data management and onboarding. This service requires a security profile with administrative authorization access. This can be obtained during the deployment of your ecosystem infrastructure.</p>","title":"Provider Service"},{"location":"reference/services/provider-service/#onboarding","text":"","title":"Onboarding"},{"location":"reference/services/provider-service/#invite-participant","text":"<p>Users can be onboarded as participants in the ecosystem by sending an invitation and a security code. This code can be sent directly through them using existing platforms or via email, SMS, etc. When users accept this invitation, they should do so using the service methods as described in creating wallet with provider invitation</p> <p>In Trinsic Ecosystems, participants can be Individuals or Organizations. This distinction is important, as providers have the ability to apply restrictions on what functionalities can be invoked by these participants. Additionally, Organizations have the ability to write their DID Document to a public ledger. Currently, the supported ledger is Sovrin, with ION and Element still in development.</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic provider invite --organization --method-email admin@faber.edu\n\ntrinsic provider invite --person --method-email alice@faber.edu\n</code></pre>   <pre><code>import { ProviderService, ParticipantType } from \"@trinsic/trinsic\";\n\nconst providerService = new ProviderService();\n\nlet inviteRequest = new InviteRequest();\ninviteRequest.setParticipant(ParticipantType.PARTICIPANT_TYPE_ORGANIZATION);\ninviteRequest.setEmail(\"admin@faber.edu\");\n\nconst inviteResponse = await providerService.inviteParticipant(inviteRequest);\n\nconsole.log(inviteResponse.getInvitationId());\n</code></pre>   <pre><code>var inviteResponse = await service.InviteParticipantAsync(new() {\n    Participant = ParticipantType.Individual,\n    Description = \"Doc sample\",\n    Details = new() {\n        Email = \"example@trinsic.id\"\n    }\n});\n</code></pre>   <pre><code>invite_response = await provider_service.invite_participant(\n    request=InviteRequest(\n        participant=ParticipantType.participant_type_individual,\n        description=\"Doc sample\",\n        details=AccountDetails(email=\"example@trinsic.id\"),\n    )\n)\n</code></pre>   <pre><code>inviteResponse, err := service.InviteParticipant(context.Background(),\n    &amp;sdk.InviteRequest{Participant: sdk.ParticipantType_participant_type_individual,\n        Details: &amp;sdk.AccountDetails{Email: \"example@trinsic.id\"}})\n</code></pre>   <pre><code>var inviteResponse = service.inviteParticipant(ProviderOuterClass.InviteRequest.newBuilder()\n        .setParticipant(ProviderOuterClass.ParticipantType.participant_type_individual)\n                .setDetails(AccountOuterClass.AccountDetails.newBuilder().setEmail(\"example@trinsic.id\").build())\n        .build()).get();\n</code></pre>     <p>The <code>invitationId</code> in the response contains the security code that users must supply when creating their wallet. If using email method in onboarding, they will receive this code in their email.</p> <p>ParticipantType</p>","title":"Invite Participant"},{"location":"reference/services/provider-service/#check-invitation-status","text":"<p>User invitation status can be checked with the provided <code>invitation id</code>. It returns an <code>InvitationStatusResponse</code> object. </p> <p>Invitation Status Request</p> <p>Invitation Status Response</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic provider invitation_status &lt;INVITATION_ID&gt;\n</code></pre>   <pre><code>import { ProviderService, ParticipantType } from \"@trinsic/trinsic\";\n\nconst providerService = new ProviderService();\n\nconst inviteResponse = await providerService.invitationStatus(\"INVITATION ID\");\n\nconsole.log(inviteResponse.getInvitationId());\n</code></pre>   <pre><code>var inviteStatus = await service.InvitationStatusAsync(new() {InvitationId = invitationId});\n</code></pre>   <pre><code>invite_status = await provider_service.invitation_status(\n    request=InvitationStatusRequest(invitation_id=invite_id)\n)\n</code></pre>   <pre><code>inviteStatus, err := service.InvitationStatus(context.Background(), &amp;sdk.InvitationStatusRequest{InvitationId: inviteResponse.InvitationId})\n</code></pre>   <pre><code>var invitationStatus = service.invitationStatus(\n        ProviderOuterClass.InvitationStatusRequest.newBuilder()\n                .setInvitationId(inviteResponse.getInvitationId())\n                .build()).get();\n</code></pre>     <p>The <code>invitationId</code> in the response contains the security code that users must supply when creating their wallet. If using email method in onboarding, they will receive this code in their email.</p>","title":"Check Invitation Status"},{"location":"reference/services/provider-service/#create-ecosystem","text":"Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>\n</code></pre>   <pre><code>let actualCreate = await providerService.createEcosystem(\n    new CreateEcosystemRequest()\n        .setDescription(\"Test ecosystem from Node\")\n        .setUri(\"https://example.com\"));\n</code></pre>   <pre><code>var (actualCreate, _) = await service.CreateEcosystemAsync(new() {\n    Description = \"My ecosystem\",\n    Uri = \"https://example.com\"\n});\n</code></pre>   <pre><code>actual_create = await provider_service.create_ecosystem(\n    request=CreateEcosystemRequest(\n        description=\"My ecosystem\", uri=\"https://example.com\"\n    )\n)\n</code></pre>   <pre><code>actualCreate, err := service.CreateEcosystem(context.Background(), &amp;sdk.CreateEcosystemRequest{\n    Description: \"My ecosystem\",\n    Uri:         \"https://example.com\",\n})\n</code></pre>   <pre><code>var response = service.createEcosystem(ProviderOuterClass.CreateEcosystemRequest.newBuilder().setDescription(\"My ecosystem\").setUri(\"https://example.com\").build()).get();\n</code></pre>","title":"Create Ecosystem"},{"location":"reference/services/template-service/","text":"<p>Credential Templates are json templates that help issuers save context when issuing credentials. </p> <p>When issuing a credential through Trinsic, it's as simple as adding the attributes to the credential template and then issuing it. </p> <p>These credential templates can be shared between issuers in an ecosystem. </p> <p>A template is a saved JSON-LD schema that is used to define/create credentials and verification. </p>","title":"Credential Templates"},{"location":"reference/services/template-service/#create-credential-template","text":"Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>\n</code></pre>   <pre><code>var credentialTemplateName = \"My First Credential Template\";\nvar  nameField = new TemplateField();\nnameField.setType(FieldType.STRING);\nnameField.setDescription(\"The name of the person\");\nnameField.setOptional(false);\n\nvar  numberOfBags = new TemplateField();\nnumberOfBags.setType(FieldType.NUMBER);\nnumberOfBags.setDescription(\"The number of bags the person is taking on the trip\");\nnumberOfBags.setOptional(false);\n\nvar  dateOfBirth = new TemplateField();\ndateOfBirth.setType(FieldType.DATETIME);\ndateOfBirth.setDescription(\"The date of birth of the person\");\ndateOfBirth.setOptional(false);\n\nvar  isVaccinated = new TemplateField();\nisVaccinated.setType(FieldType.BOOL);\nisVaccinated.setDescription(\"Whether or not the person has been vaccinated\");\nisVaccinated.setOptional(false);\n</code></pre>   <pre><code>CreateCredentialTemplateRequest templateRequest = new() {\n    Name = \"An Example Credential\",\n    AllowAdditionalFields = false\n};\ntemplateRequest.Fields.Add(\"firstName\", new() {Description = \"Given name\"});\ntemplateRequest.Fields.Add(\"lastName\", new());\ntemplateRequest.Fields.Add(\"age\", new() {Type = FieldType.Number, Optional = true});\n\nvar template = await templateService.CreateAsync(templateRequest);\n</code></pre>   <pre><code>template = await template_service.create(\n    request=CreateCredentialTemplateRequest(\n        name=\"An Example Credential\",\n        allow_additional_fields=False,\n        fields={\n            \"firstName\": TemplateField(description=\"Given name\"),\n            \"lastName\": TemplateField(),\n            \"age\": TemplateField(type=FieldType.NUMBER, optional=True),\n        },\n    )\n)\n</code></pre>   <pre><code>templateRequest := &amp;sdk.CreateCredentialTemplateRequest{Name: \"My Example Credential\", AllowAdditionalFields: false, Fields: make(map[string]*sdk.TemplateField)}\ntemplateRequest.Fields[\"firstName\"] = &amp;sdk.TemplateField{Description: \"Given name\"}\ntemplateRequest.Fields[\"lastName\"] = &amp;sdk.TemplateField{}\ntemplateRequest.Fields[\"age\"] = &amp;sdk.TemplateField{Type: sdk.FieldType_NUMBER, Optional: true}\n\ntemplate, err := templateService.Create(context.Background(), templateRequest)\n</code></pre>   <pre><code>var fields = new HashMap&lt;String, Templates.TemplateField&gt;();\nfields.put(\"firstName\", Templates.TemplateField.newBuilder().setDescription(\"Given name\").build());\nfields.put(\"lastName\", Templates.TemplateField.newBuilder().build());\nfields.put(\"age\", Templates.TemplateField.newBuilder().setType(Templates.FieldType.NUMBER).setOptional(true).build());\nvar templateRequest = Templates.CreateCredentialTemplateRequest.newBuilder().setName(\"My Example Credential\").setAllowAdditionalFields(false).putAllFields(fields).build();\nvar template = templateService.create(templateRequest).get();\n</code></pre>","title":"Create Credential Template"},{"location":"reference/services/template-service/#get","text":"Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>\n</code></pre>    <pre><code>var getTemplateResponse = await templateService.GetAsync(new() {Id = template.Data.Id});\n</code></pre>   <pre><code>get_template_response = await template_service.get(\n    request=GetCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre>   <pre><code>getResponse, err := templateService.Get(context.Background(), &amp;sdk.GetCredentialTemplateRequest{Id: template.Data.Id})\n</code></pre>   <pre><code>var getResponse = templateService.get(Templates.GetCredentialTemplateRequest.newBuilder().setId(id).build()).get();\n</code></pre>","title":"Get"},{"location":"reference/services/template-service/#search","text":"Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>\n</code></pre>    <pre><code>var searchTemplateResponse = await templateService.SearchAsync(new() {Query = \"SELECT * FROM c\"});\n</code></pre>   <pre><code>search_template_response = await template_service.search(\n    request=SearchCredentialTemplatesRequest(query=\"SELECT * FROM c\")\n)\n</code></pre>   <pre><code>searchResponse, err := templateService.Search(context.Background(), &amp;sdk.SearchCredentialTemplatesRequest{Query: \"SELECT * FROM c\"})\n</code></pre>   <pre><code>var searchResponse = templateService.search(Templates.SearchCredentialTemplatesRequest.newBuilder().setQuery(\"SELECT * FROM c WHERE c.id = '\" + id + \"'\").build()).get();\n</code></pre>","title":"Search"},{"location":"reference/services/template-service/#delete","text":"Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>\n</code></pre>    <pre><code>var deleteTemplateResponse = await templateService.DeleteAsync(new() {Id = template.Data.Id});\n</code></pre>   <pre><code>delete_template_response = await template_service.delete(\n    request=DeleteCredentialTemplateRequest(id=template.data.id)\n)\n</code></pre>   <pre><code>deleteResponse, err := templateService.Delete(context.Background(), &amp;sdk.DeleteCredentialTemplateRequest{Id: template.Data.Id})\n</code></pre>   <pre><code>var deleteResponse = templateService.delete(Templates.DeleteCredentialTemplateRequest.newBuilder().setId(id).build()).get();\n</code></pre>","title":"Delete"},{"location":"reference/services/trust-registry-service/","text":"<p>In many real-world credential exchange scenarios, a credential holder or verifier has the question \u201cHow do I know the issuer of this credential is trustworthy?\u201d</p> <p>Credential holders may also be uneasy about sharing information with a verifier if trust in the verifier has not been established.</p> <p>These problems can be solved by having a trusted third party vouch for the trustworthiness of a credential exchange participant.</p> <p>A trust registry is a list of authorized issuers and verifiers in the ecosystem and the types of credentials and passes they are authorized to issue and verify.</p> <p></p>","title":"Trust Registry"},{"location":"reference/services/trust-registry-service/#specification","text":"<p>The Trust over IP Foundation has a specification for an interoperable trust registry.  This defines an API interface so that trust registries can be queried in the same way. Our implementation is based off of this trust registry spec.</p>","title":"Specification"},{"location":"reference/services/trust-registry-service/#api-reference","text":"","title":"API Reference"},{"location":"reference/services/trust-registry-service/#create-a-ecosystem-governance-framework","text":"<p>An ecosystem governance framework is useful because it provides a good basis for verifying issuers and verifiers. It's a json-ld document that lists the issuers and verifiers. These issuers and verifiers are identified by a decentralized identifier. The governance framework is signified by an identifier as well. This can be used to represent the governance framework outside in the credential that it comes in. </p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic trust-registry register-efg\n</code></pre>    <pre><code>var registerFrameworkResponse = await service.RegisterGovernanceFrameworkAsync(new() { GovernanceFramework = new() {\n    Description = \"Demo framework\",\n    GovernanceFrameworkUri = \"https://example.com\",\n    TrustRegistryUri = \"https://schema.org/Card\"\n}});\n</code></pre>   <pre><code>register_framework_response = await service.register_governance_framework(\n    request=AddFrameworkRequest(\n        governance_framework=GovernanceFramework(\n            governance_framework_uri=https_example_com,\n            description=\"Demo framework\",\n            trust_registry_uri=https_schema_org,\n        )\n    )\n)\n</code></pre>   <pre><code>err = service.RegisterGovernanceFramework(context.Background(), &amp;sdk.AddFrameworkRequest{\n    GovernanceFramework: &amp;sdk.GovernanceFramework{\n        GovernanceFrameworkUri: frameworkURI,\n    },\n})\n</code></pre>   <pre><code>var frameworkResponse = service.registerGovernanceFramework(TrustRegistryOuterClass.AddFrameworkRequest.newBuilder().setGovernanceFramework(TrustRegistryOuterClass.GovernanceFramework.newBuilder().setGovernanceFrameworkUri(frameworkUri).build()).build()).get();\n</code></pre>","title":"Create a Ecosystem Governance Framework"},{"location":"reference/services/trust-registry-service/#register-issuers","text":"<p>Each entity on the governance framework, whether an issuer or a verifier, is represented by a decentralized identifier. These entities are registered to either issue or verify specific credential types. A credential type is represented as a fully qualified <code>type</code> URI, of the kind found in a JSON-LD Verifiable Credential. Finally, each entity must be registered on a specific governance framework. </p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic trust-registry register-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>    <pre><code>await service.RegisterIssuerAsync(new() {\n    DidUri = \"did:example:test\",\n    GovernanceFrameworkUri = \"https://example.com\",\n    CredentialTypeUri = \"https://schema.org/Card\"\n});\n\n\u22ef\n\nawait service.UnregisterIssuerAsync(new() {\n    DidUri = \"did:example:test\",\n    GovernanceFrameworkUri = \"https://example.com\",\n    CredentialTypeUri = \"https://schema.org/Card\"\n});\n</code></pre>   <pre><code>await service.register_issuer(\n    request=RegisterIssuerRequest(\n        did_uri=did_example_test,\n        governance_framework_uri=https_example_com,\n        credential_type_uri=https_schema_org,\n    )\n)\n\n\u22ef\n\nunregister_issuer_response = await service.unregister_issuer(\n    request=UnregisterIssuerRequest(\n        governance_framework_uri=https_example_com,\n        credential_type_uri=https_schema_org,\n        did_uri=did_example_test,\n    )\n)\n</code></pre>   <pre><code>    err = service.RegisterIssuer(context.Background(), &amp;sdk.RegisterIssuerRequest{\n        Authority:              &amp;sdk.RegisterIssuerRequest_DidUri{DidUri: didURI},\n        CredentialTypeUri:      typeURI,\n        GovernanceFrameworkUri: frameworkURI,\n    })\n\n \u22ef\n\n    err = service.UnregisterIssuer(context.Background(), &amp;sdk.UnregisterIssuerRequest{\n        CredentialTypeUri:      typeURI,\n        GovernanceFrameworkUri: frameworkURI,\n    })\n</code></pre>   <pre><code>service.registerIssuer(TrustRegistryOuterClass.RegisterIssuerRequest.newBuilder()\n        .setDidUri(didUri).setGovernanceFrameworkUri(frameworkUri).setCredentialTypeUri(typeUri).build());\n\n        \u22ef\n\nservice.unregisterIssuer(TrustRegistryOuterClass.UnregisterIssuerRequest.newBuilder().setGovernanceFrameworkUri(frameworkUri).setDidUri(didUri).setCredentialTypeUri(typeUri).build());\n</code></pre>","title":"Register Issuers"},{"location":"reference/services/trust-registry-service/#register-verifiers","text":"Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic trust-registry register-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>    <pre><code>await service.RegisterVerifierAsync(new() {\n    DidUri = \"did:example:test\",\n    GovernanceFrameworkUri = \"https://example.com\",\n    PresentationTypeUri = \"https://schema.org/Card\"\n});\n\n\u22ef\n\nawait service.UnregisterVerifierAsync(new() {\n    DidUri = \"did:example:test\",\n    GovernanceFrameworkUri = \"https://example.com\",\n    PresentationTypeUri = \"https://schema.org/Card\"\n});\n</code></pre>   <pre><code>await service.register_verifier(\n    request=RegisterVerifierRequest(\n        did_uri=did_example_test,\n        governance_framework_uri=https_example_com,\n        presentation_type_uri=https_schema_org,\n    )\n)\n\n\u22ef\n\nunregister_verifier_response = await service.unregister_verifier(\n    request=UnregisterVerifierRequest(\n        governance_framework_uri=https_example_com,\n        presentation_type_uri=https_schema_org,\n        did_uri=did_example_test,\n    )\n)\n</code></pre>   <pre><code>    err = service.RegisterVerifier(context.Background(), &amp;sdk.RegisterVerifierRequest{\n        Authority:              &amp;sdk.RegisterVerifierRequest_DidUri{DidUri: didURI},\n        PresentationTypeUri:    typeURI,\n        GovernanceFrameworkUri: frameworkURI,\n    })\n\n \u22ef\n\n    err = service.UnregisterVerifier(context.Background(), &amp;sdk.UnregisterVerifierRequest{\n        PresentationTypeUri:    typeURI,\n        GovernanceFrameworkUri: frameworkURI,\n    })\n</code></pre>   <pre><code>service.registerVerifier(TrustRegistryOuterClass.RegisterVerifierRequest.newBuilder().setDidUri(didUri).setGovernanceFrameworkUri(frameworkUri).setPresentationTypeUri(typeUri).build());\n\n\u22ef\n\nservice.unregisterVerifier(TrustRegistryOuterClass.UnregisterVerifierRequest.newBuilder().setGovernanceFrameworkUri(frameworkUri).setDidUri(didUri).setPresentationTypeUri(typeUri).build());\n</code></pre>","title":"Register Verifiers"},{"location":"reference/services/trust-registry-service/#unregister-issuers","text":"<p>To unregister an entity, include the credential type, the did, and the ecosystem governance framework. The credential type will be unregistered from that issuer.</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic trust-registry unregister-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>    <pre><code>await service.UnregisterIssuerAsync(new() {\n    DidUri = \"did:example:test\",\n    GovernanceFrameworkUri = \"https://example.com\",\n    CredentialTypeUri = \"https://schema.org/Card\"\n});\n</code></pre>   <pre><code>unregister_issuer_response = await service.unregister_issuer(\n    request=UnregisterIssuerRequest(\n        governance_framework_uri=https_example_com,\n        credential_type_uri=https_schema_org,\n        did_uri=did_example_test,\n    )\n)\n</code></pre>   <pre><code>err = service.UnregisterIssuer(context.Background(), &amp;sdk.UnregisterIssuerRequest{\n    CredentialTypeUri:      typeURI,\n    GovernanceFrameworkUri: frameworkURI,\n})\n</code></pre>   <pre><code>service.unregisterIssuer(TrustRegistryOuterClass.UnregisterIssuerRequest.newBuilder().setGovernanceFrameworkUri(frameworkUri).setDidUri(didUri).setCredentialTypeUri(typeUri).build());\n</code></pre>","title":"Unregister Issuers"},{"location":"reference/services/trust-registry-service/#unregister-verifiers","text":"<p>To unregister an entity, include the credential type, the did, and the ecosystem governance framework. The credential type will be unregistered from that issuer.</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic trust-registry unregister-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>    <pre><code>await service.UnregisterVerifierAsync(new() {\n    DidUri = \"did:example:test\",\n    GovernanceFrameworkUri = \"https://example.com\",\n    PresentationTypeUri = \"https://schema.org/Card\"\n});\n</code></pre>   <pre><code>unregister_verifier_response = await service.unregister_verifier(\n    request=UnregisterVerifierRequest(\n        governance_framework_uri=https_example_com,\n        presentation_type_uri=https_schema_org,\n        did_uri=did_example_test,\n    )\n)\n</code></pre>   <pre><code>err = service.UnregisterVerifier(context.Background(), &amp;sdk.UnregisterVerifierRequest{\n    PresentationTypeUri:    typeURI,\n    GovernanceFrameworkUri: frameworkURI,\n})\n</code></pre>   <pre><code>service.unregisterVerifier(TrustRegistryOuterClass.UnregisterVerifierRequest.newBuilder().setGovernanceFrameworkUri(frameworkUri).setDidUri(didUri).setPresentationTypeUri(typeUri).build());\n</code></pre>","title":"Unregister Verifiers"},{"location":"reference/services/trust-registry-service/#check-issuer-status","text":"<p>Check the status of an issuer for a credential type within a given governance framework. Returns all historical data for the given input parameter.</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic trust-registry check-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>    <pre><code>var issuerStatus = await service.CheckIssuerStatusAsync(new() {\n    DidUri = \"did:example:test\",\n    GovernanceFrameworkUri = \"https://example.com\",\n    CredentialTypeUri = \"https://schema.org/Card\"\n});\n</code></pre>   <pre><code>check_response = await service.check_issuer_status(\n    request=CheckIssuerStatusRequest(\n        did_uri=did_example_test,\n        governance_framework_uri=https_example_com,\n        credential_type_uri=https_schema_org,\n    )\n)\n</code></pre>   <pre><code>issuerStatus, err := service.CheckIssuerStatus(context.Background(), &amp;sdk.CheckIssuerStatusRequest{\n    GovernanceFrameworkUri: frameworkURI,\n    Member:                 &amp;sdk.CheckIssuerStatusRequest_DidUri{DidUri: didURI},\n    CredentialTypeUri:      typeURI,\n})\n</code></pre>   <pre><code>var issuerStatus = service.checkIssuerStatus(TrustRegistryOuterClass.CheckIssuerStatusRequest.newBuilder().setDidUri(didUri).setGovernanceFrameworkUri(frameworkUri).setCredentialTypeUri(typeUri).build()).get();\n</code></pre>","title":"Check Issuer Status"},{"location":"reference/services/trust-registry-service/#check-verifier-status","text":"<p>Check the status of an issuer for a credential type within a given governance framework. Returns all historical data for the given input parameter.</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic trust-registry check-issuer \\\n    --egf http://hl7.org/fhir \\\n    --credential-type https://w3id.org/vaccination#VaccinationCertificate \\\n    --did did:example:fabre\n</code></pre>    <pre><code>var verifierStatus = await service.CheckVerifierStatusAsync(new() {\n    DidUri = \"did:example:test\",\n    GovernanceFrameworkUri = \"https://example.com\",\n    PresentationTypeUri = \"https://schema.org/Card\"\n});\n</code></pre>   <pre><code>check_response = await service.check_verifier_status(\n    request=CheckVerifierStatusRequest(\n        did_uri=did_example_test,\n        governance_framework_uri=https_example_com,\n        presentation_type_uri=https_schema_org,\n    )\n)\n</code></pre>   <pre><code>verifierStatus, err := service.CheckVerifierStatus(context.Background(), &amp;sdk.CheckVerifierStatusRequest{\n    GovernanceFrameworkUri: frameworkURI,\n    Member:                 &amp;sdk.CheckVerifierStatusRequest_DidUri{DidUri: didURI},\n    PresentationTypeUri:    typeURI,\n})\n</code></pre>   <pre><code>var verifierStatus = service.checkIssuerStatus(TrustRegistryOuterClass.CheckIssuerStatusRequest.newBuilder().setDidUri(didUri).setGovernanceFrameworkUri(frameworkUri).setCredentialTypeUri(typeUri).build()).get();\n</code></pre>","title":"Check Verifier Status"},{"location":"reference/services/trust-registry-service/#search","text":"<p>Search the registry for authoritative issuer and verifiers using a custom query in a SQL format.</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic trust-registry search --query &lt;SQL query&gt;\n</code></pre>    <pre><code>var searchResult = await service.SearchRegistryAsync(new());\n</code></pre>   <pre><code>search_result = await service.search_registry()\n</code></pre>   <pre><code>ecosystemList, err := service.SearchRegistry(context.Background(), nil)\n</code></pre>   <pre><code>var searchResult = service.searchRegistry().get();\n</code></pre>","title":"Search"},{"location":"reference/services/trust-registry-service/#cache-offline-registry-file","text":"Trinsic CLI   <pre><code>trinsic trust-registry download \n</code></pre>","title":"Cache Offline Registry File"},{"location":"reference/services/wallet-service/","text":"<p>The wallet service is the main interface for interacting with a cloud wallet. The service endpoints are designed to closely match the recommendations of the Universal Wallet 2020  specification by W3C Community Credentials Group. The service exposes a gRPC interface and a set of data contracts as described in the specification. Our intention with this design is to bring it closer to interoperability as more implementations of this wallet appear in production.</p>","title":"Wallet Service"},{"location":"reference/services/wallet-service/#create-wallet","text":"<p>Wallets can be created directly by the user or through an invitation by the ecosystem provider. Depending on the ecosystem settings, direct wallet creation may not be enabled for your provider. The wallet is created automatically upon user signin. For more information on that, see the link below:</p> <ul> <li>Account Sign In</li> </ul>","title":"Create Wallet"},{"location":"reference/services/wallet-service/#insert-item","text":"<p>Trinsic supports the ability to insert verifiable credentials into a wallet simply using JSON data.</p> Trinsic CLI   <pre><code>trinsic wallet insert-item --item &lt;INPUT_JSON_FILE&gt;\n</code></pre>    <p>When using an SDK to perform this operation, you will need to supply an Insert Item Request object that follows the structure below:</p> <p>Insert item request</p>    Field Type Label Description     item_json string  the document to insert as stringified json   item_type string  optional item type ex. \"VerifiableCredential\"    <p></p> <p>Then you can supply it to the SDKs:</p> TypeScriptC#PythonGoJava   <pre><code>let insertItemResponse = await walletService.insertItem(new InsertItemRequest()\n    .setItemJson(issueResponse.getSignedDocumentJson()));\n</code></pre>   <pre><code>var insertItemResponse = await walletService.InsertItemAsync(new() {ItemJson = credentialJson.DocumentJson});\n</code></pre>   <pre><code>insert_response = await wallet_service.insert_item(\n    request=InsertItemRequest(item_json=credential)\n)\n</code></pre>   <pre><code>itemID, err := walletService.InsertItem(context.Background(), &amp;sdk.InsertItemRequest{ItemJson: credential.SignedDocumentJson})\n</code></pre>   <pre><code>var insertItemResponse = walletService.insertItem(UniversalWalletOuterClass.InsertItemRequest.newBuilder().setItemJson(credential).build()).get();\n</code></pre>    <p>The output of this method will be a unique <code>itemId</code> that can be used as input where required. The response model looks like this:</p> <p>Insert item response</p>    Field Type Label Description     status services.common.v1.ResponseStatus     item_id string  The item identifier of the inserted record    <p></p>","title":"Insert Item"},{"location":"reference/services/wallet-service/#search-query","text":"<p>Querying wallet data in our SDK is enabled through the use of familiar SQL syntax. All data is stored in JSON-LD format, so it can be easily searched. This apporach allows us to give developers full control over how data is retrieved. In addition to customizable sorting, paging and filtering, developers have the ability to construct projections, combine result sets, and even run user-defined functions over their queries.</p>  <p>This endpoint will support querying using Verifiable Presentation Request Spec . This feature is still in development.</p>","title":"Search / Query"},{"location":"reference/services/wallet-service/#basic-search","text":"<p>The default query used in the commands below returns a full wallet result set. The query is <code>SELECT * FROM c</code>.</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic wallet search\n</code></pre>   <pre><code>let items = await walletService.search();\n\n\u22ef\n\nlet items2 = await walletService.search(new SearchRequest().setQuery(\"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"));\n</code></pre>   <pre><code>var walletItems = await walletService.SearchAsync(new());\n\n\u22ef\n\nvar walletItems2 = await walletService.SearchAsync(new() {Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"});\n</code></pre>   <pre><code>wallet_items = await wallet_service.search()\n\n\u22ef\n\nwallet_items2 = await wallet_service.search(\n    request=SearchRequest(\n        query=\"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"\n    )\n)\n</code></pre>   <pre><code>    items, err := walletService.Search(context.Background(), &amp;sdk.SearchRequest{})\n\n \u22ef\n\n    items2, err := walletService.Search(context.Background(), &amp;sdk.SearchRequest{Query: \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"})\n</code></pre>   <pre><code>var searchResponse = walletService.search(UniversalWalletOuterClass.SearchRequest.getDefaultInstance()).get();  \n\n\u22ef\n\nvar searchResponse2 = walletService.search(UniversalWalletOuterClass.SearchRequest.newBuilder().setQuery(\"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\").build()).get();\n</code></pre>","title":"Basic Search"},{"location":"reference/services/wallet-service/#sql-search","text":"<p>To pass custom query to the search function, use the query parameter or the available overload.</p> Trinsic CLITypeScriptC#PythonGoJavaRuby   <pre><code>trinsic wallet search \\\n    --query \"SELECT * FROM c WHERE c.type = 'VerifiableCredential'\"\n</code></pre>   <pre><code>let items2 = await walletService.search(new SearchRequest().setQuery(\"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"));\n</code></pre>   <pre><code>var walletItems2 = await walletService.SearchAsync(new() {Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"});\n</code></pre>   <pre><code>wallet_items2 = await wallet_service.search(\n    request=SearchRequest(\n        query=\"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"\n    )\n)\n</code></pre>   <pre><code>items2, err := walletService.Search(context.Background(), &amp;sdk.SearchRequest{Query: \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\"})\n</code></pre>   <pre><code>var searchResponse2 = walletService.search(UniversalWalletOuterClass.SearchRequest.newBuilder().setQuery(\"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\").build()).get();\n</code></pre>","title":"SQL Search"},{"location":"reference/services/wallet-service/#common-sql-queries","text":"","title":"Common SQL Queries"},{"location":"reference/services/wallet-service/#paging","text":"<p>Paging uses the <code>OFFSET</code> clause that takes in a value indicating how many records should be skipped in the returned query. To specify the size of the result set (page size) use the <code>LIMIT</code> clause.</p> <pre><code>SELECT * FROM c OFFSET 10 LIMIT 5\n</code></pre>","title":"Paging"},{"location":"reference/services/wallet-service/#sorting","text":"<p>The optional <code>ORDER BY</code> clause specifies the sorting order for results returned by the query. To control sorting order, specify <code>ASC</code> or <code>DESC</code> at the end; if not specified ascending order is used by default.</p> <pre><code>SELECT * FROM c ORDER BY c.credential.issued DESC\n</code></pre>","title":"Sorting"},{"location":"reference/services/wallet-service/#filtering","text":"<p>The optional WHERE clause (<code>WHERE &lt;filter_condition&gt;</code>) specifies condition(s) that the source JSON items must satisfy for the query to include them in results. A JSON item must evaluate the specified conditions to true to be considered for the result. The index layer uses the <code>WHERE</code> clause to determine the smallest subset of source items that can be part of the result.</p> <pre><code>SELECT * FROM c WHERE c.name = 'Trinsic' AND c.dateCreated &gt;= \"2020-09-30T23:14:25.7251173Z\"\n</code></pre>","title":"Filtering"},{"location":"reference/services/wallet-service/#grouping","text":"<p>The <code>GROUP BY</code> clause divides the query's results according to the values of one or more specified properties. Examples and detailed description on working with grouped results can be found here </p>","title":"Grouping"},{"location":"reference/services/wallet-service/#additional-resources","text":"<p>You can read the full documentation on working with SQL queries on the Azure Cosmos DB website .</p>","title":"Additional Resources"},{"location":"ruby/","text":"<p>The Trinsic Ruby SDK makes it easy to interact with the Trinsic API from any Ruby application. The most recent version of the library can be found on RubyGems. You can find the SDKs source on Github.</p>","title":"The Trinsic Ruby SDK"},{"location":"ruby/#installation-and-configuration","text":"<ul> <li>Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here</li> <li>If you install to a different location for debugging, use the environment variable <code>RUBY_DLL_PATH</code> on windows. <code>LD_LIBRARY_PATH</code> for Ruby on Mac/Linux <pre><code>gem install trinsic-services\n</code></pre></li> <li>Test installation by running the following Ruby script: <pre><code>require 'trinsic_services'\n\naccount_service = Trinsic::AccountService.new(nil, Trinsic::trinsic_prod_server)\naccount_profile = account_service.sign_in(nil).profile\nputs account_profile\n</code></pre></li> <li>Output should look something like this: <pre><code>&lt;Services::Account::V1::AccountProfile: profile_type: \"https://trinsic.id/security/v1/oberon\", auth_data: \")urn:trinsic:wallets:bbBEp9EmV1NNWMadBhit2$19ac25ae-2fd0-44d1-9ef7-73cc668e8f7d\", auth_token: \"\u2592\", protection: &lt;Services::Account::V1::TokenProtection: enabled: false, method: :None&gt;&gt;\n</code></pre></li> </ul>","title":"Installation and Configuration"},{"location":"ruby/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API </p>","title":"Next Steps"},{"location":"walkthroughs/vaccination/","text":"<p>This walkthrough will show how a vaccination card can be issued, held, and proven using verifiable credentials with the Trinsic CLI. Feel free to follow along in a terminal using the CLI. We'll cover each part of Trinsic's platform during the tutorial. </p>","title":"Walkthrough"},{"location":"walkthroughs/vaccination/#meet-allison","text":"<p>In this walkthrough we'll explore a scenario where Allison gets her vaccination certificate. She then uses this certificate to board an airline that requires proof of vaccination.</p>  <p>In most credential exchange scenarios there are three primary roles - Issuer, Holder, and Verifier.</p> <p>Holder: Stores issued credentials from an issuer. Most often this is the credential subject. Also generates passes to share with verifiers.</p> <p>Issuer: Responsible for issuing signed credentials that attest information about a credential subject</p> <p>Verifier: Verifies passes presented from holders.</p> <p>In this case, Allison will be the holder, a vaccination clinic will be an issuer, and an airline will be the verifier.  <pre><code>walkthrough\n|- allison - Holder\n|- clinic - Issuer\n|- airline - Verifier\n</code></pre></p>","title":"Meet Allison"},{"location":"walkthroughs/vaccination/#our-sdks","text":"<p>This tutorial is meant to share the concepts of verifiable credentials. So feel free to sit back and read through this without running any code. However, you can also follow along using one of our SDKs. </p> <p>We've set up some environments to use on Repl.it. If your language of choice isn't supported on repl.it, you can also run locally by installing the SDK of your choice.</p> Trinsic CLITypeScriptC#PythonJavaRubyGo   <ul> <li>Installation instructions for the Trinsic CLI.</li> </ul> <p>Once the CLI is installed, clone our CLI example repository on Github to download the credential data for this walkthrough.</p> <pre><code>git clone https://github.com/trinsic-id/cli-example &amp;&amp; cd cli-example\n</code></pre> <p>If you don't want to install locally, we also have a replit environment for you to use. In a new tab, you can open our  to use the CLI. This demo environment works best when run side-by-side the following walkthrough using two tabs in your browser.</p>   <ul> <li>Installation instructions for the Node SDK.</li> <li>Installation instructions for the Browser SDk.</li> </ul>   <p>Let's create a new .NET console app that we will use to add our sample code</p> <pre><code>dotnet new console -n TrinsicSample &amp;&amp; cd TrinsicSample\n</code></pre> <p>Now we'll follow the installation instructions for Dotnet.</p>   <ul> <li>Installation instructions for Python.</li> </ul>   <ul> <li>Installation instructions for Java.</li> </ul> <p>In this project, we'll be following along the <code>java/src/test/java/trinsic/VaccineDemo.java</code> in our SDK repository</p>   <ul> <li>Install Instructions </li> </ul>   <ul> <li>Install Instructions</li> </ul>","title":"Our SDKs"},{"location":"walkthroughs/vaccination/#creating-accounts","text":"<p>We'll start by creating a Trinsic Wallet for each participant in this credential exchange. Wallets can be created by anyone, for anyone. In this scenario, we'll have three wallets. Allison will be the credential holder, the Airline will be the verifier, and the vaccination clinic will be the issuer.</p> <p>When a new Trinsic account is created, a cloud wallet is created on our platform and an authentication key is generated by our SDK locally. Each person is the sole owner of their cloud wallet. They're meant to be easy to create so that you can create a cloud wallet for an end-user in your UX with very little friction. </p> Trinsic CLITypescriptC#PythonJavaGo   <p>The CLI offers an interactive way of creating wallets. For demo purposes, we'll create all three on the same machine. However, this demo could be done with all three wallets created on three separate machines.</p> <p>When creating a wallet in the CLI, the wallet will store a private authentication token for the wallet in ~/.trinsic. If using the CLI with a real-world wallet, store this authentication token somewhere securely.  <pre><code>trinsic account login --description \"Allison's Wallet\" --alias allison &amp;&amp; \\\ntrinsic account login --description \"Airline's wallet\" --alias airline &amp;&amp; \\\ntrinsic account login --description \"Vaccination Clinic\" --alias clinic\n</code></pre></p>   <pre><code>// Create 3 different profiles for each participant in the scenario\nconst allison = await accountService.signIn(new SignInRequest());\nconst clinic = await accountService.signIn(new SignInRequest());\nconst airline = await accountService.signIn(new SignInRequest());\n</code></pre>   <pre><code>var allison = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\nvar clinic = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\nvar airline = await accountService.SignInAsync(new() {EcosystemId = ecosystemId});\n</code></pre>   <pre><code># Create 3 different profiles for each participant in the scenario\nallison = await account_service.sign_in(\n    request=SignInRequest(ecosystem_id=ecosystem_id)\n)\nclinic = await account_service.sign_in(\n    request=SignInRequest(ecosystem_id=ecosystem_id)\n)\nairline = await account_service.sign_in(\n    request=SignInRequest(ecosystem_id=ecosystem_id)\n)\n</code></pre>   <pre><code>// Create 3 different profiles for each participant in the scenario\nvar allison = accountService.signIn().get();\nvar clinic = accountService.signIn().get();\nvar airline = accountService.signIn().get();\n</code></pre>   <pre><code>allison, _, err := accountService.SignIn(context.Background(), &amp;sdk.SignInRequest{})\nfailError(t, \"error creating profile\", err)\nif !assert2.NotNil(allison) {\n    return\n}\n\nclinic, _, err := accountService.SignIn(context.Background(), &amp;sdk.SignInRequest{})\nfailError(t, \"error creating profile\", err)\nif !assert2.NotNil(clinic) {\n    return\n}\n\nairline, _, err := accountService.SignIn(context.Background(), &amp;sdk.SignInRequest{})\nfailError(t, \"error creating profile\", err)\nif !assert2.NotNil(airline) {\n    return\n}\n</code></pre>    <p>If you would like to save the profile for future use, you can simply export the serialized profile to a local storage. Please note that the profiles contain sensitive key data, so they should be stored in a secure enclave.</p>  C#PythonJavaGo   <pre><code>// Serialize auth token by exporting it to file\nFile.WriteAllText(\"allison.txt\", allison);\n// Create auth token from existing data\nallison = File.ReadAllText(\"allison.txt\");\n</code></pre>   <pre><code># Store profile for later use\nwith open(\"allison.txt\", \"wb\") as fid:\n    fid.write(allison.encode(\"utf-8\"))\n\n# Create profile from existing data\nwith open(\"allison.txt\", \"rb\") as fid:\n    allison = fid.readline()\n</code></pre>   <pre><code>var writeFile = new BufferedWriter(new FileWriter(\"allison.txt\"));\nwriteFile.write(allison);\nwriteFile.flush();\nwriteFile.close();\n\n// Create profile from existing data\nvar readFile = new BufferedReader(new FileReader(\"allison.txt\"));\nallison = readFile.readLine().strip();\nreadFile.close();\n</code></pre>   <pre><code>// Store profile for later use\n// File.WriteAllBytes(\"allison.bin\", allison.ToByteString().ToByteArray());\n\n// Create profile from existing data\n// var allison = WalletProfile.Parser.ParseFrom(File.ReadAllBytes(\"allison.bin\"));\n</code></pre>     <p>Note</p> <p>References: </p> <ul> <li>Manage access to cloud wallets with the Account Service</li> <li>Learn more about Wallets</li> <li>Read more about security profiles and authentication.</li> </ul>","title":"Creating Accounts"},{"location":"walkthroughs/vaccination/#define-a-template","text":"Trinsic CLITypescriptC#PythonJavaGo    <pre><code>var credentialTemplateName = \"My First Credential Template\";\nvar  nameField = new TemplateField();\nnameField.setType(FieldType.STRING);\nnameField.setDescription(\"The name of the person\");\nnameField.setOptional(false);\n\nvar  numberOfBags = new TemplateField();\nnumberOfBags.setType(FieldType.NUMBER);\nnumberOfBags.setDescription(\"The number of bags the person is taking on the trip\");\nnumberOfBags.setOptional(false);\n\nvar  dateOfBirth = new TemplateField();\ndateOfBirth.setType(FieldType.DATETIME);\ndateOfBirth.setDescription(\"The date of birth of the person\");\ndateOfBirth.setOptional(false);\n\nvar  isVaccinated = new TemplateField();\nisVaccinated.setType(FieldType.BOOL);\nisVaccinated.setDescription(\"Whether or not the person has been vaccinated\");\nisVaccinated.setOptional(false);\n</code></pre> <pre><code>const templateService = new TemplateService(options);\n\nlet request = new CreateCredentialTemplateRequest();\nrequest.setName(credentialTemplateName); \n\nrequest.getFieldsMap()\n.set(\"name\", nameField)\n.set(\"numberOfBags\", numberOfBags)\n.set(\"dateOfBirth\", dateOfBirth)\n.set(\"vaccinated\", isVaccinated);\n\nlet response = await templateService.createCredentialTemplate(request);\n</code></pre>   <pre><code>CreateCredentialTemplateRequest templateRequest = new() {\n    Name = \"An Example Credential\",\n    AllowAdditionalFields = false\n};\ntemplateRequest.Fields.Add(\"firstName\", new() {Description = \"Given name\"});\ntemplateRequest.Fields.Add(\"lastName\", new());\ntemplateRequest.Fields.Add(\"age\", new() {Type = FieldType.Number, Optional = true});\n\nvar template = await templateService.CreateAsync(templateRequest);\n</code></pre>   <pre><code>template = await template_service.create(\n    request=CreateCredentialTemplateRequest(\n        name=\"An Example Credential\",\n        allow_additional_fields=False,\n        fields={\n            \"firstName\": TemplateField(description=\"Given name\"),\n            \"lastName\": TemplateField(),\n            \"age\": TemplateField(type=FieldType.NUMBER, optional=True),\n        },\n    )\n)\n</code></pre>   <pre><code>var fields = new HashMap&lt;String, Templates.TemplateField&gt;();\nfields.put(\"firstName\", Templates.TemplateField.newBuilder().setDescription(\"Given name\").build());\nfields.put(\"lastName\", Templates.TemplateField.newBuilder().build());\nfields.put(\"age\", Templates.TemplateField.newBuilder().setType(Templates.FieldType.NUMBER).setOptional(true).build());\nvar templateRequest = Templates.CreateCredentialTemplateRequest.newBuilder().setName(\"My Example Credential\").setAllowAdditionalFields(false).putAllFields(fields).build();\nvar template = templateService.create(templateRequest).get();\n</code></pre>   <pre><code>templateRequest := &amp;sdk.CreateCredentialTemplateRequest{Name: \"My Example Credential\", AllowAdditionalFields: false, Fields: make(map[string]*sdk.TemplateField)}\ntemplateRequest.Fields[\"firstName\"] = &amp;sdk.TemplateField{Description: \"Given name\"}\ntemplateRequest.Fields[\"lastName\"] = &amp;sdk.TemplateField{}\ntemplateRequest.Fields[\"age\"] = &amp;sdk.TemplateField{Type: sdk.FieldType_NUMBER, Optional: true}\n\ntemplate, err := templateService.Create(context.Background(), templateRequest)\n</code></pre>","title":"Define a Template"},{"location":"walkthroughs/vaccination/#create-an-ecosystem","text":"Trinsic CLITypescriptC#PythonJava","title":"Create an Ecosystem"},{"location":"walkthroughs/vaccination/#issue-a-credential","text":"<p>Upon receiving her vaccine, Allison also receives a digital certificate from the clinic. This certificate is digitally signed by the clinic, acting as an issuer. The certificate is in a JSON form, and for this example, we will use the following JSON. Add this file to your project named <code>vaccination-certificate-unsigned.jsonld</code>.</p> vaccination-certificate-unsigned.jsonld     <pre><code>{\n    \"@context\": [\n        \"https://www.w3.org/2018/credentials/v1\",\n        \"https://w3id.org/vaccination/v1\",\n        \"https://w3id.org/security/bbs/v1\"\n    ],\n    \"id\": \"urn:uvci:af5vshde843jf831j128fj\",\n    \"type\": [\n        \"VaccinationCertificate\",\n        \"VerifiableCredential\"\n    ],\n    \"description\": \"COVID-19 Vaccination Certificate\",\n    \"name\": \"COVID-19 Vaccination Certificate\",\n    \"expirationDate\": \"2029-12-03T12:19:52Z\",\n    \"issuanceDate\": \"2019-12-03T12:19:52Z\",\n    \"issuer\": \"did:key:zUC724vuGvHpnCGFG1qqpXb81SiBLu3KLSqVzenwEZNPoY35i2Bscb8DLaVwHvRFs6F2NkNNXRcPWvqnPDUd9ukdjLkjZd3u9zzL4wDZDUpkPAatLDGLEYVo8kkAzuAKJQMr7N2\",\n    \"credentialSubject\": {\n        \"id\": \"urn:uuid:c53e70f8-ce9a-4576-8744-e5f85c20a743\",\n        \"type\": \"VaccinationEvent\",\n        \"batchNumber\": \"1183738569\",\n        \"countryOfVaccination\": \"US\"\n    }\n}\n</code></pre> <p>Behind the scenes, each credential is a JSON document that is signed with a special digital signature to make each piece of data in the credential separately verifiable.</p> <p>Signatures are a way to make sure that credentials are not forged or tampered with between getting issued and verified. They also are how a verifier can know that the credential was issued by who the credential says it was issued by.</p> <p>To issue this credential we'll specify links to the json files, set the active profile to the clinic, and call the issuance endpoint:</p> Trinsic CLITypescriptC#PythonJavaGo   <pre><code>trinsic  --profile clinic issuer issue --document data/vaccination-certificate-unsigned.json --out vaccination-certificate-signed.json\n</code></pre>   <pre><code>// Sign a credential as the clinic and send it to Allison\nconst credentialJson = getVaccineCertUnsignedJSON()\nconst credential = await credentialService.issueCredential(new IssueRequest()\n    .setDocumentJson(JSON.stringify(credentialJson)));\n</code></pre>   <pre><code>// Set active profile to 'clinic' so we can issue credential signed\n// with the clinic's signing keys\nwalletService.Options.AuthToken = credentialsService.Options.AuthToken = clinic;\n\n// Read the JSON credential data\nvar credentialJson = await File.ReadAllTextAsync(VaccinationCertificateUnsigned);\n// Sign the credential using BBS+ signature scheme\n// issueCredentialSample() {\nvar credential = await credentialsService.IssueCredentialAsync(new() {DocumentJson = credentialJson});\n_testOutputHelper.WriteLine($\"Credential:\\n{credential.SignedDocumentJson}\");\n// }\n</code></pre>   <p>We specify links to the jsonld files:</p> <pre><code>def _base_data_path() -&gt; str:\n    return abspath(join(dirname(__file__), \"..\", \"..\", \"devops\", \"testdata\"))\n\n\ndef _vaccine_cert_unsigned_path() -&gt; str:\n    return abspath(join(_base_data_path(), \"vaccination-certificate-unsigned.jsonld\"))\n\n\ndef _vaccine_cert_frame_path() -&gt; str:\n    return abspath(join(_base_data_path(), \"vaccination-certificate-frame.jsonld\"))\n</code></pre> <p>Let's set the active profile to the clinic, and call the issuance endpoint</p> <pre><code>issue_response = await credentials_service.issue_credential(\n    request=IssueRequest(document_json=credential_json)\n)\n</code></pre>   <p>We specify links to the jsonld files:</p> <pre><code>public static String baseTestPath() {\n    return Path.of(new File(\"\").getAbsolutePath(), \"..\", \"devops\", \"testdata\").toAbsolutePath().toString();\n}\n\npublic static Path vaccineCertUnsignedPath() {\n    return Path.of(baseTestPath(), \"vaccination-certificate-unsigned.jsonld\");\n}\n\npublic static Path vaccineCertFramePath() {\n    return Path.of(baseTestPath(), \"vaccination-certificate-frame.jsonld\");\n}\n</code></pre> <p>Let's set the active profile to the clinic, and call the issuance endpoint</p> <pre><code>// Sign a credential as the clinic and send it to Allison\nvar credentialJson = Files.readString(vaccineCertUnsignedPath());\n// issueCredentialSample() {\nvar issueResult = credentialsService.issueCredential(VerifiableCredentials.IssueRequest.newBuilder().setDocumentJson(credentialJson).build()).get();\n// }\nvar credential = issueResult.getSignedDocumentJson();\nSystem.out.println(\"Credential: \" + credential);\n</code></pre>   <pre><code>func GetBasePath() string {\n    _, fileName, _, _ := runtime.Caller(1)\n    path := filepath.Clean(filepath.Join(filepath.Dir(fileName), \"..\", \"..\", \"devops\", \"testdata\"))\n    return path\n}\nfunc GetVaccineCertUnsignedPath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-unsigned.jsonld\")\n}\nfunc GetVaccineCertFramePath() string {\n    return filepath.Join(GetBasePath(), \"vaccination-certificate-frame.jsonld\")\n}\n</code></pre> <pre><code>fileContent, err := ioutil.ReadFile(GetVaccineCertUnsignedPath())\nfailError(t, \"error reading file\", err)\n\ncredentialService.SetToken(clinic)\n// issueCredentialSample() {\ncredential, err := credentialService.IssueCredential(context.Background(), &amp;sdk.IssueRequest{DocumentJson: string(fileContent)})\n// }\nfailError(t, \"error issuing credential\", err)\nfmt.Printf(\"Credential:%s\\n\", credential)\n</code></pre>     <p>Info</p> <p>Reference: </p> <ul> <li>Learn more about how to issue a credential</li> <li>Learn more about verifiable credentials</li> </ul>","title":"Issue a Credential"},{"location":"walkthroughs/vaccination/#send-credential-to-allison","text":"<p>At this point, the clinic can send the signed credential to Allison using any available methods. These methods can include any message exchange protocol, or a custom transport. In this case, we'll assume that the credential was delivered to Allison in an offline environment.</p> <p>Sending credentials securely is an important part of maintaining the privacy of a credential holder. At this point we do not have a standard way of sending credentials to a wallet. There are a couple of options available. </p> <p>First, if you've onboarded two wallets on the Trinsic platform there is a way to send credentials to a wallet via the wallet's email address. This method is a temporary fix. We recommend using a secure channel of communication within your application for sending and receiving credentials. Sending via https or another encrypted messaging protocol is critical to ensure the personal information inside the credential is not accidentally leaked. As Trinsic's platform develops, we will embed an encrypted messaging protocol called DIDComm (decentralized identifier communication) to exchange credentials between any wallet.</p>  <p>Info</p> <p>Dive Deeper: </p> <ul> <li>Learn more about how to exchange credentials</li> </ul>","title":"Send Credential to Allison"},{"location":"walkthroughs/vaccination/#store-credential-in-wallet","text":"<p>Once Allison receives the credential, she or her wallet application can store it within her wallet. She can use any device that she's authorized to use with her wallet. Storing credentials securely is also important to maintaining Allison's privacy. </p> Trinsic CLITypescriptC#PythonJavaGo   <pre><code>trinsic --profile allison wallet insert-item --item vaccination-certificate-signed.json\n</code></pre>   <pre><code>// Alice stores the credential in her cloud wallet.\naccountService.options.setAuthToken(allison);\nconst itemId = await walletService.insertItem(new InsertItemRequest()\n    .setItemJson(credential.getSignedDocumentJson()));\n</code></pre>   <pre><code>// Set active profile to 'allison' so we can manage her cloud wallet\nwalletService.Options.AuthToken = credentialsService.Options.AuthToken = allison;\n\nvar insertItemResponse = await walletService.InsertItemAsync(new() {ItemJson = credential.SignedDocumentJson});\nvar itemId = insertItemResponse.ItemId;\n</code></pre>   <pre><code># Alice stores the credential in her cloud wallet.\nwallet_service.service_options.auth_token = allison\n# insertItemWallet() {\ninsert_response = await wallet_service.insert_item(\n    request=InsertItemRequest(item_json=credential)\n)\n# }\nitem_id = insert_response.item_id\n</code></pre>   <pre><code>// Alice stores the credential in her cloud wallet.\n// insertItemWallet() {\nvar insertItemResponse = walletService.insertItem(UniversalWalletOuterClass.InsertItemRequest.newBuilder().setItemJson(credential).build()).get();\n// }\nfinal var itemId = insertItemResponse.getItemId();\nSystem.out.println(\"item id = \" + itemId);\n</code></pre>   <pre><code>walletService.SetToken(allison)\nfailError(t, \"error setting profile\", err)\n// insertItemWallet() {\nitemID, err := walletService.InsertItem(context.Background(), &amp;sdk.InsertItemRequest{ItemJson: credential.SignedDocumentJson})\n// }\nfailError(t, \"error inserting item\", err)\nfmt.Println(\"item id\", itemID)\n</code></pre>    <p>Note down the response <code>item_id</code> printed to the console for the next step.</p>  <p>Info</p> <p>Reference: Insert Record</p>","title":"Store Credential in Wallet"},{"location":"walkthroughs/vaccination/#create-a-proof-of-vaccination","text":"<p>Before boarding an airplane, Allison must show a proof of vaccination. The request for this proof also comes in a form of JSON, in this case a JSON-LD frame.</p> <p>This request can be communicated using any exchange protocol. Again, we'll assume this was done offline.</p> <p>Let's save this request in a file named <code>vaccination-certificate-frame.jsonld</code></p> vaccination-certificate-frame.jsonld     <pre><code>{\n    \"@context\": [\n        \"https://www.w3.org/2018/credentials/v1\",\n        \"https://w3id.org/vaccination/v1\",\n        \"https://w3id.org/security/bbs/v1\"\n    ],\n    \"type\": [\n        \"VerifiableCredential\",\n        \"VaccinationCertificate\"\n    ],\n    \"@explicit\": true,\n    \"issuer\": {},\n    \"credentialSubject\": {\n        \"@explicit\": true,\n        \"@type\": \"VaccinationEvent\",\n        \"batchNumber\": {},\n        \"countryOfVaccination\": {}\n    }\n}\n</code></pre> <p>This request asks Allison to provide proof of valid vaccination certificate, including the <code>issuer</code>, <code>batchNumber</code>and <code>countryOfVaccination</code> fields.</p> <p>Allison can use the Create Proof functions to build a proof that will share only the requested fields.</p> <p>Now let's create a proof for Allison. She may choose to generate this proof before going to the airport, or might generate it right as she boards.</p> Trinsic CLITypescriptC#PythonJavaGo   <p>Replace the <code>&lt;item_id&gt;</code> in the generate proof command below with the output from the <code>insert_item</code> above.</p> <pre><code>trinsic --profile allison issuer create-proof --document-id \"&lt;item-id&gt;\" --out vaccination-certificate-partial-proof.json --reveal-document data/vaccination-certificate-frame.json\n</code></pre>   <pre><code>// Allison shares the credential with the venue.\n// The venue has communicated with Allison the details of the credential\n// that they require expressed as a JSON-LD frame.\ncredentialService.options.setAuthToken(allison);\nconst proofRequestJson = getVaccineCertFrameJSON();\nconst proof = await credentialService.createProof(new CreateProofRequest()\n    .setItemId(itemId.getItemId())\n    .setRevealDocumentJson(JSON.stringify(proofRequestJson)));\n</code></pre>   <pre><code>// We'll read the request frame from a file and communicate this with Allison\nwalletService.Options.AuthToken = credentialsService.Options.AuthToken = allison;\n\nvar proofRequestJson = await File.ReadAllTextAsync(VaccinationCertificateFrame);\n\n// Build a proof for the given request and the `itemId` we previously received\n// which points to the stored credential\nvar credentialProof = await credentialsService.CreateProofAsync(new() {\n    ItemId = itemId,\n    RevealDocumentJson = proofRequestJson\n});\n_testOutputHelper.WriteLine(\"Proof:\");\n_testOutputHelper.WriteLine(credentialProof.ProofDocumentJson);\n</code></pre>   <pre><code># Allison shares the credential with the venue.\n# The venue has communicated with Allison the details of the credential\n# that they require expressed as a JSON-LD frame.\ncredentials_service.service_options.auth_token = allison\nwallet_service.service_options.auth_token = allison\nwith open(_vaccine_cert_frame_path(), \"r\") as fid2:\n    proof_request_json = \"\\n\".join(fid2.readlines())\n\n# createProof() {\nproof_response = await credentials_service.create_proof(\n    request=CreateProofRequest(\n        reveal_document_json=proof_request_json, item_id=item_id\n    )\n)\n# }\ncredential_proof = proof_response.proof_document_json\nprint(f\"Proof: {credential_proof}\")\n</code></pre>   <pre><code>// Allison shares the credential with the venue.\n// The venue has communicated with Allison the details of the credential\n// that they require expressed as a JSON-LD frame.\ncredentialsService.setProfile(allison);\nvar proofRequestJson = Files.readString(vaccineCertFramePath());\n// createProof() {\nvar createProofResponse = credentialsService.createProof(VerifiableCredentials.CreateProofRequest.newBuilder().setItemId(itemId).setRevealDocumentJson(proofRequestJson).build()).get();\n// }\nvar credentialProof = createProofResponse.getProofDocumentJson();\nSystem.out.println(\"Proof: \" + credentialProof);\n</code></pre>   <pre><code>walletService.SetToken(allison)\nfailError(t, \"error reading file\", err)\n\nfileContent2, err := ioutil.ReadFile(GetVaccineCertFramePath())\nfailError(t, \"error reading file\", err)\n\nreq := &amp;sdk.CreateProofRequest{\n    RevealDocumentJson: string(fileContent2),\n    Proof:              &amp;sdk.CreateProofRequest_ItemId{ItemId: itemID},\n}\n\ncredentialService.SetToken(allison)\n// createProof() {\ncredentialProof, err := credentialService.CreateProof(context.Background(), req)\n// }\nfailError(t, \"error creating proof\", err)\nfmt.Println(\"Credential proof\", credentialProof)\n</code></pre>    <p>Take a look at the proof. Notice how only the attributes included in the <code>frame</code> are included with the proof.</p> <p>Allison sends this proof to the airline for them to verify.</p>  <p>Info</p> <p>Reference: Create Proof</p>","title":"Create a Proof of Vaccination"},{"location":"walkthroughs/vaccination/#verify-proof","text":"<p>Once the airline receives the proof, they can now verify it to ensure its authenticity. Because Allison sent a proof of her vaccination credential and not the credential itself, the airline only receives its required information.</p> Trinsic CLITypescriptC#PythonJavaGo   <pre><code>trinsic --profile airline issuer verify-proof --proof-document vaccination-certificate-partial-proof.json\n</code></pre>   <pre><code>// The airline verifies the credential\ncredentialService.options.setAuthToken(airline);\nconst verifyResponse = await credentialService.verifyProof(new VerifyProofRequest()\n    .setProofDocumentJson(proof.getProofDocumentJson()));\n</code></pre>   <pre><code>// The airline verifies the credential\nwalletService.Options.AuthToken = credentialsService.Options.AuthToken = airline;\n\n// Check for valid signature\nvar valid = await credentialsService.VerifyProofAsync(new() {\n    ProofDocumentJson = credentialProof.ProofDocumentJson\n});\n_testOutputHelper.WriteLine($\"Verification result: {valid.IsValid}\");\nAssert.True(valid.IsValid);\n</code></pre>   <pre><code># The airline verifies the credential\ncredentials_service.service_options.auth_token = airline\nwallet_service.service_options.auth_token = airline\n# verifyProof() {\nverify_result = await credentials_service.verify_proof(\n    request=VerifyProofRequest(proof_document_json=credential_proof)\n)\n# }\nvalid = verify_result.is_valid\nprint(f\"Verification result: {valid}\")\nassert valid is True\n</code></pre>   <pre><code>// The airline verifies the credential\ncredentialsService.setProfile(airline);\n// verifyProof() {\nvar verifyProofResponse = credentialsService.verifyProof(VerifiableCredentials.VerifyProofRequest.newBuilder().setProofDocumentJson(credentialProof).build()).get();\n// }\nvar isValid = verifyProofResponse.getIsValid();\nSystem.out.println(\"Verification result: \" + isValid);\nassert isValid;\n</code></pre>   <pre><code>walletService.SetToken(airline)\nfailError(t, \"error setting profile\", err)\n// verifyProof() {\nvalid, err := credentialService.VerifyProof(context.Background(), &amp;sdk.VerifyProofRequest{ProofDocumentJson: credential.SignedDocumentJson})\n// }\nfailError(t, \"error verifying proof\", err)\nfmt.Println(\"Validation result\", valid)\nif valid != true {\n    t.Fail()\n}\n</code></pre>    <p>Watch for the result of <code>true</code> to know that the credential successfully passed all of the verification processes.</p>  <p>Info</p> <p>Reference: Verify Proof</p>","title":"Verify Proof"},{"location":"walkthroughs/vaccination/#full-source-code","text":"TypescriptC#PythonJava   <p>browser node </p>   <p>This sample is available in our dotnet directory. </p>    <p>This sample is available as <code>ecosystem_demo.py</code></p>   <p>This sample is available in the Java directory.</p>","title":"Full Source Code"},{"location":"walkthroughs/vaccination/#next-steps","text":"<p>Congratulations! If you've completed all the steps of this walkthrough, you've just created a mini ecosystem of issuers, verifiers, and holders all exchanging credentials. Depending on your goals, there are a couple of possible next steps to take. </p> <ul> <li>Try out a sample app</li> <li>Learn more about wallets, credentials, templates, and ecosystems</li> <li>Review the SDK Reference</li> </ul>","title":"Next Steps:"},{"location":"walkthroughs/vaccination/#sample-applications","text":"<p>We have language specific sample applications that you can run to understand how the Trinsic SDK works in a development environment. </p> TypescriptC#PythonJava   <p>This sample is available in our node directory </p>   <p>This sample is available in our dotnet directory. </p>   <p>This sample is available in the python directory.</p>   <p>This sample is available in our Github repo in the java directory.</p>","title":"Sample Applications"},{"location":"web/","text":"<p>The Trinsic Web SDK makes it easy to interact with the Trinsic API from any client-side web application. You can find the SDKs source on Github.</p>","title":"The Trinsic Javascript / Web SDK"},{"location":"web/#installation","text":"<p>Install the package for Node or Browser from npmjs.com </p> Install   <pre><code>npm i @trinsic/trinsic\n</code></pre>","title":"Installation"},{"location":"web/#create-new-project","text":"<p>Let's create a new console app that we will use to add our sample code</p> <pre><code>mkdir web-sample &amp;&amp; cd web-sample &amp;&amp; npm init\n</code></pre> <p>You can select all the defaults for the node project.</p> <p>Add the required dependencies</p> <pre><code>npm i @trinsic/trinsic-web\n</code></pre> <pre><code>npm i --save-dev http-server webpack webpack-cli\n</code></pre>","title":"Create new project"},{"location":"web/#configure-webpack","text":"<p>After installing the dependencies you'll need a configuration file for webpack. Create a file called webpack.config.js at the root of your project and then copy and paste this into that file <pre><code>const path = require('path');\n\nmodule.exports = {\n  mode: 'development',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, './src'),\n    filename: 'bundle.js',\n  }\n};\n</code></pre></p>","title":"Configure Webpack"},{"location":"web/#configure-webpack-for-react","text":"<p>If using React you may need to start your project with craco</p> <p>Install Craco <pre><code>npm i @craco/craco\n</code></pre></p> <p>Next change your react scripts in your package.json file <pre><code>\"scripts\": {\n-   \"start\": \"react-scripts start\",\n+   \"start\": \"craco start\",\n-   \"build\": \"react-scripts build\",\n+   \"build\": \"craco build\"\n-   \"test\": \"react-scripts test\",\n+   \"test\": \"craco test\"\n}\n</code></pre> Finally you will need to add a craco configuration file called <code>craco.config.js</code> and add the following:</p> <pre><code>// craco.config.js\n\nconst { addBeforeLoader, loaderByName } = require('@craco/craco');\n\nmodule.exports = {\n  webpack: {\n    configure: (webpackConfig) =&gt; {\n      const wasmExtensionRegExp = /\\.wasm$/;\n      webpackConfig.resolve.extensions.push('.wasm');\n\n      webpackConfig.module.rules.forEach((rule) =&gt; {\n        (rule.oneOf || []).forEach((oneOf) =&gt; {\n          if (oneOf.loader &amp;&amp; oneOf.loader.indexOf('file-loader') &gt;= 0) {\n            oneOf.exclude.push(wasmExtensionRegExp);\n          }\n        });\n      });\n\n      const wasmLoader = {\n        test: /\\.wasm$/,\n        exclude: /node_modules/,\n        loaders: ['wasm-loader'],\n      };\n\n      addBeforeLoader(webpackConfig, loaderByName('file-loader'), wasmLoader);\n\n      return webpackConfig;\n    }\n  }\n}\n</code></pre> <p>This allows react loaders to properly load in some of our needed .wasm files.</p>","title":"Configure Webpack for React"},{"location":"web/#set-up-website","text":"<p>Create a simple html page with a script tag referencing the webpack bundle that will be built after completing the sample code. Note that you will not have the bundle.js file yet because it will be generated from the index.js file you create.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;title&gt;Web Sample&lt;/title&gt;\n  &lt;meta charset=\"UTF-8\" /&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n  &lt;meta name=\"description\" content=\"\" /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Web Sample&lt;/h1&gt;\n  &lt;div id=\"wallet\"&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;script src=\"../bundle.js\"&gt;&lt;/script&gt;\n&lt;/html&gt;\n</code></pre> <p>Your file structure should look like this</p> <pre><code>web-sample\n    src\n        index.html\n        index.js\n    package.json\n    webpack.config.js\n</code></pre>","title":"Set up Website"},{"location":"web/#next-steps","text":"<p>Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference</p> <p>Start Walkthrough Explore API</p>","title":"Next Steps"}]}